# -*- coding: utf-8 -*-

# Create a single .html file that shows photos and recorded gps tracks on hybrid google maps.
#
# Usage: python map_with_photos.py `find . -iname '*.jpg'` `find . -iname '*.gpx'`
# This creates the file 'map.html' which shows photos on a google maps.
# map.html have a relative path to the photos, so moving it breaks the photos.
#
# Opening map.html requires internet to access google maps.
# js dependencies are bundled into map.html.
#
# leaflet https://leafletjs.com/
# leaflet plugin marker cluster https://github.com/Leaflet/Leaflet.markercluster
# leaflet plugin photo https://github.com/turban/Leaflet.Photo
# leaflet plugin gpx https://github.com/mpetazzoni/leaflet-gpx
#
# gpx have changed to use inline marker icons and extra code to show
# number of points

import string
import sys
import json
import base64
import os
import stat
import PIL.Image
import PIL.ExifTags

template = """
<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css" integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/> -->
    <!-- <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js" integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og==" crossorigin=""></script> -->
    <!-- <link rel="stylesheet" href="https://combinatronics.com/Leaflet/Leaflet.markercluster/v1.4.0/dist/MarkerCluster.Default.css"/> -->
    <!-- <script src="https://combinatronics.com/Leaflet/Leaflet.markercluster/v1.4.0/dist/leaflet.markercluster.js"></script> -->
    <!-- <link rel="stylesheet" href="https://combinatronics.com/turban/Leaflet.Photo/gh-pages/Leaflet.Photo.css"/> -->
    <!-- <script src="https://combinatronics.com/turban/Leaflet.Photo/gh-pages/Leaflet.Photo.js"></script> -->
    <!-- <script src="https://combinatronics.com/mpetazzoni/leaflet-gpx/master/gpx.js"></script> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dygraph/2.1.0/dygraph.min.js"></script> -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dygraph/2.1.0/dygraph.min.css" /> -->
    <style>
/* required styles */

.leaflet-pane,
.leaflet-tile,
.leaflet-marker-icon,
.leaflet-marker-shadow,
.leaflet-tile-container,
.leaflet-pane > svg,
.leaflet-pane > canvas,
.leaflet-zoom-box,
.leaflet-image-layer,
.leaflet-layer {
	position: absolute;
	left: 0;
	top: 0;
	}
.leaflet-container {
	overflow: hidden;
	}
.leaflet-tile,
.leaflet-marker-icon,
.leaflet-marker-shadow {
	-webkit-user-select: none;
	   -moz-user-select: none;
	        user-select: none;
	  -webkit-user-drag: none;
	}
/* Prevents IE11 from highlighting tiles in blue */
.leaflet-tile::selection {
	background: transparent;
}
/* Safari renders non-retina tile on retina better with this, but Chrome is worse */
.leaflet-safari .leaflet-tile {
	image-rendering: -webkit-optimize-contrast;
	}
/* hack that prevents hw layers "stretching" when loading new tiles */
.leaflet-safari .leaflet-tile-container {
	width: 1600px;
	height: 1600px;
	-webkit-transform-origin: 0 0;
	}
.leaflet-marker-icon,
.leaflet-marker-shadow {
	display: block;
	}
/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */
/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */
.leaflet-container .leaflet-overlay-pane svg,
.leaflet-container .leaflet-marker-pane img,
.leaflet-container .leaflet-shadow-pane img,
.leaflet-container .leaflet-tile-pane img,
.leaflet-container img.leaflet-image-layer,
.leaflet-container .leaflet-tile {
	max-width: none !important;
	max-height: none !important;
	}

.leaflet-container.leaflet-touch-zoom {
	-ms-touch-action: pan-x pan-y;
	touch-action: pan-x pan-y;
	}
.leaflet-container.leaflet-touch-drag {
	-ms-touch-action: pinch-zoom;
	/* Fallback for FF which doesn't support pinch-zoom */
	touch-action: none;
	touch-action: pinch-zoom;
}
.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {
	-ms-touch-action: none;
	touch-action: none;
}
.leaflet-container {
	-webkit-tap-highlight-color: transparent;
}
.leaflet-container a {
	-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);
}
.leaflet-tile {
	filter: inherit;
	visibility: hidden;
	}
.leaflet-tile-loaded {
	visibility: inherit;
	}
.leaflet-zoom-box {
	width: 0;
	height: 0;
	-moz-box-sizing: border-box;
	     box-sizing: border-box;
	z-index: 800;
	}
/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */
.leaflet-overlay-pane svg {
	-moz-user-select: none;
	}

.leaflet-pane         { z-index: 400; }

.leaflet-tile-pane    { z-index: 200; }
.leaflet-overlay-pane { z-index: 400; }
.leaflet-shadow-pane  { z-index: 500; }
.leaflet-marker-pane  { z-index: 600; }
.leaflet-tooltip-pane   { z-index: 650; }
.leaflet-popup-pane   { z-index: 700; }

.leaflet-map-pane canvas { z-index: 100; }
.leaflet-map-pane svg    { z-index: 200; }

.leaflet-vml-shape {
	width: 1px;
	height: 1px;
	}
.lvml {
	behavior: url(#default#VML);
	display: inline-block;
	position: absolute;
	}


/* control positioning */

.leaflet-control {
	position: relative;
	z-index: 800;
	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
	pointer-events: auto;
	}
.leaflet-top,
.leaflet-bottom {
	position: absolute;
	z-index: 1000;
	pointer-events: none;
	}
.leaflet-top {
	top: 0;
	}
.leaflet-right {
	right: 0;
	}
.leaflet-bottom {
	bottom: 0;
	}
.leaflet-left {
	left: 0;
	}
.leaflet-control {
	float: left;
	clear: both;
	}
.leaflet-right .leaflet-control {
	float: right;
	}
.leaflet-top .leaflet-control {
	margin-top: 10px;
	}
.leaflet-bottom .leaflet-control {
	margin-bottom: 10px;
	}
.leaflet-left .leaflet-control {
	margin-left: 10px;
	}
.leaflet-right .leaflet-control {
	margin-right: 10px;
	}


/* zoom and fade animations */

.leaflet-fade-anim .leaflet-tile {
	will-change: opacity;
	}
.leaflet-fade-anim .leaflet-popup {
	opacity: 0;
	-webkit-transition: opacity 0.2s linear;
	   -moz-transition: opacity 0.2s linear;
	        transition: opacity 0.2s linear;
	}
.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
	opacity: 1;
	}
.leaflet-zoom-animated {
	-webkit-transform-origin: 0 0;
	    -ms-transform-origin: 0 0;
	        transform-origin: 0 0;
	}
.leaflet-zoom-anim .leaflet-zoom-animated {
	will-change: transform;
	}
.leaflet-zoom-anim .leaflet-zoom-animated {
	-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);
	   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);
	        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);
	}
.leaflet-zoom-anim .leaflet-tile,
.leaflet-pan-anim .leaflet-tile {
	-webkit-transition: none;
	   -moz-transition: none;
	        transition: none;
	}

.leaflet-zoom-anim .leaflet-zoom-hide {
	visibility: hidden;
	}


/* cursors */

.leaflet-interactive {
	cursor: pointer;
	}
.leaflet-grab {
	cursor: -webkit-grab;
	cursor:    -moz-grab;
	cursor:         grab;
	}
.leaflet-crosshair,
.leaflet-crosshair .leaflet-interactive {
	cursor: crosshair;
	}
.leaflet-popup-pane,
.leaflet-control {
	cursor: auto;
	}
.leaflet-dragging .leaflet-grab,
.leaflet-dragging .leaflet-grab .leaflet-interactive,
.leaflet-dragging .leaflet-marker-draggable {
	cursor: move;
	cursor: -webkit-grabbing;
	cursor:    -moz-grabbing;
	cursor:         grabbing;
	}

/* marker & overlays interactivity */
.leaflet-marker-icon,
.leaflet-marker-shadow,
.leaflet-image-layer,
.leaflet-pane > svg path,
.leaflet-tile-container {
	pointer-events: none;
	}

.leaflet-marker-icon.leaflet-interactive,
.leaflet-image-layer.leaflet-interactive,
.leaflet-pane > svg path.leaflet-interactive,
svg.leaflet-image-layer.leaflet-interactive path {
	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
	pointer-events: auto;
	}

/* visual tweaks */

.leaflet-container {
	background: #ddd;
	outline: 0;
	}
.leaflet-container a {
	color: #0078A8;
	}
.leaflet-container a.leaflet-active {
	outline: 2px solid orange;
	}
.leaflet-zoom-box {
	border: 2px dotted #38f;
	background: rgba(255,255,255,0.5);
	}


/* general typography */
.leaflet-container {
	font: 12px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif;
	}


/* general toolbar styles */

.leaflet-bar {
	box-shadow: 0 1px 5px rgba(0,0,0,0.65);
	border-radius: 4px;
	}
.leaflet-bar a,
.leaflet-bar a:hover {
	background-color: #fff;
	border-bottom: 1px solid #ccc;
	width: 26px;
	height: 26px;
	line-height: 26px;
	display: block;
	text-align: center;
	text-decoration: none;
	color: black;
	}
.leaflet-bar a,
.leaflet-control-layers-toggle {
	background-position: 50% 50%;
	background-repeat: no-repeat;
	display: block;
	}
.leaflet-bar a:hover {
	background-color: #f4f4f4;
	}
.leaflet-bar a:first-child {
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
	}
.leaflet-bar a:last-child {
	border-bottom-left-radius: 4px;
	border-bottom-right-radius: 4px;
	border-bottom: none;
	}
.leaflet-bar a.leaflet-disabled {
	cursor: default;
	background-color: #f4f4f4;
	color: #bbb;
	}

.leaflet-touch .leaflet-bar a {
	width: 30px;
	height: 30px;
	line-height: 30px;
	}
.leaflet-touch .leaflet-bar a:first-child {
	border-top-left-radius: 2px;
	border-top-right-radius: 2px;
	}
.leaflet-touch .leaflet-bar a:last-child {
	border-bottom-left-radius: 2px;
	border-bottom-right-radius: 2px;
	}

/* zoom control */

.leaflet-control-zoom-in,
.leaflet-control-zoom-out {
	font: bold 18px 'Lucida Console', Monaco, monospace;
	text-indent: 1px;
	}

.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {
	font-size: 22px;
	}


/* layers control */

.leaflet-control-layers {
	box-shadow: 0 1px 5px rgba(0,0,0,0.4);
	background: #fff;
	border-radius: 5px;
	}
.leaflet-control-layers-toggle {
	background-image: url(images/layers.png);
	width: 36px;
	height: 36px;
	}
.leaflet-retina .leaflet-control-layers-toggle {
	background-image: url(images/layers-2x.png);
	background-size: 26px 26px;
	}
.leaflet-touch .leaflet-control-layers-toggle {
	width: 44px;
	height: 44px;
	}
.leaflet-control-layers .leaflet-control-layers-list,
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {
	display: none;
	}
.leaflet-control-layers-expanded .leaflet-control-layers-list {
	display: block;
	position: relative;
	}
.leaflet-control-layers-expanded {
	padding: 6px 10px 6px 6px;
	color: #333;
	background: #fff;
	}
.leaflet-control-layers-scrollbar {
	overflow-y: scroll;
	overflow-x: hidden;
	padding-right: 5px;
	}
.leaflet-control-layers-selector {
	margin-top: 2px;
	position: relative;
	top: 1px;
	}
.leaflet-control-layers label {
	display: block;
	}
.leaflet-control-layers-separator {
	height: 0;
	border-top: 1px solid #ddd;
	margin: 5px -10px 5px -6px;
	}

/* Default icon URLs */
.leaflet-default-icon-path {
	background-image: url(images/marker-icon.png);
	}


/* attribution and scale controls */

.leaflet-container .leaflet-control-attribution {
	background: #fff;
	background: rgba(255, 255, 255, 0.7);
	margin: 0;
	}
.leaflet-control-attribution,
.leaflet-control-scale-line {
	padding: 0 5px;
	color: #333;
	}
.leaflet-control-attribution a {
	text-decoration: none;
	}
.leaflet-control-attribution a:hover {
	text-decoration: underline;
	}
.leaflet-container .leaflet-control-attribution,
.leaflet-container .leaflet-control-scale {
	font-size: 11px;
	}
.leaflet-left .leaflet-control-scale {
	margin-left: 5px;
	}
.leaflet-bottom .leaflet-control-scale {
	margin-bottom: 5px;
	}
.leaflet-control-scale-line {
	border: 2px solid #777;
	border-top: none;
	line-height: 1.1;
	padding: 2px 5px 1px;
	font-size: 11px;
	white-space: nowrap;
	overflow: hidden;
	-moz-box-sizing: border-box;
	     box-sizing: border-box;

	background: #fff;
	background: rgba(255, 255, 255, 0.5);
	}
.leaflet-control-scale-line:not(:first-child) {
	border-top: 2px solid #777;
	border-bottom: none;
	margin-top: -2px;
	}
.leaflet-control-scale-line:not(:first-child):not(:last-child) {
	border-bottom: 2px solid #777;
	}

.leaflet-touch .leaflet-control-attribution,
.leaflet-touch .leaflet-control-layers,
.leaflet-touch .leaflet-bar {
	box-shadow: none;
	}
.leaflet-touch .leaflet-control-layers,
.leaflet-touch .leaflet-bar {
	border: 2px solid rgba(0,0,0,0.2);
	background-clip: padding-box;
	}


/* popup */

.leaflet-popup {
	position: absolute;
	text-align: center;
	margin-bottom: 20px;
	}
.leaflet-popup-content-wrapper {
	padding: 1px;
	text-align: left;
	border-radius: 12px;
	}
.leaflet-popup-content {
	margin: 13px 19px;
	line-height: 1.4;
	}
.leaflet-popup-content p {
	margin: 18px 0;
	}
.leaflet-popup-tip-container {
	width: 40px;
	height: 20px;
	position: absolute;
	left: 50%;
	margin-left: -20px;
	overflow: hidden;
	pointer-events: none;
	}
.leaflet-popup-tip {
	width: 17px;
	height: 17px;
	padding: 1px;

	margin: -10px auto 0;

	-webkit-transform: rotate(45deg);
	   -moz-transform: rotate(45deg);
	    -ms-transform: rotate(45deg);
	        transform: rotate(45deg);
	}
.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
	background: white;
	color: #333;
	box-shadow: 0 3px 14px rgba(0,0,0,0.4);
	}
.leaflet-container a.leaflet-popup-close-button {
	position: absolute;
	top: 0;
	right: 0;
	padding: 4px 4px 0 0;
	border: none;
	text-align: center;
	width: 18px;
	height: 14px;
	font: 16px/14px Tahoma, Verdana, sans-serif;
	color: #c3c3c3;
	text-decoration: none;
	font-weight: bold;
	background: transparent;
	}
.leaflet-container a.leaflet-popup-close-button:hover {
	color: #999;
	}
.leaflet-popup-scrolled {
	overflow: auto;
	border-bottom: 1px solid #ddd;
	border-top: 1px solid #ddd;
	}

.leaflet-oldie .leaflet-popup-content-wrapper {
	zoom: 1;
	}
.leaflet-oldie .leaflet-popup-tip {
	width: 24px;
	margin: 0 auto;

	-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";
	filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
	}
.leaflet-oldie .leaflet-popup-tip-container {
	margin-top: -1px;
	}

.leaflet-oldie .leaflet-control-zoom,
.leaflet-oldie .leaflet-control-layers,
.leaflet-oldie .leaflet-popup-content-wrapper,
.leaflet-oldie .leaflet-popup-tip {
	border: 1px solid #999;
	}


/* div icon */

.leaflet-div-icon {
	background: #fff;
	border: 1px solid #666;
	}


/* Tooltip */
/* Base styles for the element that has a tooltip */
.leaflet-tooltip {
	position: absolute;
	padding: 6px;
	background-color: #fff;
	border: 1px solid #fff;
	border-radius: 3px;
	color: #222;
	white-space: nowrap;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	pointer-events: none;
	box-shadow: 0 1px 3px rgba(0,0,0,0.4);
	}
.leaflet-tooltip.leaflet-clickable {
	cursor: pointer;
	pointer-events: auto;
	}
.leaflet-tooltip-top:before,
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
	position: absolute;
	pointer-events: none;
	border: 6px solid transparent;
	background: transparent;
	content: "";
	}

/* Directions */

.leaflet-tooltip-bottom {
	margin-top: 6px;
}
.leaflet-tooltip-top {
	margin-top: -6px;
}
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-top:before {
	left: 50%;
	margin-left: -6px;
	}
.leaflet-tooltip-top:before {
	bottom: 0;
	margin-bottom: -12px;
	border-top-color: #fff;
	}
.leaflet-tooltip-bottom:before {
	top: 0;
	margin-top: -12px;
	margin-left: -6px;
	border-bottom-color: #fff;
	}
.leaflet-tooltip-left {
	margin-left: -6px;
}
.leaflet-tooltip-right {
	margin-left: 6px;
}
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
	top: 50%;
	margin-top: -6px;
	}
.leaflet-tooltip-left:before {
	right: 0;
	margin-right: -12px;
	border-left-color: #fff;
	}
.leaflet-tooltip-right:before {
	left: 0;
	margin-left: -12px;
	border-right-color: #fff;
	}



.marker-cluster-small {
	background-color: rgba(181, 226, 140, 0.6);
	}
.marker-cluster-small div {
	background-color: rgba(110, 204, 57, 0.6);
	}

.marker-cluster-medium {
	background-color: rgba(241, 211, 87, 0.6);
	}
.marker-cluster-medium div {
	background-color: rgba(240, 194, 12, 0.6);
	}

.marker-cluster-large {
	background-color: rgba(253, 156, 115, 0.6);
	}
.marker-cluster-large div {
	background-color: rgba(241, 128, 23, 0.6);
	}

	/* IE 6-8 fallback colors */
.leaflet-oldie .marker-cluster-small {
	background-color: rgb(181, 226, 140);
	}
.leaflet-oldie .marker-cluster-small div {
	background-color: rgb(110, 204, 57);
	}

.leaflet-oldie .marker-cluster-medium {
	background-color: rgb(241, 211, 87);
	}
.leaflet-oldie .marker-cluster-medium div {
	background-color: rgb(240, 194, 12);
	}

.leaflet-oldie .marker-cluster-large {
	background-color: rgb(253, 156, 115);
	}
.leaflet-oldie .marker-cluster-large div {
	background-color: rgb(241, 128, 23);
}

.marker-cluster {
	background-clip: padding-box;
	border-radius: 20px;
	}
.marker-cluster div {
	width: 30px;
	height: 30px;
	margin-left: 5px;
	margin-top: 5px;

	text-align: center;
	border-radius: 15px;
	font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
	}
.marker-cluster span {
	line-height: 30px;
}




.leaflet-marker-photo { 
	border: 2px solid #fff; 
	box-shadow: 3px 3px 10px #888; 
}	

.leaflet-marker-photo div { 
    width: 100%;  
    height: 100%;
    background-size: cover;    
    background-position: center center;
    background-repeat: no-repeat;
}	

.leaflet-marker-photo b {
	position: absolute;
	top: -7px;
	right: -11px;
	color: #555;
	background-color: #fff;
	border-radius: 8px;
	height: 12px;
	min-width: 12px;
	line-height: 12px;
	text-align: center;
	padding: 3px;
	box-shadow: 0 3px 14px rgba(0,0,0,0.4);
}


.dygraph-annotation,.dygraph-legend{
    overflow:hidden
}.dygraph-legend{
    position:absolute;
    font-size:14px;
    z-index:10;
    width:250px;
    background:#fff;
    line-height:normal;
    text-align:left
}.dygraph-legend-dash,.dygraph-legend-line{
    display:inline-block;
    position:relative;
    bottom:.5ex;
    height:1px;
    border-bottom-width:2px;
    border-bottom-style:solid
}.dygraph-legend-line{
    padding-left:1em
}.dygraph-annotation,.dygraph-roller{
    position:absolute;
    z-index:10
}.dygraph-default-annotation{
    border:1px solid #000;
    background-color:#fff;
    text-align:center
}.dygraph-axis-label{
    z-index:10;
    line-height:normal;
    overflow:hidden;
    color:#000
}.dygraph-title{
    font-weight:700;
    z-index:10;
    text-align:center
}.dygraph-xlabel{
    text-align:center
}.dygraph-label-rotate-left{
    text-align:center;
    transform:rotate(90deg);
    -webkit-transform:rotate(90deg);
    -moz-transform:rotate(90deg);
    -o-transform:rotate(90deg);
    -ms-transform:rotate(90deg)
}.dygraph-label-rotate-right{
    text-align:center;
    transform:rotate(-90deg);
    -webkit-transform:rotate(-90deg);
    -moz-transform:rotate(-90deg);
    -o-transform:rotate(-90deg);
    -ms-transform:rotate(-90deg)
}


      body {
        padding: 0;
        margin: 0;
      }
      html, body, #mapid {
        height: 100%;
        width: 100%;
      }
    </style>
    <script>
/* @preserve
 * Leaflet 1.5.1+build.2e3e0ff, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
! function(t, i) {
  "object" == typeof exports && "undefined" != typeof module ? i(exports) : "function" == typeof define && define.amd ? define(["exports"], i) : i(t.L = {})
}(this, function(t) {
  "use strict";
  var i = Object.freeze;

  function h(t) {
    var i, e, n, o;
    for (e = 1, n = arguments.length; e < n; e++)
      for (i in o = arguments[e]) t[i] = o[i];
    return t
  }
  Object.freeze = function(t) {
    return t
  };
  var s = Object.create || function(t) {
    return e.prototype = t, new e
  };

  function e() {}

  function a(t, i) {
    var e = Array.prototype.slice;
    if (t.bind) return t.bind.apply(t, e.call(arguments, 1));
    var n = e.call(arguments, 2);
    return function() {
      return t.apply(i, n.length ? n.concat(e.call(arguments)) : arguments)
    }
  }
  var n = 0;

  function u(t) {
    return t._leaflet_id = t._leaflet_id || ++n, t._leaflet_id
  }

  function o(t, i, e) {
    var n, o, s, r;
    return r = function() {
      n = !1, o && (s.apply(e, o), o = !1)
    }, s = function() {
      n ? o = arguments : (t.apply(e, arguments), setTimeout(r, i), n = !0)
    }
  }

  function r(t, i, e) {
    var n = i[1],
      o = i[0],
      s = n - o;
    return t === n && e ? t : ((t - o) % s + s) % s + o
  }

  function l() {
    return !1
  }

  function c(t, i) {
    return i = void 0 === i ? 6 : i, +(Math.round(t + "e+" + i) + "e-" + i)
  }

  function _(t) {
    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
  }

  function d(t) {
    return _(t).split(/\s+/)
  }

  function p(t, i) {
    for (var e in t.hasOwnProperty("options") || (t.options = t.options ? s(t.options) : {}), i) t.options[e] = i[e];
    return t.options
  }

  function m(t, i, e) {
    var n = [];
    for (var o in t) n.push(encodeURIComponent(e ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));
    return (i && -1 !== i.indexOf("?") ? "&" : "?") + n.join("&")
  }
  var f = /\{ *([\w_-]+) *\}/g;

  function g(t, n) {
    return t.replace(f, function(t, i) {
      var e = n[i];
      if (void 0 === e) throw new Error("No value provided for variable " + t);
      return "function" == typeof e && (e = e(n)), e
    })
  }
  var v = Array.isArray || function(t) {
    return "[object Array]" === Object.prototype.toString.call(t)
  };

  function y(t, i) {
    for (var e = 0; e < t.length; e++)
      if (t[e] === i) return e;
    return -1
  }
  var x = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

  function w(t) {
    return window["webkit" + t] || window["moz" + t] || window["ms" + t]
  }
  var P = 0;

  function b(t) {
    var i = +new Date,
      e = Math.max(0, 16 - (i - P));
    return P = i + e, window.setTimeout(t, e)
  }
  var T = window.requestAnimationFrame || w("RequestAnimationFrame") || b,
    z = window.cancelAnimationFrame || w("CancelAnimationFrame") || w("CancelRequestAnimationFrame") || function(t) {
      window.clearTimeout(t)
    };

  function M(t, i, e) {
    if (!e || T !== b) return T.call(window, a(t, i));
    t.call(i)
  }

  function C(t) {
    t && z.call(window, t)
  }
  var S = (Object.freeze || Object)({
    freeze: i,
    extend: h,
    create: s,
    bind: a,
    lastId: n,
    stamp: u,
    throttle: o,
    wrapNum: r,
    falseFn: l,
    formatNum: c,
    trim: _,
    splitWords: d,
    setOptions: p,
    getParamString: m,
    template: g,
    isArray: v,
    indexOf: y,
    emptyImageUrl: x,
    requestFn: T,
    cancelFn: z,
    requestAnimFrame: M,
    cancelAnimFrame: C
  });

  function Z() {}
  Z.extend = function(t) {
    function i() {
      this.initialize && this.initialize.apply(this, arguments), this.callInitHooks()
    }
    var e = i.__super__ = this.prototype,
      n = s(e);
    for (var o in (n.constructor = i).prototype = n, this) this.hasOwnProperty(o) && "prototype" !== o && "__super__" !== o && (i[o] = this[o]);
    return t.statics && (h(i, t.statics), delete t.statics), t.includes && (function(t) {
      if ("undefined" == typeof L || !L || !L.Mixin) return;
      t = v(t) ? t : [t];
      for (var i = 0; i < t.length; i++) t[i] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack)
    }(t.includes), h.apply(null, [n].concat(t.includes)), delete t.includes), n.options && (t.options = h(s(n.options), t.options)), h(n, t), n._initHooks = [], n.callInitHooks = function() {
      if (!this._initHooksCalled) {
        e.callInitHooks && e.callInitHooks.call(this), this._initHooksCalled = !0;
        for (var t = 0, i = n._initHooks.length; t < i; t++) n._initHooks[t].call(this)
      }
    }, i
  }, Z.include = function(t) {
    return h(this.prototype, t), this
  }, Z.mergeOptions = function(t) {
    return h(this.prototype.options, t), this
  }, Z.addInitHook = function(t) {
    var i = Array.prototype.slice.call(arguments, 1),
      e = "function" == typeof t ? t : function() {
        this[t].apply(this, i)
      };
    return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(e), this
  };
  var E = {
    on: function(t, i, e) {
      if ("object" == typeof t)
        for (var n in t) this._on(n, t[n], i);
      else
        for (var o = 0, s = (t = d(t)).length; o < s; o++) this._on(t[o], i, e);
      return this
    },
    off: function(t, i, e) {
      if (t)
        if ("object" == typeof t)
          for (var n in t) this._off(n, t[n], i);
        else
          for (var o = 0, s = (t = d(t)).length; o < s; o++) this._off(t[o], i, e);
      else delete this._events;
      return this
    },
    _on: function(t, i, e) {
      this._events = this._events || {};
      var n = this._events[t];
      n || (n = [], this._events[t] = n), e === this && (e = void 0);
      for (var o = {
          fn: i,
          ctx: e
        }, s = n, r = 0, a = s.length; r < a; r++)
        if (s[r].fn === i && s[r].ctx === e) return;
      s.push(o)
    },
    _off: function(t, i, e) {
      var n, o, s;
      if (this._events && (n = this._events[t]))
        if (i) {
          if (e === this && (e = void 0), n)
            for (o = 0, s = n.length; o < s; o++) {
              var r = n[o];
              if (r.ctx === e && r.fn === i) return r.fn = l, this._firingCount && (this._events[t] = n = n.slice()), void n.splice(o, 1)
            }
        } else {
          for (o = 0, s = n.length; o < s; o++) n[o].fn = l;
          delete this._events[t]
        }
    },
    fire: function(t, i, e) {
      if (!this.listens(t, e)) return this;
      var n = h({}, i, {
        type: t,
        target: this,
        sourceTarget: i && i.sourceTarget || this
      });
      if (this._events) {
        var o = this._events[t];
        if (o) {
          this._firingCount = this._firingCount + 1 || 1;
          for (var s = 0, r = o.length; s < r; s++) {
            var a = o[s];
            a.fn.call(a.ctx || this, n)
          }
          this._firingCount--
        }
      }
      return e && this._propagateEvent(n), this
    },
    listens: function(t, i) {
      var e = this._events && this._events[t];
      if (e && e.length) return !0;
      if (i)
        for (var n in this._eventParents)
          if (this._eventParents[n].listens(t, i)) return !0;
      return !1
    },
    once: function(t, i, e) {
      if ("object" == typeof t) {
        for (var n in t) this.once(n, t[n], i);
        return this
      }
      var o = a(function() {
        this.off(t, i, e).off(t, o, e)
      }, this);
      return this.on(t, i, e).on(t, o, e)
    },
    addEventParent: function(t) {
      return this._eventParents = this._eventParents || {}, this._eventParents[u(t)] = t, this
    },
    removeEventParent: function(t) {
      return this._eventParents && delete this._eventParents[u(t)], this
    },
    _propagateEvent: function(t) {
      for (var i in this._eventParents) this._eventParents[i].fire(t.type, h({
        layer: t.target,
        propagatedFrom: t.target
      }, t), !0)
    }
  };
  E.addEventListener = E.on, E.removeEventListener = E.clearAllEventListeners = E.off, E.addOneTimeEventListener = E.once, E.fireEvent = E.fire, E.hasEventListeners = E.listens;
  var k = Z.extend(E);

  function B(t, i, e) {
    this.x = e ? Math.round(t) : t, this.y = e ? Math.round(i) : i
  }
  var A = Math.trunc || function(t) {
    return 0 < t ? Math.floor(t) : Math.ceil(t)
  };

  function I(t, i, e) {
    return t instanceof B ? t : v(t) ? new B(t[0], t[1]) : null == t ? t : "object" == typeof t && "x" in t && "y" in t ? new B(t.x, t.y) : new B(t, i, e)
  }

  function O(t, i) {
    if (t)
      for (var e = i ? [t, i] : t, n = 0, o = e.length; n < o; n++) this.extend(e[n])
  }

  function R(t, i) {
    return !t || t instanceof O ? t : new O(t, i)
  }

  function N(t, i) {
    if (t)
      for (var e = i ? [t, i] : t, n = 0, o = e.length; n < o; n++) this.extend(e[n])
  }

  function D(t, i) {
    return t instanceof N ? t : new N(t, i)
  }

  function j(t, i, e) {
    if (isNaN(t) || isNaN(i)) throw new Error("Invalid LatLng object: (" + t + ", " + i + ")");
    this.lat = +t, this.lng = +i, void 0 !== e && (this.alt = +e)
  }

  function W(t, i, e) {
    return t instanceof j ? t : v(t) && "object" != typeof t[0] ? 3 === t.length ? new j(t[0], t[1], t[2]) : 2 === t.length ? new j(t[0], t[1]) : null : null == t ? t : "object" == typeof t && "lat" in t ? new j(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === i ? null : new j(t, i, e)
  }
  B.prototype = {
    clone: function() {
      return new B(this.x, this.y)
    },
    add: function(t) {
      return this.clone()._add(I(t))
    },
    _add: function(t) {
      return this.x += t.x, this.y += t.y, this
    },
    subtract: function(t) {
      return this.clone()._subtract(I(t))
    },
    _subtract: function(t) {
      return this.x -= t.x, this.y -= t.y, this
    },
    divideBy: function(t) {
      return this.clone()._divideBy(t)
    },
    _divideBy: function(t) {
      return this.x /= t, this.y /= t, this
    },
    multiplyBy: function(t) {
      return this.clone()._multiplyBy(t)
    },
    _multiplyBy: function(t) {
      return this.x *= t, this.y *= t, this
    },
    scaleBy: function(t) {
      return new B(this.x * t.x, this.y * t.y)
    },
    unscaleBy: function(t) {
      return new B(this.x / t.x, this.y / t.y)
    },
    round: function() {
      return this.clone()._round()
    },
    _round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    },
    floor: function() {
      return this.clone()._floor()
    },
    _floor: function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    },
    ceil: function() {
      return this.clone()._ceil()
    },
    _ceil: function() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    },
    trunc: function() {
      return this.clone()._trunc()
    },
    _trunc: function() {
      return this.x = A(this.x), this.y = A(this.y), this
    },
    distanceTo: function(t) {
      var i = (t = I(t)).x - this.x,
        e = t.y - this.y;
      return Math.sqrt(i * i + e * e)
    },
    equals: function(t) {
      return (t = I(t)).x === this.x && t.y === this.y
    },
    contains: function(t) {
      return t = I(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
    },
    toString: function() {
      return "Point(" + c(this.x) + ", " + c(this.y) + ")"
    }
  }, O.prototype = {
    extend: function(t) {
      return t = I(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this
    },
    getCenter: function(t) {
      return new B((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
    },
    getBottomLeft: function() {
      return new B(this.min.x, this.max.y)
    },
    getTopRight: function() {
      return new B(this.max.x, this.min.y)
    },
    getTopLeft: function() {
      return this.min
    },
    getBottomRight: function() {
      return this.max
    },
    getSize: function() {
      return this.max.subtract(this.min)
    },
    contains: function(t) {
      var i, e;
      return (t = "number" == typeof t[0] || t instanceof B ? I(t) : R(t)) instanceof O ? (i = t.min, e = t.max) : i = e = t, i.x >= this.min.x && e.x <= this.max.x && i.y >= this.min.y && e.y <= this.max.y
    },
    intersects: function(t) {
      t = R(t);
      var i = this.min,
        e = this.max,
        n = t.min,
        o = t.max,
        s = o.x >= i.x && n.x <= e.x,
        r = o.y >= i.y && n.y <= e.y;
      return s && r
    },
    overlaps: function(t) {
      t = R(t);
      var i = this.min,
        e = this.max,
        n = t.min,
        o = t.max,
        s = o.x > i.x && n.x < e.x,
        r = o.y > i.y && n.y < e.y;
      return s && r
    },
    isValid: function() {
      return !(!this.min || !this.max)
    }
  }, N.prototype = {
    extend: function(t) {
      var i, e, n = this._southWest,
        o = this._northEast;
      if (t instanceof j) e = i = t;
      else {
        if (!(t instanceof N)) return t ? this.extend(W(t) || D(t)) : this;
        if (i = t._southWest, e = t._northEast, !i || !e) return this
      }
      return n || o ? (n.lat = Math.min(i.lat, n.lat), n.lng = Math.min(i.lng, n.lng), o.lat = Math.max(e.lat, o.lat), o.lng = Math.max(e.lng, o.lng)) : (this._southWest = new j(i.lat, i.lng), this._northEast = new j(e.lat, e.lng)), this
    },
    pad: function(t) {
      var i = this._southWest,
        e = this._northEast,
        n = Math.abs(i.lat - e.lat) * t,
        o = Math.abs(i.lng - e.lng) * t;
      return new N(new j(i.lat - n, i.lng - o), new j(e.lat + n, e.lng + o))
    },
    getCenter: function() {
      return new j((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
    },
    getSouthWest: function() {
      return this._southWest
    },
    getNorthEast: function() {
      return this._northEast
    },
    getNorthWest: function() {
      return new j(this.getNorth(), this.getWest())
    },
    getSouthEast: function() {
      return new j(this.getSouth(), this.getEast())
    },
    getWest: function() {
      return this._southWest.lng
    },
    getSouth: function() {
      return this._southWest.lat
    },
    getEast: function() {
      return this._northEast.lng
    },
    getNorth: function() {
      return this._northEast.lat
    },
    contains: function(t) {
      t = "number" == typeof t[0] || t instanceof j || "lat" in t ? W(t) : D(t);
      var i, e, n = this._southWest,
        o = this._northEast;
      return t instanceof N ? (i = t.getSouthWest(), e = t.getNorthEast()) : i = e = t, i.lat >= n.lat && e.lat <= o.lat && i.lng >= n.lng && e.lng <= o.lng
    },
    intersects: function(t) {
      t = D(t);
      var i = this._southWest,
        e = this._northEast,
        n = t.getSouthWest(),
        o = t.getNorthEast(),
        s = o.lat >= i.lat && n.lat <= e.lat,
        r = o.lng >= i.lng && n.lng <= e.lng;
      return s && r
    },
    overlaps: function(t) {
      t = D(t);
      var i = this._southWest,
        e = this._northEast,
        n = t.getSouthWest(),
        o = t.getNorthEast(),
        s = o.lat > i.lat && n.lat < e.lat,
        r = o.lng > i.lng && n.lng < e.lng;
      return s && r
    },
    toBBoxString: function() {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
    },
    equals: function(t, i) {
      return !!t && (t = D(t), this._southWest.equals(t.getSouthWest(), i) && this._northEast.equals(t.getNorthEast(), i))
    },
    isValid: function() {
      return !(!this._southWest || !this._northEast)
    }
  };
  var H, F = {
      latLngToPoint: function(t, i) {
        var e = this.projection.project(t),
          n = this.scale(i);
        return this.transformation._transform(e, n)
      },
      pointToLatLng: function(t, i) {
        var e = this.scale(i),
          n = this.transformation.untransform(t, e);
        return this.projection.unproject(n)
      },
      project: function(t) {
        return this.projection.project(t)
      },
      unproject: function(t) {
        return this.projection.unproject(t)
      },
      scale: function(t) {
        return 256 * Math.pow(2, t)
      },
      zoom: function(t) {
        return Math.log(t / 256) / Math.LN2
      },
      getProjectedBounds: function(t) {
        if (this.infinite) return null;
        var i = this.projection.bounds,
          e = this.scale(t);
        return new O(this.transformation.transform(i.min, e), this.transformation.transform(i.max, e))
      },
      infinite: !(j.prototype = {
        equals: function(t, i) {
          return !!t && (t = W(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === i ? 1e-9 : i))
        },
        toString: function(t) {
          return "LatLng(" + c(this.lat, t) + ", " + c(this.lng, t) + ")"
        },
        distanceTo: function(t) {
          return U.distance(this, W(t))
        },
        wrap: function() {
          return U.wrapLatLng(this)
        },
        toBounds: function(t) {
          var i = 180 * t / 40075017,
            e = i / Math.cos(Math.PI / 180 * this.lat);
          return D([this.lat - i, this.lng - e], [this.lat + i, this.lng + e])
        },
        clone: function() {
          return new j(this.lat, this.lng, this.alt)
        }
      }),
      wrapLatLng: function(t) {
        var i = this.wrapLng ? r(t.lng, this.wrapLng, !0) : t.lng;
        return new j(this.wrapLat ? r(t.lat, this.wrapLat, !0) : t.lat, i, t.alt)
      },
      wrapLatLngBounds: function(t) {
        var i = t.getCenter(),
          e = this.wrapLatLng(i),
          n = i.lat - e.lat,
          o = i.lng - e.lng;
        if (0 == n && 0 == o) return t;
        var s = t.getSouthWest(),
          r = t.getNorthEast();
        return new N(new j(s.lat - n, s.lng - o), new j(r.lat - n, r.lng - o))
      }
    },
    U = h({}, F, {
      wrapLng: [-180, 180],
      R: 6371e3,
      distance: function(t, i) {
        var e = Math.PI / 180,
          n = t.lat * e,
          o = i.lat * e,
          s = Math.sin((i.lat - t.lat) * e / 2),
          r = Math.sin((i.lng - t.lng) * e / 2),
          a = s * s + Math.cos(n) * Math.cos(o) * r * r,
          h = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return this.R * h
      }
    }),
    V = 6378137,
    q = {
      R: V,
      MAX_LATITUDE: 85.0511287798,
      project: function(t) {
        var i = Math.PI / 180,
          e = this.MAX_LATITUDE,
          n = Math.max(Math.min(e, t.lat), -e),
          o = Math.sin(n * i);
        return new B(this.R * t.lng * i, this.R * Math.log((1 + o) / (1 - o)) / 2)
      },
      unproject: function(t) {
        var i = 180 / Math.PI;
        return new j((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * i, t.x * i / this.R)
      },
      bounds: (H = V * Math.PI, new O([-H, -H], [H, H]))
    };

  function G(t, i, e, n) {
    if (v(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void(this._d = t[3]);
    this._a = t, this._b = i, this._c = e, this._d = n
  }

  function K(t, i, e, n) {
    return new G(t, i, e, n)
  }
  G.prototype = {
    transform: function(t, i) {
      return this._transform(t.clone(), i)
    },
    _transform: function(t, i) {
      return i = i || 1, t.x = i * (this._a * t.x + this._b), t.y = i * (this._c * t.y + this._d), t
    },
    untransform: function(t, i) {
      return i = i || 1, new B((t.x / i - this._b) / this._a, (t.y / i - this._d) / this._c)
    }
  };
  var Y, X = h({}, U, {
      code: "EPSG:3857",
      projection: q,
      transformation: (Y = .5 / (Math.PI * q.R), K(Y, .5, -Y, .5))
    }),
    J = h({}, X, {
      code: "EPSG:900913"
    });

  function $(t) {
    return document.createElementNS("http://www.w3.org/2000/svg", t)
  }

  function Q(t, i) {
    var e, n, o, s, r, a, h = "";
    for (e = 0, o = t.length; e < o; e++) {
      for (n = 0, s = (r = t[e]).length; n < s; n++) h += (n ? "L" : "M") + (a = r[n]).x + " " + a.y;
      h += i ? Zt ? "z" : "x" : ""
    }
    return h || "M0 0"
  }
  var tt = document.documentElement.style,
    it = "ActiveXObject" in window,
    et = it && !document.addEventListener,
    nt = "msLaunchUri" in navigator && !("documentMode" in document),
    ot = kt("webkit"),
    st = kt("android"),
    rt = kt("android 2") || kt("android 3"),
    at = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10),
    ht = st && kt("Google") && at < 537 && !("AudioNode" in window),
    ut = !!window.opera,
    lt = kt("chrome"),
    ct = kt("gecko") && !ot && !ut && !it,
    _t = !lt && kt("safari"),
    dt = kt("phantom"),
    pt = "OTransition" in tt,
    mt = 0 === navigator.platform.indexOf("Win"),
    ft = it && "transition" in tt,
    gt = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !rt,
    vt = "MozPerspective" in tt,
    yt = !window.L_DISABLE_3D && (ft || gt || vt) && !pt && !dt,
    xt = "undefined" != typeof orientation || kt("mobile"),
    wt = xt && ot,
    Pt = xt && gt,
    bt = !window.PointerEvent && window.MSPointerEvent,
    Lt = !(!window.PointerEvent && !bt),
    Tt = !window.L_NO_TOUCH && (Lt || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    zt = xt && ut,
    Mt = xt && ct,
    Ct = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI),
    St = !!document.createElement("canvas").getContext,
    Zt = !(!document.createElementNS || !$("svg").createSVGRect),
    Et = !Zt && function() {
      try {
        var t = document.createElement("div");
        t.innerHTML = '<v:shape adj="1"/>';
        var i = t.firstChild;
        return i.style.behavior = "url(#default#VML)", i && "object" == typeof i.adj
      } catch (t) {
        return !1
      }
    }();

  function kt(t) {
    return 0 <= navigator.userAgent.toLowerCase().indexOf(t)
  }
  var Bt = (Object.freeze || Object)({
      ie: it,
      ielt9: et,
      edge: nt,
      webkit: ot,
      android: st,
      android23: rt,
      androidStock: ht,
      opera: ut,
      chrome: lt,
      gecko: ct,
      safari: _t,
      phantom: dt,
      opera12: pt,
      win: mt,
      ie3d: ft,
      webkit3d: gt,
      gecko3d: vt,
      any3d: yt,
      mobile: xt,
      mobileWebkit: wt,
      mobileWebkit3d: Pt,
      msPointer: bt,
      pointer: Lt,
      touch: Tt,
      mobileOpera: zt,
      mobileGecko: Mt,
      retina: Ct,
      canvas: St,
      svg: Zt,
      vml: Et
    }),
    At = bt ? "MSPointerDown" : "pointerdown",
    It = bt ? "MSPointerMove" : "pointermove",
    Ot = bt ? "MSPointerUp" : "pointerup",
    Rt = bt ? "MSPointerCancel" : "pointercancel",
    Nt = ["INPUT", "SELECT", "OPTION"],
    Dt = {},
    jt = !1,
    Wt = 0;

  function Ht(t, i, e, n) {
    return "touchstart" === i ? function(t, i, e) {
      var n = a(function(t) {
        if ("mouse" !== t.pointerType && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE) {
          if (!(Nt.indexOf(t.target.tagName) < 0)) return;
          Di(t)
        }
        qt(t, i)
      });
      t["_leaflet_touchstart" + e] = n, t.addEventListener(At, n, !1), jt || (document.documentElement.addEventListener(At, Ft, !0), document.documentElement.addEventListener(It, Ut, !0), document.documentElement.addEventListener(Ot, Vt, !0), document.documentElement.addEventListener(Rt, Vt, !0), jt = !0)
    }(t, e, n) : "touchmove" === i ? function(t, i, e) {
      var n = function(t) {
        (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) && qt(t, i)
      };
      t["_leaflet_touchmove" + e] = n, t.addEventListener(It, n, !1)
    }(t, e, n) : "touchend" === i && function(t, i, e) {
      var n = function(t) {
        qt(t, i)
      };
      t["_leaflet_touchend" + e] = n, t.addEventListener(Ot, n, !1), t.addEventListener(Rt, n, !1)
    }(t, e, n), this
  }

  function Ft(t) {
    Dt[t.pointerId] = t, Wt++
  }

  function Ut(t) {
    Dt[t.pointerId] && (Dt[t.pointerId] = t)
  }

  function Vt(t) {
    delete Dt[t.pointerId], Wt--
  }

  function qt(t, i) {
    for (var e in t.touches = [], Dt) t.touches.push(Dt[e]);
    t.changedTouches = [t], i(t)
  }
  var Gt = bt ? "MSPointerDown" : Lt ? "pointerdown" : "touchstart",
    Kt = bt ? "MSPointerUp" : Lt ? "pointerup" : "touchend",
    Yt = "_leaflet_";

  function Xt(t, o, i) {
    var s, r, a = !1;

    function e(t) {
      var i;
      if (Lt) {
        if (!nt || "mouse" === t.pointerType) return;
        i = Wt
      } else i = t.touches.length;
      if (!(1 < i)) {
        var e = Date.now(),
          n = e - (s || e);
        r = t.touches ? t.touches[0] : t, a = 0 < n && n <= 250, s = e
      }
    }

    function n(t) {
      if (a && !r.cancelBubble) {
        if (Lt) {
          if (!nt || "mouse" === t.pointerType) return;
          var i, e, n = {};
          for (e in r) i = r[e], n[e] = i && i.bind ? i.bind(r) : i;
          r = n
        }
        r.type = "dblclick", r.button = 0, o(r), s = null
      }
    }
    return t[Yt + Gt + i] = e, t[Yt + Kt + i] = n, t[Yt + "dblclick" + i] = o, t.addEventListener(Gt, e, !1), t.addEventListener(Kt, n, !1), t.addEventListener("dblclick", o, !1), this
  }

  function Jt(t, i) {
    var e = t[Yt + Gt + i],
      n = t[Yt + Kt + i],
      o = t[Yt + "dblclick" + i];
    return t.removeEventListener(Gt, e, !1), t.removeEventListener(Kt, n, !1), nt || t.removeEventListener("dblclick", o, !1), this
  }
  var $t, Qt, ti, ii, ei, ni = yi(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]),
    oi = yi(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]),
    si = "webkitTransition" === oi || "OTransition" === oi ? oi + "End" : "transitionend";

  function ri(t) {
    return "string" == typeof t ? document.getElementById(t) : t
  }

  function ai(t, i) {
    var e = t.style[i] || t.currentStyle && t.currentStyle[i];
    if ((!e || "auto" === e) && document.defaultView) {
      var n = document.defaultView.getComputedStyle(t, null);
      e = n ? n[i] : null
    }
    return "auto" === e ? null : e
  }

  function hi(t, i, e) {
    var n = document.createElement(t);
    return n.className = i || "", e && e.appendChild(n), n
  }

  function ui(t) {
    var i = t.parentNode;
    i && i.removeChild(t)
  }

  function li(t) {
    for (; t.firstChild;) t.removeChild(t.firstChild)
  }

  function ci(t) {
    var i = t.parentNode;
    i && i.lastChild !== t && i.appendChild(t)
  }

  function _i(t) {
    var i = t.parentNode;
    i && i.firstChild !== t && i.insertBefore(t, i.firstChild)
  }

  function di(t, i) {
    if (void 0 !== t.classList) return t.classList.contains(i);
    var e = gi(t);
    return 0 < e.length && new RegExp("(^|\\s)" + i + "(\\s|$)").test(e)
  }

  function pi(t, i) {
    if (void 0 !== t.classList)
      for (var e = d(i), n = 0, o = e.length; n < o; n++) t.classList.add(e[n]);
    else if (!di(t, i)) {
      var s = gi(t);
      fi(t, (s ? s + " " : "") + i)
    }
  }

  function mi(t, i) {
    void 0 !== t.classList ? t.classList.remove(i) : fi(t, _((" " + gi(t) + " ").replace(" " + i + " ", " ")))
  }

  function fi(t, i) {
    void 0 === t.className.baseVal ? t.className = i : t.className.baseVal = i
  }

  function gi(t) {
    return t.correspondingElement && (t = t.correspondingElement), void 0 === t.className.baseVal ? t.className : t.className.baseVal
  }

  function vi(t, i) {
    "opacity" in t.style ? t.style.opacity = i : "filter" in t.style && function(t, i) {
      var e = !1,
        n = "DXImageTransform.Microsoft.Alpha";
      try {
        e = t.filters.item(n)
      } catch (t) {
        if (1 === i) return
      }
      i = Math.round(100 * i), e ? (e.Enabled = 100 !== i, e.Opacity = i) : t.style.filter += " progid:" + n + "(opacity=" + i + ")"
    }(t, i)
  }

  function yi(t) {
    for (var i = document.documentElement.style, e = 0; e < t.length; e++)
      if (t[e] in i) return t[e];
    return !1
  }

  function xi(t, i, e) {
    var n = i || new B(0, 0);
    t.style[ni] = (ft ? "translate(" + n.x + "px," + n.y + "px)" : "translate3d(" + n.x + "px," + n.y + "px,0)") + (e ? " scale(" + e + ")" : "")
  }

  function wi(t, i) {
    t._leaflet_pos = i, yt ? xi(t, i) : (t.style.left = i.x + "px", t.style.top = i.y + "px")
  }

  function Pi(t) {
    return t._leaflet_pos || new B(0, 0)
  }
  if ("onselectstart" in document) $t = function() {
    Ei(window, "selectstart", Di)
  }, Qt = function() {
    Bi(window, "selectstart", Di)
  };
  else {
    var bi = yi(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
    $t = function() {
      if (bi) {
        var t = document.documentElement.style;
        ti = t[bi], t[bi] = "none"
      }
    }, Qt = function() {
      bi && (document.documentElement.style[bi] = ti, ti = void 0)
    }
  }

  function Li() {
    Ei(window, "dragstart", Di)
  }

  function Ti() {
    Bi(window, "dragstart", Di)
  }

  function zi(t) {
    for (; - 1 === t.tabIndex;) t = t.parentNode;
    t.style && (Mi(), ei = (ii = t).style.outline, t.style.outline = "none", Ei(window, "keydown", Mi))
  }

  function Mi() {
    ii && (ii.style.outline = ei, ei = ii = void 0, Bi(window, "keydown", Mi))
  }

  function Ci(t) {
    for (; !((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body););
    return t
  }

  function Si(t) {
    var i = t.getBoundingClientRect();
    return {
      x: i.width / t.offsetWidth || 1,
      y: i.height / t.offsetHeight || 1,
      boundingClientRect: i
    }
  }
  var Zi = (Object.freeze || Object)({
    TRANSFORM: ni,
    TRANSITION: oi,
    TRANSITION_END: si,
    get: ri,
    getStyle: ai,
    create: hi,
    remove: ui,
    empty: li,
    toFront: ci,
    toBack: _i,
    hasClass: di,
    addClass: pi,
    removeClass: mi,
    setClass: fi,
    getClass: gi,
    setOpacity: vi,
    testProp: yi,
    setTransform: xi,
    setPosition: wi,
    getPosition: Pi,
    disableTextSelection: $t,
    enableTextSelection: Qt,
    disableImageDrag: Li,
    enableImageDrag: Ti,
    preventOutline: zi,
    restoreOutline: Mi,
    getSizedParentNode: Ci,
    getScale: Si
  });

  function Ei(t, i, e, n) {
    if ("object" == typeof i)
      for (var o in i) Ai(t, o, i[o], e);
    else
      for (var s = 0, r = (i = d(i)).length; s < r; s++) Ai(t, i[s], e, n);
    return this
  }
  var ki = "_leaflet_events";

  function Bi(t, i, e, n) {
    if ("object" == typeof i)
      for (var o in i) Ii(t, o, i[o], e);
    else if (i)
      for (var s = 0, r = (i = d(i)).length; s < r; s++) Ii(t, i[s], e, n);
    else {
      for (var a in t[ki]) Ii(t, a, t[ki][a]);
      delete t[ki]
    }
    return this
  }

  function Ai(i, t, e, n) {
    var o = t + u(e) + (n ? "_" + u(n) : "");
    if (i[ki] && i[ki][o]) return this;
    var s = function(t) {
        return e.call(n || i, t || window.event)
      },
      r = s;
    Lt && 0 === t.indexOf("touch") ? Ht(i, t, s, o) : !Tt || "dblclick" !== t || Lt && lt ? "addEventListener" in i ? "mousewheel" === t ? i.addEventListener("onwheel" in i ? "wheel" : "mousewheel", s, !1) : "mouseenter" === t || "mouseleave" === t ? (s = function(t) {
      t = t || window.event, Ki(i, t) && r(t)
    }, i.addEventListener("mouseenter" === t ? "mouseover" : "mouseout", s, !1)) : ("click" === t && st && (s = function(t) {
      ! function(t, i) {
        var e = t.timeStamp || t.originalEvent && t.originalEvent.timeStamp,
          n = Ui && e - Ui;
        if (n && 100 < n && n < 500 || t.target._simulatedClick && !t._simulated) return ji(t);
        Ui = e, i(t)
      }(t, r)
    }), i.addEventListener(t, s, !1)) : "attachEvent" in i && i.attachEvent("on" + t, s) : Xt(i, s, o), i[ki] = i[ki] || {}, i[ki][o] = s
  }

  function Ii(t, i, e, n) {
    var o = i + u(e) + (n ? "_" + u(n) : ""),
      s = t[ki] && t[ki][o];
    if (!s) return this;
    Lt && 0 === i.indexOf("touch") ? function(t, i, e) {
      var n = t["_leaflet_" + i + e];
      "touchstart" === i ? t.removeEventListener(At, n, !1) : "touchmove" === i ? t.removeEventListener(It, n, !1) : "touchend" === i && (t.removeEventListener(Ot, n, !1), t.removeEventListener(Rt, n, !1))
    }(t, i, o) : !Tt || "dblclick" !== i || Lt && lt ? "removeEventListener" in t ? "mousewheel" === i ? t.removeEventListener("onwheel" in t ? "wheel" : "mousewheel", s, !1) : t.removeEventListener("mouseenter" === i ? "mouseover" : "mouseleave" === i ? "mouseout" : i, s, !1) : "detachEvent" in t && t.detachEvent("on" + i, s) : Jt(t, o), t[ki][o] = null
  }

  function Oi(t) {
    return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, Gi(t), this
  }

  function Ri(t) {
    return Ai(t, "mousewheel", Oi), this
  }

  function Ni(t) {
    return Ei(t, "mousedown touchstart dblclick", Oi), Ai(t, "click", qi), this
  }

  function Di(t) {
    return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this
  }

  function ji(t) {
    return Di(t), Oi(t), this
  }

  function Wi(t, i) {
    if (!i) return new B(t.clientX, t.clientY);
    var e = Si(i),
      n = e.boundingClientRect;
    return new B((t.clientX - n.left) / e.x - i.clientLeft, (t.clientY - n.top) / e.y - i.clientTop)
  }
  var Hi = mt && lt ? 2 * window.devicePixelRatio : ct ? window.devicePixelRatio : 1;

  function Fi(t) {
    return nt ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / Hi : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0
  }
  var Ui, Vi = {};

  function qi(t) {
    Vi[t.type] = !0
  }

  function Gi(t) {
    var i = Vi[t.type];
    return Vi[t.type] = !1, i
  }

  function Ki(t, i) {
    var e = i.relatedTarget;
    if (!e) return !0;
    try {
      for (; e && e !== t;) e = e.parentNode
    } catch (t) {
      return !1
    }
    return e !== t
  }
  var Yi = (Object.freeze || Object)({
      on: Ei,
      off: Bi,
      stopPropagation: Oi,
      disableScrollPropagation: Ri,
      disableClickPropagation: Ni,
      preventDefault: Di,
      stop: ji,
      getMousePosition: Wi,
      getWheelDelta: Fi,
      fakeStop: qi,
      skipped: Gi,
      isExternalTarget: Ki,
      addListener: Ei,
      removeListener: Bi
    }),
    Xi = k.extend({
      run: function(t, i, e, n) {
        this.stop(), this._el = t, this._inProgress = !0, this._duration = e || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = Pi(t), this._offset = i.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate()
      },
      stop: function() {
        this._inProgress && (this._step(!0), this._complete())
      },
      _animate: function() {
        this._animId = M(this._animate, this), this._step()
      },
      _step: function(t) {
        var i = +new Date - this._startTime,
          e = 1e3 * this._duration;
        i < e ? this._runFrame(this._easeOut(i / e), t) : (this._runFrame(1), this._complete())
      },
      _runFrame: function(t, i) {
        var e = this._startPos.add(this._offset.multiplyBy(t));
        i && e._round(), wi(this._el, e), this.fire("step")
      },
      _complete: function() {
        C(this._animId), this._inProgress = !1, this.fire("end")
      },
      _easeOut: function(t) {
        return 1 - Math.pow(1 - t, this._easeOutPower)
      }
    }),
    Ji = k.extend({
      options: {
        crs: X,
        center: void 0,
        zoom: void 0,
        minZoom: void 0,
        maxZoom: void 0,
        layers: [],
        maxBounds: void 0,
        renderer: void 0,
        zoomAnimation: !0,
        zoomAnimationThreshold: 4,
        fadeAnimation: !0,
        markerZoomAnimation: !0,
        transform3DLimit: 8388608,
        zoomSnap: 1,
        zoomDelta: 1,
        trackResize: !0
      },
      initialize: function(t, i) {
        i = p(this, i), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = a(this._onResize, this), this._initEvents(), i.maxBounds && this.setMaxBounds(i.maxBounds), void 0 !== i.zoom && (this._zoom = this._limitZoom(i.zoom)), i.center && void 0 !== i.zoom && this.setView(W(i.center), i.zoom, {
          reset: !0
        }), this.callInitHooks(), this._zoomAnimated = oi && yt && !zt && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Ei(this._proxy, si, this._catchTransitionEnd, this)), this._addLayers(this.options.layers)
      },
      setView: function(t, i, e) {
        if ((i = void 0 === i ? this._zoom : this._limitZoom(i), t = this._limitCenter(W(t), i, this.options.maxBounds), e = e || {}, this._stop(), this._loaded && !e.reset && !0 !== e) && (void 0 !== e.animate && (e.zoom = h({
            animate: e.animate
          }, e.zoom), e.pan = h({
            animate: e.animate,
            duration: e.duration
          }, e.pan)), this._zoom !== i ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, i, e.zoom) : this._tryAnimatedPan(t, e.pan))) return clearTimeout(this._sizeTimer), this;
        return this._resetView(t, i), this
      },
      setZoom: function(t, i) {
        return this._loaded ? this.setView(this.getCenter(), t, {
          zoom: i
        }) : (this._zoom = t, this)
      },
      zoomIn: function(t, i) {
        return t = t || (yt ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, i)
      },
      zoomOut: function(t, i) {
        return t = t || (yt ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, i)
      },
      setZoomAround: function(t, i, e) {
        var n = this.getZoomScale(i),
          o = this.getSize().divideBy(2),
          s = (t instanceof B ? t : this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1 - 1 / n),
          r = this.containerPointToLatLng(o.add(s));
        return this.setView(r, i, {
          zoom: e
        })
      },
      _getBoundsCenterZoom: function(t, i) {
        i = i || {}, t = t.getBounds ? t.getBounds() : D(t);
        var e = I(i.paddingTopLeft || i.padding || [0, 0]),
          n = I(i.paddingBottomRight || i.padding || [0, 0]),
          o = this.getBoundsZoom(t, !1, e.add(n));
        if ((o = "number" == typeof i.maxZoom ? Math.min(i.maxZoom, o) : o) === 1 / 0) return {
          center: t.getCenter(),
          zoom: o
        };
        var s = n.subtract(e).divideBy(2),
          r = this.project(t.getSouthWest(), o),
          a = this.project(t.getNorthEast(), o);
        return {
          center: this.unproject(r.add(a).divideBy(2).add(s), o),
          zoom: o
        }
      },
      fitBounds: function(t, i) {
        if (!(t = D(t)).isValid()) throw new Error("Bounds are not valid.");
        var e = this._getBoundsCenterZoom(t, i);
        return this.setView(e.center, e.zoom, i)
      },
      fitWorld: function(t) {
        return this.fitBounds([
          [-90, -180],
          [90, 180]
        ], t)
      },
      panTo: function(t, i) {
        return this.setView(t, this._zoom, {
          pan: i
        })
      },
      panBy: function(t, i) {
        if (i = i || {}, !(t = I(t).round()).x && !t.y) return this.fire("moveend");
        if (!0 !== i.animate && !this.getSize().contains(t)) return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this;
        if (this._panAnim || (this._panAnim = new Xi, this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this)), i.noMoveStart || this.fire("movestart"), !1 !== i.animate) {
          pi(this._mapPane, "leaflet-pan-anim");
          var e = this._getMapPanePos().subtract(t).round();
          this._panAnim.run(this._mapPane, e, i.duration || .25, i.easeLinearity)
        } else this._rawPanBy(t), this.fire("move").fire("moveend");
        return this
      },
      flyTo: function(n, o, t) {
        if (!1 === (t = t || {}).animate || !yt) return this.setView(n, o, t);
        this._stop();
        var s = this.project(this.getCenter()),
          r = this.project(n),
          i = this.getSize(),
          a = this._zoom;
        n = W(n), o = void 0 === o ? a : o;
        var h = Math.max(i.x, i.y),
          u = h * this.getZoomScale(a, o),
          l = r.distanceTo(s) || 1,
          c = 1.42,
          _ = c * c;

        function e(t) {
          var i = (u * u - h * h + (t ? -1 : 1) * _ * _ * l * l) / (2 * (t ? u : h) * _ * l),
            e = Math.sqrt(i * i + 1) - i;
          return e < 1e-9 ? -18 : Math.log(e)
        }

        function d(t) {
          return (Math.exp(t) - Math.exp(-t)) / 2
        }

        function p(t) {
          return (Math.exp(t) + Math.exp(-t)) / 2
        }
        var m = e(0);

        function f(t) {
          return h * (p(m) * function(t) {
            return d(t) / p(t)
          }(m + c * t) - d(m)) / _
        }
        var g = Date.now(),
          v = (e(1) - m) / c,
          y = t.duration ? 1e3 * t.duration : 1e3 * v * .8;
        return this._moveStart(!0, t.noMoveStart),
          function t() {
            var i = (Date.now() - g) / y,
              e = function(t) {
                return 1 - Math.pow(1 - t, 1.5)
              }(i) * v;
            i <= 1 ? (this._flyToFrame = M(t, this), this._move(this.unproject(s.add(r.subtract(s).multiplyBy(f(e) / l)), a), this.getScaleZoom(h / function(t) {
              return h * (p(m) / p(m + c * t))
            }(e), a), {
              flyTo: !0
            })) : this._move(n, o)._moveEnd(!0)
          }.call(this), this
      },
      flyToBounds: function(t, i) {
        var e = this._getBoundsCenterZoom(t, i);
        return this.flyTo(e.center, e.zoom, i)
      },
      setMaxBounds: function(t) {
        return (t = D(t)).isValid() ? (this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off("moveend", this._panInsideMaxBounds))
      },
      setMinZoom: function(t) {
        var i = this.options.minZoom;
        return this.options.minZoom = t, this._loaded && i !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this
      },
      setMaxZoom: function(t) {
        var i = this.options.maxZoom;
        return this.options.maxZoom = t, this._loaded && i !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this
      },
      panInsideBounds: function(t, i) {
        this._enforcingBounds = !0;
        var e = this.getCenter(),
          n = this._limitCenter(e, this._zoom, D(t));
        return e.equals(n) || this.panTo(n, i), this._enforcingBounds = !1, this
      },
      panInside: function(t, i) {
        var e = I((i = i || {}).paddingTopLeft || i.padding || [0, 0]),
          n = I(i.paddingBottomRight || i.padding || [0, 0]),
          o = this.getCenter(),
          s = this.project(o),
          r = this.project(t),
          a = this.getPixelBounds(),
          h = a.getSize().divideBy(2),
          u = R([a.min.add(e), a.max.subtract(n)]);
        if (!u.contains(r)) {
          this._enforcingBounds = !0;
          var l = s.subtract(r),
            c = I(r.x + l.x, r.y + l.y);
          (r.x < u.min.x || r.x > u.max.x) && (c.x = s.x - l.x, 0 < l.x ? c.x += h.x - e.x : c.x -= h.x - n.x), (r.y < u.min.y || r.y > u.max.y) && (c.y = s.y - l.y, 0 < l.y ? c.y += h.y - e.y : c.y -= h.y - n.y), this.panTo(this.unproject(c), i), this._enforcingBounds = !1
        }
        return this
      },
      invalidateSize: function(t) {
        if (!this._loaded) return this;
        t = h({
          animate: !1,
          pan: !0
        }, !0 === t ? {
          animate: !0
        } : t);
        var i = this.getSize();
        this._sizeChanged = !0, this._lastCenter = null;
        var e = this.getSize(),
          n = i.divideBy(2).round(),
          o = e.divideBy(2).round(),
          s = n.subtract(o);
        return s.x || s.y ? (t.animate && t.pan ? this.panBy(s) : (t.pan && this._rawPanBy(s), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(a(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
          oldSize: i,
          newSize: e
        })) : this
      },
      stop: function() {
        return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop()
      },
      locate: function(t) {
        if (t = this._locateOptions = h({
            timeout: 1e4,
            watch: !1
          }, t), !("geolocation" in navigator)) return this._handleGeolocationError({
          code: 0,
          message: "Geolocation not supported."
        }), this;
        var i = a(this._handleGeolocationResponse, this),
          e = a(this._handleGeolocationError, this);
        return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(i, e, t) : navigator.geolocation.getCurrentPosition(i, e, t), this
      },
      stopLocate: function() {
        return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this
      },
      _handleGeolocationError: function(t) {
        var i = t.code,
          e = t.message || (1 === i ? "permission denied" : 2 === i ? "position unavailable" : "timeout");
        this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
          code: i,
          message: "Geolocation error: " + e + "."
        })
      },
      _handleGeolocationResponse: function(t) {
        var i = new j(t.coords.latitude, t.coords.longitude),
          e = i.toBounds(2 * t.coords.accuracy),
          n = this._locateOptions;
        if (n.setView) {
          var o = this.getBoundsZoom(e);
          this.setView(i, n.maxZoom ? Math.min(o, n.maxZoom) : o)
        }
        var s = {
          latlng: i,
          bounds: e,
          timestamp: t.timestamp
        };
        for (var r in t.coords) "number" == typeof t.coords[r] && (s[r] = t.coords[r]);
        this.fire("locationfound", s)
      },
      addHandler: function(t, i) {
        if (!i) return this;
        var e = this[t] = new i(this);
        return this._handlers.push(e), this.options[t] && e.enable(), this
      },
      remove: function() {
        if (this._initEvents(!0), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance");
        try {
          delete this._container._leaflet_id, delete this._containerId
        } catch (t) {
          this._container._leaflet_id = void 0, this._containerId = void 0
        }
        var t;
        for (t in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), ui(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (C(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers) this._layers[t].remove();
        for (t in this._panes) ui(this._panes[t]);
        return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this
      },
      createPane: function(t, i) {
        var e = hi("div", "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), i || this._mapPane);
        return t && (this._panes[t] = e), e
      },
      getCenter: function() {
        return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
      },
      getZoom: function() {
        return this._zoom
      },
      getBounds: function() {
        var t = this.getPixelBounds();
        return new N(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight()))
      },
      getMinZoom: function() {
        return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom
      },
      getMaxZoom: function() {
        return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
      },
      getBoundsZoom: function(t, i, e) {
        t = D(t), e = I(e || [0, 0]);
        var n = this.getZoom() || 0,
          o = this.getMinZoom(),
          s = this.getMaxZoom(),
          r = t.getNorthWest(),
          a = t.getSouthEast(),
          h = this.getSize().subtract(e),
          u = R(this.project(a, n), this.project(r, n)).getSize(),
          l = yt ? this.options.zoomSnap : 1,
          c = h.x / u.x,
          _ = h.y / u.y,
          d = i ? Math.max(c, _) : Math.min(c, _);
        return n = this.getScaleZoom(d, n), l && (n = Math.round(n / (l / 100)) * (l / 100), n = i ? Math.ceil(n / l) * l : Math.floor(n / l) * l), Math.max(o, Math.min(s, n))
      },
      getSize: function() {
        return this._size && !this._sizeChanged || (this._size = new B(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone()
      },
      getPixelBounds: function(t, i) {
        var e = this._getTopLeftPoint(t, i);
        return new O(e, e.add(this.getSize()))
      },
      getPixelOrigin: function() {
        return this._checkIfLoaded(), this._pixelOrigin
      },
      getPixelWorldBounds: function(t) {
        return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t)
      },
      getPane: function(t) {
        return "string" == typeof t ? this._panes[t] : t
      },
      getPanes: function() {
        return this._panes
      },
      getContainer: function() {
        return this._container
      },
      getZoomScale: function(t, i) {
        var e = this.options.crs;
        return i = void 0 === i ? this._zoom : i, e.scale(t) / e.scale(i)
      },
      getScaleZoom: function(t, i) {
        var e = this.options.crs;
        i = void 0 === i ? this._zoom : i;
        var n = e.zoom(t * e.scale(i));
        return isNaN(n) ? 1 / 0 : n
      },
      project: function(t, i) {
        return i = void 0 === i ? this._zoom : i, this.options.crs.latLngToPoint(W(t), i)
      },
      unproject: function(t, i) {
        return i = void 0 === i ? this._zoom : i, this.options.crs.pointToLatLng(I(t), i)
      },
      layerPointToLatLng: function(t) {
        var i = I(t).add(this.getPixelOrigin());
        return this.unproject(i)
      },
      latLngToLayerPoint: function(t) {
        return this.project(W(t))._round()._subtract(this.getPixelOrigin())
      },
      wrapLatLng: function(t) {
        return this.options.crs.wrapLatLng(W(t))
      },
      wrapLatLngBounds: function(t) {
        return this.options.crs.wrapLatLngBounds(D(t))
      },
      distance: function(t, i) {
        return this.options.crs.distance(W(t), W(i))
      },
      containerPointToLayerPoint: function(t) {
        return I(t).subtract(this._getMapPanePos())
      },
      layerPointToContainerPoint: function(t) {
        return I(t).add(this._getMapPanePos())
      },
      containerPointToLatLng: function(t) {
        var i = this.containerPointToLayerPoint(I(t));
        return this.layerPointToLatLng(i)
      },
      latLngToContainerPoint: function(t) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(W(t)))
      },
      mouseEventToContainerPoint: function(t) {
        return Wi(t, this._container)
      },
      mouseEventToLayerPoint: function(t) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
      },
      mouseEventToLatLng: function(t) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
      },
      _initContainer: function(t) {
        var i = this._container = ri(t);
        if (!i) throw new Error("Map container not found.");
        if (i._leaflet_id) throw new Error("Map container is already initialized.");
        Ei(i, "scroll", this._onScroll, this), this._containerId = u(i)
      },
      _initLayout: function() {
        var t = this._container;
        this._fadeAnimated = this.options.fadeAnimation && yt, pi(t, "leaflet-container" + (Tt ? " leaflet-touch" : "") + (Ct ? " leaflet-retina" : "") + (et ? " leaflet-oldie" : "") + (_t ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var i = ai(t, "position");
        "absolute" !== i && "relative" !== i && "fixed" !== i && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos()
      },
      _initPanes: function() {
        var t = this._panes = {};
        this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), wi(this._mapPane, new B(0, 0)), this.createPane("tilePane"), this.createPane("shadowPane"), this.createPane("overlayPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (pi(t.markerPane, "leaflet-zoom-hide"), pi(t.shadowPane, "leaflet-zoom-hide"))
      },
      _resetView: function(t, i) {
        wi(this._mapPane, new B(0, 0));
        var e = !this._loaded;
        this._loaded = !0, i = this._limitZoom(i), this.fire("viewprereset");
        var n = this._zoom !== i;
        this._moveStart(n, !1)._move(t, i)._moveEnd(n), this.fire("viewreset"), e && this.fire("load")
      },
      _moveStart: function(t, i) {
        return t && this.fire("zoomstart"), i || this.fire("movestart"), this
      },
      _move: function(t, i, e) {
        void 0 === i && (i = this._zoom);
        var n = this._zoom !== i;
        return this._zoom = i, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), (n || e && e.pinch) && this.fire("zoom", e), this.fire("move", e)
      },
      _moveEnd: function(t) {
        return t && this.fire("zoomend"), this.fire("moveend")
      },
      _stop: function() {
        return C(this._flyToFrame), this._panAnim && this._panAnim.stop(), this
      },
      _rawPanBy: function(t) {
        wi(this._mapPane, this._getMapPanePos().subtract(t))
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom()
      },
      _panInsideMaxBounds: function() {
        this._enforcingBounds || this.panInsideBounds(this.options.maxBounds)
      },
      _checkIfLoaded: function() {
        if (!this._loaded) throw new Error("Set map center and zoom first.")
      },
      _initEvents: function(t) {
        this._targets = {};
        var i = t ? Bi : Ei;
        i((this._targets[u(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && i(window, "resize", this._onResize, this), yt && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd)
      },
      _onResize: function() {
        C(this._resizeRequest), this._resizeRequest = M(function() {
          this.invalidateSize({
            debounceMoveend: !0
          })
        }, this)
      },
      _onScroll: function() {
        this._container.scrollTop = 0, this._container.scrollLeft = 0
      },
      _onMoveEnd: function() {
        var t = this._getMapPanePos();
        Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom())
      },
      _findEventTargets: function(t, i) {
        for (var e, n = [], o = "mouseout" === i || "mouseover" === i, s = t.target || t.srcElement, r = !1; s;) {
          if ((e = this._targets[u(s)]) && ("click" === i || "preclick" === i) && !t._simulated && this._draggableMoved(e)) {
            r = !0;
            break
          }
          if (e && e.listens(i, !0)) {
            if (o && !Ki(s, t)) break;
            if (n.push(e), o) break
          }
          if (s === this._container) break;
          s = s.parentNode
        }
        return n.length || r || o || !Ki(s, t) || (n = [this]), n
      },
      _handleDOMEvent: function(t) {
        if (this._loaded && !Gi(t)) {
          var i = t.type;
          "mousedown" !== i && "keypress" !== i && "keyup" !== i && "keydown" !== i || zi(t.target || t.srcElement), this._fireDOMEvent(t, i)
        }
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(t, i, e) {
        if ("click" === t.type) {
          var n = h({}, t);
          n.type = "preclick", this._fireDOMEvent(n, n.type, e)
        }
        if (!t._stopped && (e = (e || []).concat(this._findEventTargets(t, i))).length) {
          var o = e[0];
          "contextmenu" === i && o.listens(i, !0) && Di(t);
          var s = {
            originalEvent: t
          };
          if ("keypress" !== t.type && "keydown" !== t.type && "keyup" !== t.type) {
            var r = o.getLatLng && (!o._radius || o._radius <= 10);
            s.containerPoint = r ? this.latLngToContainerPoint(o.getLatLng()) : this.mouseEventToContainerPoint(t), s.layerPoint = this.containerPointToLayerPoint(s.containerPoint), s.latlng = r ? o.getLatLng() : this.layerPointToLatLng(s.layerPoint)
          }
          for (var a = 0; a < e.length; a++)
            if (e[a].fire(i, s, !0), s.originalEvent._stopped || !1 === e[a].options.bubblingMouseEvents && -1 !== y(this._mouseEvents, i)) return
        }
      },
      _draggableMoved: function(t) {
        return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved()
      },
      _clearHandlers: function() {
        for (var t = 0, i = this._handlers.length; t < i; t++) this._handlers[t].disable()
      },
      whenReady: function(t, i) {
        return this._loaded ? t.call(i || this, {
          target: this
        }) : this.on("load", t, i), this
      },
      _getMapPanePos: function() {
        return Pi(this._mapPane) || new B(0, 0)
      },
      _moved: function() {
        var t = this._getMapPanePos();
        return t && !t.equals([0, 0])
      },
      _getTopLeftPoint: function(t, i) {
        return (t && void 0 !== i ? this._getNewPixelOrigin(t, i) : this.getPixelOrigin()).subtract(this._getMapPanePos())
      },
      _getNewPixelOrigin: function(t, i) {
        var e = this.getSize()._divideBy(2);
        return this.project(t, i)._subtract(e)._add(this._getMapPanePos())._round()
      },
      _latLngToNewLayerPoint: function(t, i, e) {
        var n = this._getNewPixelOrigin(e, i);
        return this.project(t, i)._subtract(n)
      },
      _latLngBoundsToNewLayerBounds: function(t, i, e) {
        var n = this._getNewPixelOrigin(e, i);
        return R([this.project(t.getSouthWest(), i)._subtract(n), this.project(t.getNorthWest(), i)._subtract(n), this.project(t.getSouthEast(), i)._subtract(n), this.project(t.getNorthEast(), i)._subtract(n)])
      },
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
      },
      _getCenterOffset: function(t) {
        return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
      },
      _limitCenter: function(t, i, e) {
        if (!e) return t;
        var n = this.project(t, i),
          o = this.getSize().divideBy(2),
          s = new O(n.subtract(o), n.add(o)),
          r = this._getBoundsOffset(s, e, i);
        return r.round().equals([0, 0]) ? t : this.unproject(n.add(r), i)
      },
      _limitOffset: function(t, i) {
        if (!i) return t;
        var e = this.getPixelBounds(),
          n = new O(e.min.add(t), e.max.add(t));
        return t.add(this._getBoundsOffset(n, i))
      },
      _getBoundsOffset: function(t, i, e) {
        var n = R(this.project(i.getNorthEast(), e), this.project(i.getSouthWest(), e)),
          o = n.min.subtract(t.min),
          s = n.max.subtract(t.max);
        return new B(this._rebound(o.x, -s.x), this._rebound(o.y, -s.y))
      },
      _rebound: function(t, i) {
        return 0 < t + i ? Math.round(t - i) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(i))
      },
      _limitZoom: function(t) {
        var i = this.getMinZoom(),
          e = this.getMaxZoom(),
          n = yt ? this.options.zoomSnap : 1;
        return n && (t = Math.round(t / n) * n), Math.max(i, Math.min(e, t))
      },
      _onPanTransitionStep: function() {
        this.fire("move")
      },
      _onPanTransitionEnd: function() {
        mi(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
      },
      _tryAnimatedPan: function(t, i) {
        var e = this._getCenterOffset(t)._trunc();
        return !(!0 !== (i && i.animate) && !this.getSize().contains(e)) && (this.panBy(e, i), !0)
      },
      _createAnimProxy: function() {
        var t = this._proxy = hi("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(t), this.on("zoomanim", function(t) {
          var i = ni,
            e = this._proxy.style[i];
          xi(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), e === this._proxy.style[i] && this._animatingZoom && this._onZoomTransitionEnd()
        }, this), this.on("load moveend", function() {
          var t = this.getCenter(),
            i = this.getZoom();
          xi(this._proxy, this.project(t, i), this.getZoomScale(i, 1))
        }, this), this._on("unload", this._destroyAnimProxy, this)
      },
      _destroyAnimProxy: function() {
        ui(this._proxy), delete this._proxy
      },
      _catchTransitionEnd: function(t) {
        this._animatingZoom && 0 <= t.propertyName.indexOf("transform") && this._onZoomTransitionEnd()
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length
      },
      _tryAnimatedZoom: function(t, i, e) {
        if (this._animatingZoom) return !0;
        if (e = e || {}, !this._zoomAnimated || !1 === e.animate || this._nothingToAnimate() || Math.abs(i - this._zoom) > this.options.zoomAnimationThreshold) return !1;
        var n = this.getZoomScale(i),
          o = this._getCenterOffset(t)._divideBy(1 - 1 / n);
        return !(!0 !== e.animate && !this.getSize().contains(o)) && (M(function() {
          this._moveStart(!0, !1)._animateZoom(t, i, !0)
        }, this), !0)
      },
      _animateZoom: function(t, i, e, n) {
        this._mapPane && (e && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = i, pi(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
          center: t,
          zoom: i,
          noUpdate: n
        }), setTimeout(a(this._onZoomTransitionEnd, this), 250))
      },
      _onZoomTransitionEnd: function() {
        this._animatingZoom && (this._mapPane && mi(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom), M(function() {
          this._moveEnd(!0)
        }, this))
      }
    });

  function $i(t) {
    return new Qi(t)
  }
  var Qi = Z.extend({
    options: {
      position: "topright"
    },
    initialize: function(t) {
      p(this, t)
    },
    getPosition: function() {
      return this.options.position
    },
    setPosition: function(t) {
      var i = this._map;
      return i && i.removeControl(this), this.options.position = t, i && i.addControl(this), this
    },
    getContainer: function() {
      return this._container
    },
    addTo: function(t) {
      this.remove(), this._map = t;
      var i = this._container = this.onAdd(t),
        e = this.getPosition(),
        n = t._controlCorners[e];
      return pi(i, "leaflet-control"), -1 !== e.indexOf("bottom") ? n.insertBefore(i, n.firstChild) : n.appendChild(i), this._map.on("unload", this.remove, this), this
    },
    remove: function() {
      return this._map && (ui(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null), this
    },
    _refocusOnMap: function(t) {
      this._map && t && 0 < t.screenX && 0 < t.screenY && this._map.getContainer().focus()
    }
  });
  Ji.include({
    addControl: function(t) {
      return t.addTo(this), this
    },
    removeControl: function(t) {
      return t.remove(), this
    },
    _initControlPos: function() {
      var n = this._controlCorners = {},
        o = "leaflet-",
        s = this._controlContainer = hi("div", o + "control-container", this._container);

      function t(t, i) {
        var e = o + t + " " + o + i;
        n[t + i] = hi("div", e, s)
      }
      t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right")
    },
    _clearControlPos: function() {
      for (var t in this._controlCorners) ui(this._controlCorners[t]);
      ui(this._controlContainer), delete this._controlCorners, delete this._controlContainer
    }
  });
  var te = Qi.extend({
      options: {
        collapsed: !0,
        position: "topright",
        autoZIndex: !0,
        hideSingleBase: !1,
        sortLayers: !1,
        sortFunction: function(t, i, e, n) {
          return e < n ? -1 : n < e ? 1 : 0
        }
      },
      initialize: function(t, i, e) {
        for (var n in p(this, e), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, t) this._addLayer(t[n], n);
        for (n in i) this._addLayer(i[n], n, !0)
      },
      onAdd: function(t) {
        this._initLayout(), this._update(), (this._map = t).on("zoomend", this._checkDisabledLayers, this);
        for (var i = 0; i < this._layers.length; i++) this._layers[i].layer.on("add remove", this._onLayerChange, this);
        return this._container
      },
      addTo: function(t) {
        return Qi.prototype.addTo.call(this, t), this._expandIfNotCollapsed()
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var t = 0; t < this._layers.length; t++) this._layers[t].layer.off("add remove", this._onLayerChange, this)
      },
      addBaseLayer: function(t, i) {
        return this._addLayer(t, i), this._map ? this._update() : this
      },
      addOverlay: function(t, i) {
        return this._addLayer(t, i, !0), this._map ? this._update() : this
      },
      removeLayer: function(t) {
        t.off("add remove", this._onLayerChange, this);
        var i = this._getLayer(u(t));
        return i && this._layers.splice(this._layers.indexOf(i), 1), this._map ? this._update() : this
      },
      expand: function() {
        pi(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
        var t = this._map.getSize().y - (this._container.offsetTop + 50);
        return t < this._section.clientHeight ? (pi(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = t + "px") : mi(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this
      },
      collapse: function() {
        return mi(this._container, "leaflet-control-layers-expanded"), this
      },
      _initLayout: function() {
        var t = "leaflet-control-layers",
          i = this._container = hi("div", t),
          e = this.options.collapsed;
        i.setAttribute("aria-haspopup", !0), Ni(i), Ri(i);
        var n = this._section = hi("section", t + "-list");
        e && (this._map.on("click", this.collapse, this), st || Ei(i, {
          mouseenter: this.expand,
          mouseleave: this.collapse
        }, this));
        var o = this._layersLink = hi("a", t + "-toggle", i);
        o.href = "#", o.title = "Layers", Tt ? (Ei(o, "click", ji), Ei(o, "click", this.expand, this)) : Ei(o, "focus", this.expand, this), e || this.expand(), this._baseLayersList = hi("div", t + "-base", n), this._separator = hi("div", t + "-separator", n), this._overlaysList = hi("div", t + "-overlays", n), i.appendChild(n)
      },
      _getLayer: function(t) {
        for (var i = 0; i < this._layers.length; i++)
          if (this._layers[i] && u(this._layers[i].layer) === t) return this._layers[i]
      },
      _addLayer: function(t, i, e) {
        this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({
          layer: t,
          name: i,
          overlay: e
        }), this.options.sortLayers && this._layers.sort(a(function(t, i) {
          return this.options.sortFunction(t.layer, i.layer, t.name, i.name)
        }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed()
      },
      _update: function() {
        if (!this._container) return this;
        li(this._baseLayersList), li(this._overlaysList), this._layerControlInputs = [];
        var t, i, e, n, o = 0;
        for (e = 0; e < this._layers.length; e++) n = this._layers[e], this._addItem(n), i = i || n.overlay, t = t || !n.overlay, o += n.overlay ? 0 : 1;
        return this.options.hideSingleBase && (t = t && 1 < o, this._baseLayersList.style.display = t ? "" : "none"), this._separator.style.display = i && t ? "" : "none", this
      },
      _onLayerChange: function(t) {
        this._handlingClick || this._update();
        var i = this._getLayer(u(t.target)),
          e = i.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null;
        e && this._map.fire(e, i)
      },
      _createRadioElement: function(t, i) {
        var e = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (i ? ' checked="checked"' : "") + "/>",
          n = document.createElement("div");
        return n.innerHTML = e, n.firstChild
      },
      _addItem: function(t) {
        var i, e = document.createElement("label"),
          n = this._map.hasLayer(t.layer);
        t.overlay ? ((i = document.createElement("input")).type = "checkbox", i.className = "leaflet-control-layers-selector", i.defaultChecked = n) : i = this._createRadioElement("leaflet-base-layers_" + u(this), n), this._layerControlInputs.push(i), i.layerId = u(t.layer), Ei(i, "click", this._onInputClick, this);
        var o = document.createElement("span");
        o.innerHTML = " " + t.name;
        var s = document.createElement("div");
        return e.appendChild(s), s.appendChild(i), s.appendChild(o), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(e), this._checkDisabledLayers(), e
      },
      _onInputClick: function() {
        var t, i, e = this._layerControlInputs,
          n = [],
          o = [];
        this._handlingClick = !0;
        for (var s = e.length - 1; 0 <= s; s--) t = e[s], i = this._getLayer(t.layerId).layer, t.checked ? n.push(i) : t.checked || o.push(i);
        for (s = 0; s < o.length; s++) this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]);
        for (s = 0; s < n.length; s++) this._map.hasLayer(n[s]) || this._map.addLayer(n[s]);
        this._handlingClick = !1, this._refocusOnMap()
      },
      _checkDisabledLayers: function() {
        for (var t, i, e = this._layerControlInputs, n = this._map.getZoom(), o = e.length - 1; 0 <= o; o--) t = e[o], i = this._getLayer(t.layerId).layer, t.disabled = void 0 !== i.options.minZoom && n < i.options.minZoom || void 0 !== i.options.maxZoom && n > i.options.maxZoom
      },
      _expandIfNotCollapsed: function() {
        return this._map && !this.options.collapsed && this.expand(), this
      },
      _expand: function() {
        return this.expand()
      },
      _collapse: function() {
        return this.collapse()
      }
    }),
    ie = Qi.extend({
      options: {
        position: "topleft",
        zoomInText: "+",
        zoomInTitle: "Zoom in",
        zoomOutText: "&#x2212;",
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(t) {
        var i = "leaflet-control-zoom",
          e = hi("div", i + " leaflet-bar"),
          n = this.options;
        return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, i + "-in", e, this._zoomIn), this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, i + "-out", e, this._zoomOut), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), e
      },
      onRemove: function(t) {
        t.off("zoomend zoomlevelschange", this._updateDisabled, this)
      },
      disable: function() {
        return this._disabled = !0, this._updateDisabled(), this
      },
      enable: function() {
        return this._disabled = !1, this._updateDisabled(), this
      },
      _zoomIn: function(t) {
        !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
      },
      _zoomOut: function(t) {
        !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
      },
      _createButton: function(t, i, e, n, o) {
        var s = hi("a", e, n);
        return s.innerHTML = t, s.href = "#", s.title = i, s.setAttribute("role", "button"), s.setAttribute("aria-label", i), Ni(s), Ei(s, "click", ji), Ei(s, "click", o, this), Ei(s, "click", this._refocusOnMap, this), s
      },
      _updateDisabled: function() {
        var t = this._map,
          i = "leaflet-disabled";
        mi(this._zoomInButton, i), mi(this._zoomOutButton, i), !this._disabled && t._zoom !== t.getMinZoom() || pi(this._zoomOutButton, i), !this._disabled && t._zoom !== t.getMaxZoom() || pi(this._zoomInButton, i)
      }
    });
  Ji.mergeOptions({
    zoomControl: !0
  }), Ji.addInitHook(function() {
    this.options.zoomControl && (this.zoomControl = new ie, this.addControl(this.zoomControl))
  });
  var ee = Qi.extend({
      options: {
        position: "bottomleft",
        maxWidth: 100,
        metric: !0,
        imperial: !0
      },
      onAdd: function(t) {
        var i = "leaflet-control-scale",
          e = hi("div", i),
          n = this.options;
        return this._addScales(n, i + "-line", e), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), e
      },
      onRemove: function(t) {
        t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
      },
      _addScales: function(t, i, e) {
        t.metric && (this._mScale = hi("div", i, e)), t.imperial && (this._iScale = hi("div", i, e))
      },
      _update: function() {
        var t = this._map,
          i = t.getSize().y / 2,
          e = t.distance(t.containerPointToLatLng([0, i]), t.containerPointToLatLng([this.options.maxWidth, i]));
        this._updateScales(e)
      },
      _updateScales: function(t) {
        this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t)
      },
      _updateMetric: function(t) {
        var i = this._getRoundNum(t),
          e = i < 1e3 ? i + " m" : i / 1e3 + " km";
        this._updateScale(this._mScale, e, i / t)
      },
      _updateImperial: function(t) {
        var i, e, n, o = 3.2808399 * t;
        5280 < o ? (i = o / 5280, e = this._getRoundNum(i), this._updateScale(this._iScale, e + " mi", e / i)) : (n = this._getRoundNum(o), this._updateScale(this._iScale, n + " ft", n / o))
      },
      _updateScale: function(t, i, e) {
        t.style.width = Math.round(this.options.maxWidth * e) + "px", t.innerHTML = i
      },
      _getRoundNum: function(t) {
        var i = Math.pow(10, (Math.floor(t) + "").length - 1),
          e = t / i;
        return i * (e = 10 <= e ? 10 : 5 <= e ? 5 : 3 <= e ? 3 : 2 <= e ? 2 : 1)
      }
    }),
    ne = Qi.extend({
      options: {
        position: "bottomright",
        prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
      },
      initialize: function(t) {
        p(this, t), this._attributions = {}
      },
      onAdd: function(t) {
        for (var i in (t.attributionControl = this)._container = hi("div", "leaflet-control-attribution"), Ni(this._container), t._layers) t._layers[i].getAttribution && this.addAttribution(t._layers[i].getAttribution());
        return this._update(), this._container
      },
      setPrefix: function(t) {
        return this.options.prefix = t, this._update(), this
      },
      addAttribution: function(t) {
        return t && (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update()), this
      },
      removeAttribution: function(t) {
        return t && this._attributions[t] && (this._attributions[t]--, this._update()), this
      },
      _update: function() {
        if (this._map) {
          var t = [];
          for (var i in this._attributions) this._attributions[i] && t.push(i);
          var e = [];
          this.options.prefix && e.push(this.options.prefix), t.length && e.push(t.join(", ")), this._container.innerHTML = e.join(" | ")
        }
      }
    });
  Ji.mergeOptions({
    attributionControl: !0
  }), Ji.addInitHook(function() {
    this.options.attributionControl && (new ne).addTo(this)
  });
  Qi.Layers = te, Qi.Zoom = ie, Qi.Scale = ee, Qi.Attribution = ne, $i.layers = function(t, i, e) {
    return new te(t, i, e)
  }, $i.zoom = function(t) {
    return new ie(t)
  }, $i.scale = function(t) {
    return new ee(t)
  }, $i.attribution = function(t) {
    return new ne(t)
  };
  var oe = Z.extend({
    initialize: function(t) {
      this._map = t
    },
    enable: function() {
      return this._enabled || (this._enabled = !0, this.addHooks()), this
    },
    disable: function() {
      return this._enabled && (this._enabled = !1, this.removeHooks()), this
    },
    enabled: function() {
      return !!this._enabled
    }
  });
  oe.addTo = function(t, i) {
    return t.addHandler(i, this), this
  };
  var se, re = {
      Events: E
    },
    ae = Tt ? "touchstart mousedown" : "mousedown",
    he = {
      mousedown: "mouseup",
      touchstart: "touchend",
      pointerdown: "touchend",
      MSPointerDown: "touchend"
    },
    ue = {
      mousedown: "mousemove",
      touchstart: "touchmove",
      pointerdown: "touchmove",
      MSPointerDown: "touchmove"
    },
    le = k.extend({
      options: {
        clickTolerance: 3
      },
      initialize: function(t, i, e, n) {
        p(this, n), this._element = t, this._dragStartTarget = i || t, this._preventOutline = e
      },
      enable: function() {
        this._enabled || (Ei(this._dragStartTarget, ae, this._onDown, this), this._enabled = !0)
      },
      disable: function() {
        this._enabled && (le._dragging === this && this.finishDrag(), Bi(this._dragStartTarget, ae, this._onDown, this), this._enabled = !1, this._moved = !1)
      },
      _onDown: function(t) {
        if (!t._simulated && this._enabled && (this._moved = !1, !di(this._element, "leaflet-zoom-anim") && !(le._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || ((le._dragging = this)._preventOutline && zi(this._element), Li(), $t(), this._moving)))) {
          this.fire("down");
          var i = t.touches ? t.touches[0] : t,
            e = Ci(this._element);
          this._startPoint = new B(i.clientX, i.clientY), this._parentScale = Si(e), Ei(document, ue[t.type], this._onMove, this), Ei(document, he[t.type], this._onUp, this)
        }
      },
      _onMove: function(t) {
        if (!t._simulated && this._enabled)
          if (t.touches && 1 < t.touches.length) this._moved = !0;
          else {
            var i = t.touches && 1 === t.touches.length ? t.touches[0] : t,
              e = new B(i.clientX, i.clientY)._subtract(this._startPoint);
            (e.x || e.y) && (Math.abs(e.x) + Math.abs(e.y) < this.options.clickTolerance || (e.x /= this._parentScale.x, e.y /= this._parentScale.y, Di(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = Pi(this._element).subtract(e), pi(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), pi(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(e), this._moving = !0, C(this._animRequest), this._lastEvent = t, this._animRequest = M(this._updatePosition, this, !0)))
          }
      },
      _updatePosition: function() {
        var t = {
          originalEvent: this._lastEvent
        };
        this.fire("predrag", t), wi(this._element, this._newPos), this.fire("drag", t)
      },
      _onUp: function(t) {
        !t._simulated && this._enabled && this.finishDrag()
      },
      finishDrag: function() {
        for (var t in mi(document.body, "leaflet-dragging"), this._lastTarget && (mi(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), ue) Bi(document, ue[t], this._onMove, this), Bi(document, he[t], this._onUp, this);
        Ti(), Qt(), this._moved && this._moving && (C(this._animRequest), this.fire("dragend", {
          distance: this._newPos.distanceTo(this._startPos)
        })), this._moving = !1, le._dragging = !1
      }
    });

  function ce(t, i) {
    if (!i || !t.length) return t.slice();
    var e = i * i;
    return t = function(t, i) {
      var e = t.length,
        n = new(typeof Uint8Array != void 0 + "" ? Uint8Array : Array)(e);
      n[0] = n[e - 1] = 1,
        function t(i, e, n, o, s) {
          var r, a, h, u = 0;
          for (a = o + 1; a <= s - 1; a++) h = fe(i[a], i[o], i[s], !0), u < h && (r = a, u = h);
          n < u && (e[r] = 1, t(i, e, n, o, r), t(i, e, n, r, s))
        }(t, n, i, 0, e - 1);
      var o, s = [];
      for (o = 0; o < e; o++) n[o] && s.push(t[o]);
      return s
    }(t = function(t, i) {
      for (var e = [t[0]], n = 1, o = 0, s = t.length; n < s; n++) r = t[n], a = t[o], void 0, h = a.x - r.x, u = a.y - r.y, i < h * h + u * u && (e.push(t[n]), o = n);
      var r, a, h, u;
      o < s - 1 && e.push(t[s - 1]);
      return e
    }(t, e), e)
  }

  function _e(t, i, e) {
    return Math.sqrt(fe(t, i, e, !0))
  }

  function de(t, i, e, n, o) {
    var s, r, a, h = n ? se : me(t, e),
      u = me(i, e);
    for (se = u;;) {
      if (!(h | u)) return [t, i];
      if (h & u) return !1;
      a = me(r = pe(t, i, s = h || u, e, o), e), s === h ? (t = r, h = a) : (i = r, u = a)
    }
  }

  function pe(t, i, e, n, o) {
    var s, r, a = i.x - t.x,
      h = i.y - t.y,
      u = n.min,
      l = n.max;
    return 8 & e ? (s = t.x + a * (l.y - t.y) / h, r = l.y) : 4 & e ? (s = t.x + a * (u.y - t.y) / h, r = u.y) : 2 & e ? (s = l.x, r = t.y + h * (l.x - t.x) / a) : 1 & e && (s = u.x, r = t.y + h * (u.x - t.x) / a), new B(s, r, o)
  }

  function me(t, i) {
    var e = 0;
    return t.x < i.min.x ? e |= 1 : t.x > i.max.x && (e |= 2), t.y < i.min.y ? e |= 4 : t.y > i.max.y && (e |= 8), e
  }

  function fe(t, i, e, n) {
    var o, s = i.x,
      r = i.y,
      a = e.x - s,
      h = e.y - r,
      u = a * a + h * h;
    return 0 < u && (1 < (o = ((t.x - s) * a + (t.y - r) * h) / u) ? (s = e.x, r = e.y) : 0 < o && (s += a * o, r += h * o)), a = t.x - s, h = t.y - r, n ? a * a + h * h : new B(s, r)
  }

  function ge(t) {
    return !v(t[0]) || "object" != typeof t[0][0] && void 0 !== t[0][0]
  }

  function ve(t) {
    return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), ge(t)
  }
  var ye = (Object.freeze || Object)({
    simplify: ce,
    pointToSegmentDistance: _e,
    closestPointOnSegment: function(t, i, e) {
      return fe(t, i, e)
    },
    clipSegment: de,
    _getEdgeIntersection: pe,
    _getBitCode: me,
    _sqClosestPointOnSegment: fe,
    isFlat: ge,
    _flat: ve
  });

  function xe(t, i, e) {
    var n, o, s, r, a, h, u, l, c, _ = [1, 4, 2, 8];
    for (o = 0, u = t.length; o < u; o++) t[o]._code = me(t[o], i);
    for (r = 0; r < 4; r++) {
      for (l = _[r], n = [], o = 0, s = (u = t.length) - 1; o < u; s = o++) a = t[o], h = t[s], a._code & l ? h._code & l || ((c = pe(h, a, l, i, e))._code = me(c, i), n.push(c)) : (h._code & l && ((c = pe(h, a, l, i, e))._code = me(c, i), n.push(c)), n.push(a));
      t = n
    }
    return t
  }
  var we, Pe = (Object.freeze || Object)({
      clipPolygon: xe
    }),
    be = {
      project: function(t) {
        return new B(t.lng, t.lat)
      },
      unproject: function(t) {
        return new j(t.y, t.x)
      },
      bounds: new O([-180, -90], [180, 90])
    },
    Le = {
      R: 6378137,
      R_MINOR: 6356752.314245179,
      bounds: new O([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
      project: function(t) {
        var i = Math.PI / 180,
          e = this.R,
          n = t.lat * i,
          o = this.R_MINOR / e,
          s = Math.sqrt(1 - o * o),
          r = s * Math.sin(n),
          a = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - r) / (1 + r), s / 2);
        return n = -e * Math.log(Math.max(a, 1e-10)), new B(t.lng * i * e, n)
      },
      unproject: function(t) {
        for (var i, e = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), r = Math.exp(-t.y / n), a = Math.PI / 2 - 2 * Math.atan(r), h = 0, u = .1; h < 15 && 1e-7 < Math.abs(u); h++) i = s * Math.sin(a), i = Math.pow((1 - i) / (1 + i), s / 2), a += u = Math.PI / 2 - 2 * Math.atan(r * i) - a;
        return new j(a * e, t.x * e / n)
      }
    },
    Te = (Object.freeze || Object)({
      LonLat: be,
      Mercator: Le,
      SphericalMercator: q
    }),
    ze = h({}, U, {
      code: "EPSG:3395",
      projection: Le,
      transformation: (we = .5 / (Math.PI * Le.R), K(we, .5, -we, .5))
    }),
    Me = h({}, U, {
      code: "EPSG:4326",
      projection: be,
      transformation: K(1 / 180, 1, -1 / 180, .5)
    }),
    Ce = h({}, F, {
      projection: be,
      transformation: K(1, 0, -1, 0),
      scale: function(t) {
        return Math.pow(2, t)
      },
      zoom: function(t) {
        return Math.log(t) / Math.LN2
      },
      distance: function(t, i) {
        var e = i.lng - t.lng,
          n = i.lat - t.lat;
        return Math.sqrt(e * e + n * n)
      },
      infinite: !0
    });
  F.Earth = U, F.EPSG3395 = ze, F.EPSG3857 = X, F.EPSG900913 = J, F.EPSG4326 = Me, F.Simple = Ce;
  var Se = k.extend({
    options: {
      pane: "overlayPane",
      attribution: null,
      bubblingMouseEvents: !0
    },
    addTo: function(t) {
      return t.addLayer(this), this
    },
    remove: function() {
      return this.removeFrom(this._map || this._mapToAdd)
    },
    removeFrom: function(t) {
      return t && t.removeLayer(this), this
    },
    getPane: function(t) {
      return this._map.getPane(t ? this.options[t] || t : this.options.pane)
    },
    addInteractiveTarget: function(t) {
      return this._map._targets[u(t)] = this
    },
    removeInteractiveTarget: function(t) {
      return delete this._map._targets[u(t)], this
    },
    getAttribution: function() {
      return this.options.attribution
    },
    _layerAdd: function(t) {
      var i = t.target;
      if (i.hasLayer(this)) {
        if (this._map = i, this._zoomAnimated = i._zoomAnimated, this.getEvents) {
          var e = this.getEvents();
          i.on(e, this), this.once("remove", function() {
            i.off(e, this)
          }, this)
        }
        this.onAdd(i), this.getAttribution && i.attributionControl && i.attributionControl.addAttribution(this.getAttribution()), this.fire("add"), i.fire("layeradd", {
          layer: this
        })
      }
    }
  });
  Ji.include({
    addLayer: function(t) {
      if (!t._layerAdd) throw new Error("The provided object is not a Layer.");
      var i = u(t);
      return this._layers[i] || ((this._layers[i] = t)._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t)), this
    },
    removeLayer: function(t) {
      var i = u(t);
      return this._layers[i] && (this._loaded && t.onRemove(this), t.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(t.getAttribution()), delete this._layers[i], this._loaded && (this.fire("layerremove", {
        layer: t
      }), t.fire("remove")), t._map = t._mapToAdd = null), this
    },
    hasLayer: function(t) {
      return !!t && u(t) in this._layers
    },
    eachLayer: function(t, i) {
      for (var e in this._layers) t.call(i, this._layers[e]);
      return this
    },
    _addLayers: function(t) {
      for (var i = 0, e = (t = t ? v(t) ? t : [t] : []).length; i < e; i++) this.addLayer(t[i])
    },
    _addZoomLimit: function(t) {
      !isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[u(t)] = t, this._updateZoomLevels())
    },
    _removeZoomLimit: function(t) {
      var i = u(t);
      this._zoomBoundLayers[i] && (delete this._zoomBoundLayers[i], this._updateZoomLevels())
    },
    _updateZoomLevels: function() {
      var t = 1 / 0,
        i = -1 / 0,
        e = this._getZoomSpan();
      for (var n in this._zoomBoundLayers) {
        var o = this._zoomBoundLayers[n].options;
        t = void 0 === o.minZoom ? t : Math.min(t, o.minZoom), i = void 0 === o.maxZoom ? i : Math.max(i, o.maxZoom)
      }
      this._layersMaxZoom = i === -1 / 0 ? void 0 : i, this._layersMinZoom = t === 1 / 0 ? void 0 : t, e !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom)
    }
  });
  var Ze = Se.extend({
      initialize: function(t, i) {
        var e, n;
        if (p(this, i), this._layers = {}, t)
          for (e = 0, n = t.length; e < n; e++) this.addLayer(t[e])
      },
      addLayer: function(t) {
        var i = this.getLayerId(t);
        return this._layers[i] = t, this._map && this._map.addLayer(t), this
      },
      removeLayer: function(t) {
        var i = t in this._layers ? t : this.getLayerId(t);
        return this._map && this._layers[i] && this._map.removeLayer(this._layers[i]), delete this._layers[i], this
      },
      hasLayer: function(t) {
        return !!t && (t in this._layers || this.getLayerId(t) in this._layers)
      },
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this)
      },
      invoke: function(t) {
        var i, e, n = Array.prototype.slice.call(arguments, 1);
        for (i in this._layers)(e = this._layers[i])[t] && e[t].apply(e, n);
        return this
      },
      onAdd: function(t) {
        this.eachLayer(t.addLayer, t)
      },
      onRemove: function(t) {
        this.eachLayer(t.removeLayer, t)
      },
      eachLayer: function(t, i) {
        for (var e in this._layers) t.call(i, this._layers[e]);
        return this
      },
      getLayer: function(t) {
        return this._layers[t]
      },
      getLayers: function() {
        var t = [];
        return this.eachLayer(t.push, t), t
      },
      setZIndex: function(t) {
        return this.invoke("setZIndex", t)
      },
      getLayerId: function(t) {
        return u(t)
      }
    }),
    Ee = Ze.extend({
      addLayer: function(t) {
        return this.hasLayer(t) ? this : (t.addEventParent(this), Ze.prototype.addLayer.call(this, t), this.fire("layeradd", {
          layer: t
        }))
      },
      removeLayer: function(t) {
        return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), Ze.prototype.removeLayer.call(this, t), this.fire("layerremove", {
          layer: t
        })) : this
      },
      setStyle: function(t) {
        return this.invoke("setStyle", t)
      },
      bringToFront: function() {
        return this.invoke("bringToFront")
      },
      bringToBack: function() {
        return this.invoke("bringToBack")
      },
      getBounds: function() {
        var t = new N;
        for (var i in this._layers) {
          var e = this._layers[i];
          t.extend(e.getBounds ? e.getBounds() : e.getLatLng())
        }
        return t
      }
    }),
    ke = Z.extend({
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0]
      },
      initialize: function(t) {
        p(this, t)
      },
      createIcon: function(t) {
        return this._createIcon("icon", t)
      },
      createShadow: function(t) {
        return this._createIcon("shadow", t)
      },
      _createIcon: function(t, i) {
        var e = this._getIconUrl(t);
        if (!e) {
          if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs).");
          return null
        }
        var n = this._createImg(e, i && "IMG" === i.tagName ? i : null);
        return this._setIconStyles(n, t), n
      },
      _setIconStyles: function(t, i) {
        var e = this.options,
          n = e[i + "Size"];
        "number" == typeof n && (n = [n, n]);
        var o = I(n),
          s = I("shadow" === i && e.shadowAnchor || e.iconAnchor || o && o.divideBy(2, !0));
        t.className = "leaflet-marker-" + i + " " + (e.className || ""), s && (t.style.marginLeft = -s.x + "px", t.style.marginTop = -s.y + "px"), o && (t.style.width = o.x + "px", t.style.height = o.y + "px")
      },
      _createImg: function(t, i) {
        return (i = i || document.createElement("img")).src = t, i
      },
      _getIconUrl: function(t) {
        return Ct && this.options[t + "RetinaUrl"] || this.options[t + "Url"]
      }
    });
  var Be = ke.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(t) {
        return Be.imagePath || (Be.imagePath = this._detectIconPath()), (this.options.imagePath || Be.imagePath) + ke.prototype._getIconUrl.call(this, t)
      },
      _detectIconPath: function() {
        var t = hi("div", "leaflet-default-icon-path", document.body),
          i = ai(t, "background-image") || ai(t, "backgroundImage");
        return document.body.removeChild(t), i = null === i || 0 !== i.indexOf("url") ? "" : i.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "")
      }
    }),
    Ae = oe.extend({
      initialize: function(t) {
        this._marker = t
      },
      addHooks: function() {
        var t = this._marker._icon;
        this._draggable || (this._draggable = new le(t, t, !0)), this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable(), pi(t, "leaflet-marker-draggable")
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable(), this._marker._icon && mi(this._marker._icon, "leaflet-marker-draggable")
      },
      moved: function() {
        return this._draggable && this._draggable._moved
      },
      _adjustPan: function(t) {
        var i = this._marker,
          e = i._map,
          n = this._marker.options.autoPanSpeed,
          o = this._marker.options.autoPanPadding,
          s = Pi(i._icon),
          r = e.getPixelBounds(),
          a = e.getPixelOrigin(),
          h = R(r.min._subtract(a).add(o), r.max._subtract(a).subtract(o));
        if (!h.contains(s)) {
          var u = I((Math.max(h.max.x, s.x) - h.max.x) / (r.max.x - h.max.x) - (Math.min(h.min.x, s.x) - h.min.x) / (r.min.x - h.min.x), (Math.max(h.max.y, s.y) - h.max.y) / (r.max.y - h.max.y) - (Math.min(h.min.y, s.y) - h.min.y) / (r.min.y - h.min.y)).multiplyBy(n);
          e.panBy(u, {
            animate: !1
          }), this._draggable._newPos._add(u), this._draggable._startPos._add(u), wi(i._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = M(this._adjustPan.bind(this, t))
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup().fire("movestart").fire("dragstart")
      },
      _onPreDrag: function(t) {
        this._marker.options.autoPan && (C(this._panRequest), this._panRequest = M(this._adjustPan.bind(this, t)))
      },
      _onDrag: function(t) {
        var i = this._marker,
          e = i._shadow,
          n = Pi(i._icon),
          o = i._map.layerPointToLatLng(n);
        e && wi(e, n), i._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, i.fire("move", t).fire("drag", t)
      },
      _onDragEnd: function(t) {
        C(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t)
      }
    }),
    Ie = Se.extend({
      options: {
        icon: new Be,
        interactive: !0,
        keyboard: !0,
        title: "",
        alt: "",
        zIndexOffset: 0,
        opacity: 1,
        riseOnHover: !1,
        riseOffset: 250,
        pane: "markerPane",
        shadowPane: "shadowPane",
        bubblingMouseEvents: !1,
        draggable: !1,
        autoPan: !1,
        autoPanPadding: [50, 50],
        autoPanSpeed: 10
      },
      initialize: function(t, i) {
        p(this, i), this._latlng = W(t)
      },
      onAdd: function(t) {
        this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update()
      },
      onRemove: function(t) {
        this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow()
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        }
      },
      getLatLng: function() {
        return this._latlng
      },
      setLatLng: function(t) {
        var i = this._latlng;
        return this._latlng = W(t), this.update(), this.fire("move", {
          oldLatLng: i,
          latlng: this._latlng
        })
      },
      setZIndexOffset: function(t) {
        return this.options.zIndexOffset = t, this.update()
      },
      getIcon: function() {
        return this.options.icon
      },
      setIcon: function(t) {
        return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this
      },
      getElement: function() {
        return this._icon
      },
      update: function() {
        if (this._icon && this._map) {
          var t = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(t)
        }
        return this
      },
      _initIcon: function() {
        var t = this.options,
          i = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"),
          e = t.icon.createIcon(this._icon),
          n = !1;
        e !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (e.title = t.title), "IMG" === e.tagName && (e.alt = t.alt || "")), pi(e, i), t.keyboard && (e.tabIndex = "0"), this._icon = e, t.riseOnHover && this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
        var o = t.icon.createShadow(this._shadow),
          s = !1;
        o !== this._shadow && (this._removeShadow(), s = !0), o && (pi(o, i), o.alt = ""), this._shadow = o, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), o && s && this.getPane(t.shadowPane).appendChild(this._shadow)
      },
      _removeIcon: function() {
        this.options.riseOnHover && this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), ui(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null
      },
      _removeShadow: function() {
        this._shadow && ui(this._shadow), this._shadow = null
      },
      _setPos: function(t) {
        wi(this._icon, t), this._shadow && wi(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex()
      },
      _updateZIndex: function(t) {
        this._icon.style.zIndex = this._zIndex + t
      },
      _animateZoom: function(t) {
        var i = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
        this._setPos(i)
      },
      _initInteraction: function() {
        if (this.options.interactive && (pi(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), Ae)) {
          var t = this.options.draggable;
          this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Ae(this), t && this.dragging.enable()
        }
      },
      setOpacity: function(t) {
        return this.options.opacity = t, this._map && this._updateOpacity(), this
      },
      _updateOpacity: function() {
        var t = this.options.opacity;
        this._icon && vi(this._icon, t), this._shadow && vi(this._shadow, t)
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset)
      },
      _resetZIndex: function() {
        this._updateZIndex(0)
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor
      }
    });
  var Oe = Se.extend({
      options: {
        stroke: !0,
        color: "#3388ff",
        weight: 3,
        opacity: 1,
        lineCap: "round",
        lineJoin: "round",
        dashArray: null,
        dashOffset: null,
        fill: !1,
        fillColor: null,
        fillOpacity: .2,
        fillRule: "evenodd",
        interactive: !0,
        bubblingMouseEvents: !0
      },
      beforeAdd: function(t) {
        this._renderer = t.getRenderer(this)
      },
      onAdd: function() {
        this._renderer._initPath(this), this._reset(), this._renderer._addPath(this)
      },
      onRemove: function() {
        this._renderer._removePath(this)
      },
      redraw: function() {
        return this._map && this._renderer._updatePath(this), this
      },
      setStyle: function(t) {
        return p(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t.hasOwnProperty("weight") && this._updateBounds()), this
      },
      bringToFront: function() {
        return this._renderer && this._renderer._bringToFront(this), this
      },
      bringToBack: function() {
        return this._renderer && this._renderer._bringToBack(this), this
      },
      getElement: function() {
        return this._path
      },
      _reset: function() {
        this._project(), this._update()
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance
      }
    }),
    Re = Oe.extend({
      options: {
        fill: !0,
        radius: 10
      },
      initialize: function(t, i) {
        p(this, i), this._latlng = W(t), this._radius = this.options.radius
      },
      setLatLng: function(t) {
        return this._latlng = W(t), this.redraw(), this.fire("move", {
          latlng: this._latlng
        })
      },
      getLatLng: function() {
        return this._latlng
      },
      setRadius: function(t) {
        return this.options.radius = this._radius = t, this.redraw()
      },
      getRadius: function() {
        return this._radius
      },
      setStyle: function(t) {
        var i = t && t.radius || this._radius;
        return Oe.prototype.setStyle.call(this, t), this.setRadius(i), this
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds()
      },
      _updateBounds: function() {
        var t = this._radius,
          i = this._radiusY || t,
          e = this._clickTolerance(),
          n = [t + e, i + e];
        this._pxBounds = new O(this._point.subtract(n), this._point.add(n))
      },
      _update: function() {
        this._map && this._updatePath()
      },
      _updatePath: function() {
        this._renderer._updateCircle(this)
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
      },
      _containsPoint: function(t) {
        return t.distanceTo(this._point) <= this._radius + this._clickTolerance()
      }
    });
  var Ne = Re.extend({
    initialize: function(t, i, e) {
      if ("number" == typeof i && (i = h({}, e, {
          radius: i
        })), p(this, i), this._latlng = W(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN");
      this._mRadius = this.options.radius
    },
    setRadius: function(t) {
      return this._mRadius = t, this.redraw()
    },
    getRadius: function() {
      return this._mRadius
    },
    getBounds: function() {
      var t = [this._radius, this._radiusY || this._radius];
      return new N(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t)))
    },
    setStyle: Oe.prototype.setStyle,
    _project: function() {
      var t = this._latlng.lng,
        i = this._latlng.lat,
        e = this._map,
        n = e.options.crs;
      if (n.distance === U.distance) {
        var o = Math.PI / 180,
          s = this._mRadius / U.R / o,
          r = e.project([i + s, t]),
          a = e.project([i - s, t]),
          h = r.add(a).divideBy(2),
          u = e.unproject(h).lat,
          l = Math.acos((Math.cos(s * o) - Math.sin(i * o) * Math.sin(u * o)) / (Math.cos(i * o) * Math.cos(u * o))) / o;
        !isNaN(l) && 0 !== l || (l = s / Math.cos(Math.PI / 180 * i)), this._point = h.subtract(e.getPixelOrigin()), this._radius = isNaN(l) ? 0 : h.x - e.project([u, t - l]).x, this._radiusY = h.y - r.y
      } else {
        var c = n.unproject(n.project(this._latlng).subtract([this._mRadius, 0]));
        this._point = e.latLngToLayerPoint(this._latlng), this._radius = this._point.x - e.latLngToLayerPoint(c).x
      }
      this._updateBounds()
    }
  });
  var De = Oe.extend({
    options: {
      smoothFactor: 1,
      noClip: !1
    },
    initialize: function(t, i) {
      p(this, i), this._setLatLngs(t)
    },
    getLatLngs: function() {
      return this._latlngs
    },
    setLatLngs: function(t) {
      return this._setLatLngs(t), this.redraw()
    },
    isEmpty: function() {
      return !this._latlngs.length
    },
    closestLayerPoint: function(t) {
      for (var i, e, n = 1 / 0, o = null, s = fe, r = 0, a = this._parts.length; r < a; r++)
        for (var h = this._parts[r], u = 1, l = h.length; u < l; u++) {
          var c = s(t, i = h[u - 1], e = h[u], !0);
          c < n && (n = c, o = s(t, i, e))
        }
      return o && (o.distance = Math.sqrt(n)), o
    },
    getCenter: function() {
      if (!this._map) throw new Error("Must add layer to map before using getCenter()");
      var t, i, e, n, o, s, r, a = this._rings[0],
        h = a.length;
      if (!h) return null;
      for (i = t = 0; t < h - 1; t++) i += a[t].distanceTo(a[t + 1]) / 2;
      if (0 === i) return this._map.layerPointToLatLng(a[0]);
      for (n = t = 0; t < h - 1; t++)
        if (o = a[t], s = a[t + 1], i < (n += e = o.distanceTo(s))) return r = (n - i) / e, this._map.layerPointToLatLng([s.x - r * (s.x - o.x), s.y - r * (s.y - o.y)])
    },
    getBounds: function() {
      return this._bounds
    },
    addLatLng: function(t, i) {
      return i = i || this._defaultShape(), t = W(t), i.push(t), this._bounds.extend(t), this.redraw()
    },
    _setLatLngs: function(t) {
      this._bounds = new N, this._latlngs = this._convertLatLngs(t)
    },
    _defaultShape: function() {
      return ge(this._latlngs) ? this._latlngs : this._latlngs[0]
    },
    _convertLatLngs: function(t) {
      for (var i = [], e = ge(t), n = 0, o = t.length; n < o; n++) e ? (i[n] = W(t[n]), this._bounds.extend(i[n])) : i[n] = this._convertLatLngs(t[n]);
      return i
    },
    _project: function() {
      var t = new O;
      this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds())
    },
    _updateBounds: function() {
      var t = this._clickTolerance(),
        i = new B(t, t);
      this._pxBounds = new O([this._rawPxBounds.min.subtract(i), this._rawPxBounds.max.add(i)])
    },
    _projectLatlngs: function(t, i, e) {
      var n, o, s = t[0] instanceof j,
        r = t.length;
      if (s) {
        for (o = [], n = 0; n < r; n++) o[n] = this._map.latLngToLayerPoint(t[n]), e.extend(o[n]);
        i.push(o)
      } else
        for (n = 0; n < r; n++) this._projectLatlngs(t[n], i, e)
    },
    _clipPoints: function() {
      var t = this._renderer._bounds;
      if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t))
        if (this.options.noClip) this._parts = this._rings;
        else {
          var i, e, n, o, s, r, a, h = this._parts;
          for (n = i = 0, o = this._rings.length; i < o; i++)
            for (e = 0, s = (a = this._rings[i]).length; e < s - 1; e++)(r = de(a[e], a[e + 1], t, e, !0)) && (h[n] = h[n] || [], h[n].push(r[0]), r[1] === a[e + 1] && e !== s - 2 || (h[n].push(r[1]), n++))
        }
    },
    _simplifyPoints: function() {
      for (var t = this._parts, i = this.options.smoothFactor, e = 0, n = t.length; e < n; e++) t[e] = ce(t[e], i)
    },
    _update: function() {
      this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath())
    },
    _updatePath: function() {
      this._renderer._updatePoly(this)
    },
    _containsPoint: function(t, i) {
      var e, n, o, s, r, a, h = this._clickTolerance();
      if (!this._pxBounds || !this._pxBounds.contains(t)) return !1;
      for (e = 0, s = this._parts.length; e < s; e++)
        for (n = 0, o = (r = (a = this._parts[e]).length) - 1; n < r; o = n++)
          if ((i || 0 !== n) && _e(t, a[o], a[n]) <= h) return !0;
      return !1
    }
  });
  De._flat = ve;
  var je = De.extend({
    options: {
      fill: !0
    },
    isEmpty: function() {
      return !this._latlngs.length || !this._latlngs[0].length
    },
    getCenter: function() {
      if (!this._map) throw new Error("Must add layer to map before using getCenter()");
      var t, i, e, n, o, s, r, a, h, u = this._rings[0],
        l = u.length;
      if (!l) return null;
      for (s = r = a = 0, t = 0, i = l - 1; t < l; i = t++) e = u[t], n = u[i], o = e.y * n.x - n.y * e.x, r += (e.x + n.x) * o, a += (e.y + n.y) * o, s += 3 * o;
      return h = 0 === s ? u[0] : [r / s, a / s], this._map.layerPointToLatLng(h)
    },
    _convertLatLngs: function(t) {
      var i = De.prototype._convertLatLngs.call(this, t),
        e = i.length;
      return 2 <= e && i[0] instanceof j && i[0].equals(i[e - 1]) && i.pop(), i
    },
    _setLatLngs: function(t) {
      De.prototype._setLatLngs.call(this, t), ge(this._latlngs) && (this._latlngs = [this._latlngs])
    },
    _defaultShape: function() {
      return ge(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]
    },
    _clipPoints: function() {
      var t = this._renderer._bounds,
        i = this.options.weight,
        e = new B(i, i);
      if (t = new O(t.min.subtract(e), t.max.add(e)), this._parts = [], this._pxBounds && this._pxBounds.intersects(t))
        if (this.options.noClip) this._parts = this._rings;
        else
          for (var n, o = 0, s = this._rings.length; o < s; o++)(n = xe(this._rings[o], t, !0)).length && this._parts.push(n)
    },
    _updatePath: function() {
      this._renderer._updatePoly(this, !0)
    },
    _containsPoint: function(t) {
      var i, e, n, o, s, r, a, h, u = !1;
      if (!this._pxBounds || !this._pxBounds.contains(t)) return !1;
      for (o = 0, a = this._parts.length; o < a; o++)
        for (s = 0, r = (h = (i = this._parts[o]).length) - 1; s < h; r = s++) e = i[s], n = i[r], e.y > t.y != n.y > t.y && t.x < (n.x - e.x) * (t.y - e.y) / (n.y - e.y) + e.x && (u = !u);
      return u || De.prototype._containsPoint.call(this, t, !0)
    }
  });
  var We = Ee.extend({
    initialize: function(t, i) {
      p(this, i), this._layers = {}, t && this.addData(t)
    },
    addData: function(t) {
      var i, e, n, o = v(t) ? t : t.features;
      if (o) {
        for (i = 0, e = o.length; i < e; i++)((n = o[i]).geometries || n.geometry || n.features || n.coordinates) && this.addData(n);
        return this
      }
      var s = this.options;
      if (s.filter && !s.filter(t)) return this;
      var r = He(t, s);
      return r ? (r.feature = Ke(t), r.defaultOptions = r.options, this.resetStyle(r), s.onEachFeature && s.onEachFeature(t, r), this.addLayer(r)) : this
    },
    resetStyle: function(t) {
      return t.options = h({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this
    },
    setStyle: function(i) {
      return this.eachLayer(function(t) {
        this._setLayerStyle(t, i)
      }, this)
    },
    _setLayerStyle: function(t, i) {
      t.setStyle && ("function" == typeof i && (i = i(t.feature)), t.setStyle(i))
    }
  });

  function He(t, i) {
    var e, n, o, s, r = "Feature" === t.type ? t.geometry : t,
      a = r ? r.coordinates : null,
      h = [],
      u = i && i.pointToLayer,
      l = i && i.coordsToLatLng || Fe;
    if (!a && !r) return null;
    switch (r.type) {
      case "Point":
        return e = l(a), u ? u(t, e) : new Ie(e);
      case "MultiPoint":
        for (o = 0, s = a.length; o < s; o++) e = l(a[o]), h.push(u ? u(t, e) : new Ie(e));
        return new Ee(h);
      case "LineString":
      case "MultiLineString":
        return n = Ue(a, "LineString" === r.type ? 0 : 1, l), new De(n, i);
      case "Polygon":
      case "MultiPolygon":
        return n = Ue(a, "Polygon" === r.type ? 1 : 2, l), new je(n, i);
      case "GeometryCollection":
        for (o = 0, s = r.geometries.length; o < s; o++) {
          var c = He({
            geometry: r.geometries[o],
            type: "Feature",
            properties: t.properties
          }, i);
          c && h.push(c)
        }
        return new Ee(h);
      default:
        throw new Error("Invalid GeoJSON object.")
    }
  }

  function Fe(t) {
    return new j(t[1], t[0], t[2])
  }

  function Ue(t, i, e) {
    for (var n, o = [], s = 0, r = t.length; s < r; s++) n = i ? Ue(t[s], i - 1, e) : (e || Fe)(t[s]), o.push(n);
    return o
  }

  function Ve(t, i) {
    return i = "number" == typeof i ? i : 6, void 0 !== t.alt ? [c(t.lng, i), c(t.lat, i), c(t.alt, i)] : [c(t.lng, i), c(t.lat, i)]
  }

  function qe(t, i, e, n) {
    for (var o = [], s = 0, r = t.length; s < r; s++) o.push(i ? qe(t[s], i - 1, e, n) : Ve(t[s], n));
    return !i && e && o.push(o[0]), o
  }

  function Ge(t, i) {
    return t.feature ? h({}, t.feature, {
      geometry: i
    }) : Ke(i)
  }

  function Ke(t) {
    return "Feature" === t.type || "FeatureCollection" === t.type ? t : {
      type: "Feature",
      properties: {},
      geometry: t
    }
  }
  var Ye = {
    toGeoJSON: function(t) {
      return Ge(this, {
        type: "Point",
        coordinates: Ve(this.getLatLng(), t)
      })
    }
  };

  function Xe(t, i) {
    return new We(t, i)
  }
  Ie.include(Ye), Ne.include(Ye), Re.include(Ye), De.include({
    toGeoJSON: function(t) {
      var i = !ge(this._latlngs);
      return Ge(this, {
        type: (i ? "Multi" : "") + "LineString",
        coordinates: qe(this._latlngs, i ? 1 : 0, !1, t)
      })
    }
  }), je.include({
    toGeoJSON: function(t) {
      var i = !ge(this._latlngs),
        e = i && !ge(this._latlngs[0]),
        n = qe(this._latlngs, e ? 2 : i ? 1 : 0, !0, t);
      return i || (n = [n]), Ge(this, {
        type: (e ? "Multi" : "") + "Polygon",
        coordinates: n
      })
    }
  }), Ze.include({
    toMultiPoint: function(i) {
      var e = [];
      return this.eachLayer(function(t) {
        e.push(t.toGeoJSON(i).geometry.coordinates)
      }), Ge(this, {
        type: "MultiPoint",
        coordinates: e
      })
    },
    toGeoJSON: function(n) {
      var t = this.feature && this.feature.geometry && this.feature.geometry.type;
      if ("MultiPoint" === t) return this.toMultiPoint(n);
      var o = "GeometryCollection" === t,
        s = [];
      return this.eachLayer(function(t) {
        if (t.toGeoJSON) {
          var i = t.toGeoJSON(n);
          if (o) s.push(i.geometry);
          else {
            var e = Ke(i);
            "FeatureCollection" === e.type ? s.push.apply(s, e.features) : s.push(e)
          }
        }
      }), o ? Ge(this, {
        geometries: s,
        type: "GeometryCollection"
      }) : {
        type: "FeatureCollection",
        features: s
      }
    }
  });
  var Je = Xe,
    $e = Se.extend({
      options: {
        opacity: 1,
        alt: "",
        interactive: !1,
        crossOrigin: !1,
        errorOverlayUrl: "",
        zIndex: 1,
        className: ""
      },
      initialize: function(t, i, e) {
        this._url = t, this._bounds = D(i), p(this, e)
      },
      onAdd: function() {
        this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (pi(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset()
      },
      onRemove: function() {
        ui(this._image), this.options.interactive && this.removeInteractiveTarget(this._image)
      },
      setOpacity: function(t) {
        return this.options.opacity = t, this._image && this._updateOpacity(), this
      },
      setStyle: function(t) {
        return t.opacity && this.setOpacity(t.opacity), this
      },
      bringToFront: function() {
        return this._map && ci(this._image), this
      },
      bringToBack: function() {
        return this._map && _i(this._image), this
      },
      setUrl: function(t) {
        return this._url = t, this._image && (this._image.src = t), this
      },
      setBounds: function(t) {
        return this._bounds = D(t), this._map && this._reset(), this
      },
      getEvents: function() {
        var t = {
          zoom: this._reset,
          viewreset: this._reset
        };
        return this._zoomAnimated && (t.zoomanim = this._animateZoom), t
      },
      setZIndex: function(t) {
        return this.options.zIndex = t, this._updateZIndex(), this
      },
      getBounds: function() {
        return this._bounds
      },
      getElement: function() {
        return this._image
      },
      _initImage: function() {
        var t = "IMG" === this._url.tagName,
          i = this._image = t ? this._url : hi("img");
        pi(i, "leaflet-image-layer"), this._zoomAnimated && pi(i, "leaflet-zoom-animated"), this.options.className && pi(i, this.options.className), i.onselectstart = l, i.onmousemove = l, i.onload = a(this.fire, this, "load"), i.onerror = a(this._overlayOnError, this, "error"), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = i.src : (i.src = this._url, i.alt = this.options.alt)
      },
      _animateZoom: function(t) {
        var i = this._map.getZoomScale(t.zoom),
          e = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;
        xi(this._image, e, i)
      },
      _reset: function() {
        var t = this._image,
          i = new O(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
          e = i.getSize();
        wi(t, i.min), t.style.width = e.x + "px", t.style.height = e.y + "px"
      },
      _updateOpacity: function() {
        vi(this._image, this.options.opacity)
      },
      _updateZIndex: function() {
        this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex)
      },
      _overlayOnError: function() {
        this.fire("error");
        var t = this.options.errorOverlayUrl;
        t && this._url !== t && (this._url = t, this._image.src = t)
      }
    }),
    Qe = $e.extend({
      options: {
        autoplay: !0,
        loop: !0,
        keepAspectRatio: !0
      },
      _initImage: function() {
        var t = "VIDEO" === this._url.tagName,
          i = this._image = t ? this._url : hi("video");
        if (pi(i, "leaflet-image-layer"), this._zoomAnimated && pi(i, "leaflet-zoom-animated"), i.onselectstart = l, i.onmousemove = l, i.onloadeddata = a(this.fire, this, "load"), t) {
          for (var e = i.getElementsByTagName("source"), n = [], o = 0; o < e.length; o++) n.push(e[o].src);
          this._url = 0 < e.length ? n : [i.src]
        } else {
          v(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && i.style.hasOwnProperty("objectFit") && (i.style.objectFit = "fill"), i.autoplay = !!this.options.autoplay, i.loop = !!this.options.loop;
          for (var s = 0; s < this._url.length; s++) {
            var r = hi("source");
            r.src = this._url[s], i.appendChild(r)
          }
        }
      }
    });
  var tn = $e.extend({
    _initImage: function() {
      var t = this._image = this._url;
      pi(t, "leaflet-image-layer"), this._zoomAnimated && pi(t, "leaflet-zoom-animated"), t.onselectstart = l, t.onmousemove = l
    }
  });
  var en = Se.extend({
      options: {
        offset: [0, 7],
        className: "",
        pane: "popupPane"
      },
      initialize: function(t, i) {
        p(this, t), this._source = i
      },
      onAdd: function(t) {
        this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && vi(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && vi(this._container, 1), this.bringToFront()
      },
      onRemove: function(t) {
        t._fadeAnimated ? (vi(this._container, 0), this._removeTimeout = setTimeout(a(ui, void 0, this._container), 200)) : ui(this._container)
      },
      getLatLng: function() {
        return this._latlng
      },
      setLatLng: function(t) {
        return this._latlng = W(t), this._map && (this._updatePosition(), this._adjustPan()), this
      },
      getContent: function() {
        return this._content
      },
      setContent: function(t) {
        return this._content = t, this.update(), this
      },
      getElement: function() {
        return this._container
      },
      update: function() {
        this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
      },
      getEvents: function() {
        var t = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        return this._zoomAnimated && (t.zoomanim = this._animateZoom), t
      },
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this)
      },
      bringToFront: function() {
        return this._map && ci(this._container), this
      },
      bringToBack: function() {
        return this._map && _i(this._container), this
      },
      _prepareOpen: function(t, i, e) {
        if (i instanceof Se || (e = i, i = t), i instanceof Ee)
          for (var n in t._layers) {
            i = t._layers[n];
            break
          }
        if (!e)
          if (i.getCenter) e = i.getCenter();
          else {
            if (!i.getLatLng) throw new Error("Unable to get source layer LatLng.");
            e = i.getLatLng()
          }
        return this._source = i, this.update(), e
      },
      _updateContent: function() {
        if (this._content) {
          var t = this._contentNode,
            i = "function" == typeof this._content ? this._content(this._source || this) : this._content;
          if ("string" == typeof i) t.innerHTML = i;
          else {
            for (; t.hasChildNodes();) t.removeChild(t.firstChild);
            t.appendChild(i)
          }
          this.fire("contentupdate")
        }
      },
      _updatePosition: function() {
        if (this._map) {
          var t = this._map.latLngToLayerPoint(this._latlng),
            i = I(this.options.offset),
            e = this._getAnchor();
          this._zoomAnimated ? wi(this._container, t.add(e)) : i = i.add(t).add(e);
          var n = this._containerBottom = -i.y,
            o = this._containerLeft = -Math.round(this._containerWidth / 2) + i.x;
          this._container.style.bottom = n + "px", this._container.style.left = o + "px"
        }
      },
      _getAnchor: function() {
        return [0, 0]
      }
    }),
    nn = en.extend({
      options: {
        maxWidth: 300,
        minWidth: 50,
        maxHeight: null,
        autoPan: !0,
        autoPanPaddingTopLeft: null,
        autoPanPaddingBottomRight: null,
        autoPanPadding: [5, 5],
        keepInView: !1,
        closeButton: !0,
        autoClose: !0,
        closeOnEscapeKey: !0,
        className: ""
      },
      openOn: function(t) {
        return t.openPopup(this), this
      },
      onAdd: function(t) {
        en.prototype.onAdd.call(this, t), t.fire("popupopen", {
          popup: this
        }), this._source && (this._source.fire("popupopen", {
          popup: this
        }, !0), this._source instanceof Oe || this._source.on("preclick", Oi))
      },
      onRemove: function(t) {
        en.prototype.onRemove.call(this, t), t.fire("popupclose", {
          popup: this
        }), this._source && (this._source.fire("popupclose", {
          popup: this
        }, !0), this._source instanceof Oe || this._source.off("preclick", Oi))
      },
      getEvents: function() {
        var t = en.prototype.getEvents.call(this);
        return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t
      },
      _close: function() {
        this._map && this._map.closePopup(this)
      },
      _initLayout: function() {
        var t = "leaflet-popup",
          i = this._container = hi("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated"),
          e = this._wrapper = hi("div", t + "-content-wrapper", i);
        if (this._contentNode = hi("div", t + "-content", e), Ni(e), Ri(this._contentNode), Ei(e, "contextmenu", Oi), this._tipContainer = hi("div", t + "-tip-container", i), this._tip = hi("div", t + "-tip", this._tipContainer), this.options.closeButton) {
          var n = this._closeButton = hi("a", t + "-close-button", i);
          n.href = "#close", n.innerHTML = "&#215;", Ei(n, "click", this._onCloseButtonClick, this)
        }
      },
      _updateLayout: function() {
        var t = this._contentNode,
          i = t.style;
        i.width = "", i.whiteSpace = "nowrap";
        var e = t.offsetWidth;
        e = Math.min(e, this.options.maxWidth), e = Math.max(e, this.options.minWidth), i.width = e + 1 + "px", i.whiteSpace = "", i.height = "";
        var n = t.offsetHeight,
          o = this.options.maxHeight,
          s = "leaflet-popup-scrolled";
        o && o < n ? (i.height = o + "px", pi(t, s)) : mi(t, s), this._containerWidth = this._container.offsetWidth
      },
      _animateZoom: function(t) {
        var i = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center),
          e = this._getAnchor();
        wi(this._container, i.add(e))
      },
      _adjustPan: function() {
        if (this.options.autoPan) {
          this._map._panAnim && this._map._panAnim.stop();
          var t = this._map,
            i = parseInt(ai(this._container, "marginBottom"), 10) || 0,
            e = this._container.offsetHeight + i,
            n = this._containerWidth,
            o = new B(this._containerLeft, -e - this._containerBottom);
          o._add(Pi(this._container));
          var s = t.layerPointToContainerPoint(o),
            r = I(this.options.autoPanPadding),
            a = I(this.options.autoPanPaddingTopLeft || r),
            h = I(this.options.autoPanPaddingBottomRight || r),
            u = t.getSize(),
            l = 0,
            c = 0;
          s.x + n + h.x > u.x && (l = s.x + n - u.x + h.x), s.x - l - a.x < 0 && (l = s.x - a.x), s.y + e + h.y > u.y && (c = s.y + e - u.y + h.y), s.y - c - a.y < 0 && (c = s.y - a.y), (l || c) && t.fire("autopanstart").panBy([l, c])
        }
      },
      _onCloseButtonClick: function(t) {
        this._close(), ji(t)
      },
      _getAnchor: function() {
        return I(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0])
      }
    });
  Ji.mergeOptions({
    closePopupOnClick: !0
  }), Ji.include({
    openPopup: function(t, i, e) {
      return t instanceof nn || (t = new nn(e).setContent(t)), i && t.setLatLng(i), this.hasLayer(t) ? this : (this._popup && this._popup.options.autoClose && this.closePopup(), this._popup = t, this.addLayer(t))
    },
    closePopup: function(t) {
      return t && t !== this._popup || (t = this._popup, this._popup = null), t && this.removeLayer(t), this
    }
  }), Se.include({
    bindPopup: function(t, i) {
      return t instanceof nn ? (p(t, i), (this._popup = t)._source = this) : (this._popup && !i || (this._popup = new nn(i, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on({
        click: this._openPopup,
        keypress: this._onKeyPress,
        remove: this.closePopup,
        move: this._movePopup
      }), this._popupHandlersAdded = !0), this
    },
    unbindPopup: function() {
      return this._popup && (this.off({
        click: this._openPopup,
        keypress: this._onKeyPress,
        remove: this.closePopup,
        move: this._movePopup
      }), this._popupHandlersAdded = !1, this._popup = null), this
    },
    openPopup: function(t, i) {
      return this._popup && this._map && (i = this._popup._prepareOpen(this, t, i), this._map.openPopup(this._popup, i)), this
    },
    closePopup: function() {
      return this._popup && this._popup._close(), this
    },
    togglePopup: function(t) {
      return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(t)), this
    },
    isPopupOpen: function() {
      return !!this._popup && this._popup.isOpen()
    },
    setPopupContent: function(t) {
      return this._popup && this._popup.setContent(t), this
    },
    getPopup: function() {
      return this._popup
    },
    _openPopup: function(t) {
      var i = t.layer || t.target;
      this._popup && this._map && (ji(t), i instanceof Oe ? this.openPopup(t.layer || t.target, t.latlng) : this._map.hasLayer(this._popup) && this._popup._source === i ? this.closePopup() : this.openPopup(i, t.latlng))
    },
    _movePopup: function(t) {
      this._popup.setLatLng(t.latlng)
    },
    _onKeyPress: function(t) {
      13 === t.originalEvent.keyCode && this._openPopup(t)
    }
  });
  var on = en.extend({
    options: {
      pane: "tooltipPane",
      offset: [0, 0],
      direction: "auto",
      permanent: !1,
      sticky: !1,
      interactive: !1,
      opacity: .9
    },
    onAdd: function(t) {
      en.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", {
        tooltip: this
      }), this._source && this._source.fire("tooltipopen", {
        tooltip: this
      }, !0)
    },
    onRemove: function(t) {
      en.prototype.onRemove.call(this, t), t.fire("tooltipclose", {
        tooltip: this
      }), this._source && this._source.fire("tooltipclose", {
        tooltip: this
      }, !0)
    },
    getEvents: function() {
      var t = en.prototype.getEvents.call(this);
      return Tt && !this.options.permanent && (t.preclick = this._close), t
    },
    _close: function() {
      this._map && this._map.closeTooltip(this)
    },
    _initLayout: function() {
      var t = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
      this._contentNode = this._container = hi("div", t)
    },
    _updateLayout: function() {},
    _adjustPan: function() {},
    _setPosition: function(t) {
      var i = this._map,
        e = this._container,
        n = i.latLngToContainerPoint(i.getCenter()),
        o = i.layerPointToContainerPoint(t),
        s = this.options.direction,
        r = e.offsetWidth,
        a = e.offsetHeight,
        h = I(this.options.offset),
        u = this._getAnchor();
      t = "top" === s ? t.add(I(-r / 2 + h.x, -a + h.y + u.y, !0)) : "bottom" === s ? t.subtract(I(r / 2 - h.x, -h.y, !0)) : "center" === s ? t.subtract(I(r / 2 + h.x, a / 2 - u.y + h.y, !0)) : "right" === s || "auto" === s && o.x < n.x ? (s = "right", t.add(I(h.x + u.x, u.y - a / 2 + h.y, !0))) : (s = "left", t.subtract(I(r + u.x - h.x, a / 2 - u.y - h.y, !0))), mi(e, "leaflet-tooltip-right"), mi(e, "leaflet-tooltip-left"), mi(e, "leaflet-tooltip-top"), mi(e, "leaflet-tooltip-bottom"), pi(e, "leaflet-tooltip-" + s), wi(e, t)
    },
    _updatePosition: function() {
      var t = this._map.latLngToLayerPoint(this._latlng);
      this._setPosition(t)
    },
    setOpacity: function(t) {
      this.options.opacity = t, this._container && vi(this._container, t)
    },
    _animateZoom: function(t) {
      var i = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
      this._setPosition(i)
    },
    _getAnchor: function() {
      return I(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0])
    }
  });
  Ji.include({
    openTooltip: function(t, i, e) {
      return t instanceof on || (t = new on(e).setContent(t)), i && t.setLatLng(i), this.hasLayer(t) ? this : this.addLayer(t)
    },
    closeTooltip: function(t) {
      return t && this.removeLayer(t), this
    }
  }), Se.include({
    bindTooltip: function(t, i) {
      return t instanceof on ? (p(t, i), (this._tooltip = t)._source = this) : (this._tooltip && !i || (this._tooltip = new on(i, this)), this._tooltip.setContent(t)), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this
    },
    unbindTooltip: function() {
      return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this
    },
    _initTooltipInteractions: function(t) {
      if (t || !this._tooltipHandlersAdded) {
        var i = t ? "off" : "on",
          e = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
        this._tooltip.options.permanent ? e.add = this._openTooltip : (e.mouseover = this._openTooltip, e.mouseout = this.closeTooltip, this._tooltip.options.sticky && (e.mousemove = this._moveTooltip), Tt && (e.click = this._openTooltip)), this[i](e), this._tooltipHandlersAdded = !t
      }
    },
    openTooltip: function(t, i) {
      return this._tooltip && this._map && (i = this._tooltip._prepareOpen(this, t, i), this._map.openTooltip(this._tooltip, i), this._tooltip.options.interactive && this._tooltip._container && (pi(this._tooltip._container, "leaflet-clickable"), this.addInteractiveTarget(this._tooltip._container))), this
    },
    closeTooltip: function() {
      return this._tooltip && (this._tooltip._close(), this._tooltip.options.interactive && this._tooltip._container && (mi(this._tooltip._container, "leaflet-clickable"), this.removeInteractiveTarget(this._tooltip._container))), this
    },
    toggleTooltip: function(t) {
      return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this.openTooltip(t)), this
    },
    isTooltipOpen: function() {
      return this._tooltip.isOpen()
    },
    setTooltipContent: function(t) {
      return this._tooltip && this._tooltip.setContent(t), this
    },
    getTooltip: function() {
      return this._tooltip
    },
    _openTooltip: function(t) {
      var i = t.layer || t.target;
      this._tooltip && this._map && this.openTooltip(i, this._tooltip.options.sticky ? t.latlng : void 0)
    },
    _moveTooltip: function(t) {
      var i, e, n = t.latlng;
      this._tooltip.options.sticky && t.originalEvent && (i = this._map.mouseEventToContainerPoint(t.originalEvent), e = this._map.containerPointToLayerPoint(i), n = this._map.layerPointToLatLng(e)), this._tooltip.setLatLng(n)
    }
  });
  var sn = ke.extend({
    options: {
      iconSize: [12, 12],
      html: !1,
      bgPos: null,
      className: "leaflet-div-icon"
    },
    createIcon: function(t) {
      var i = t && "DIV" === t.tagName ? t : document.createElement("div"),
        e = this.options;
      if (e.html instanceof Element ? (li(i), i.appendChild(e.html)) : i.innerHTML = !1 !== e.html ? e.html : "", e.bgPos) {
        var n = I(e.bgPos);
        i.style.backgroundPosition = -n.x + "px " + -n.y + "px"
      }
      return this._setIconStyles(i, "icon"), i
    },
    createShadow: function() {
      return null
    }
  });
  ke.Default = Be;
  var rn = Se.extend({
    options: {
      tileSize: 256,
      opacity: 1,
      updateWhenIdle: xt,
      updateWhenZooming: !0,
      updateInterval: 200,
      zIndex: 1,
      bounds: null,
      minZoom: 0,
      maxZoom: void 0,
      maxNativeZoom: void 0,
      minNativeZoom: void 0,
      noWrap: !1,
      pane: "tilePane",
      className: "",
      keepBuffer: 2
    },
    initialize: function(t) {
      p(this, t)
    },
    onAdd: function() {
      this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(), this._update()
    },
    beforeAdd: function(t) {
      t._addZoomLimit(this)
    },
    onRemove: function(t) {
      this._removeAllTiles(), ui(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0
    },
    bringToFront: function() {
      return this._map && (ci(this._container), this._setAutoZIndex(Math.max)), this
    },
    bringToBack: function() {
      return this._map && (_i(this._container), this._setAutoZIndex(Math.min)), this
    },
    getContainer: function() {
      return this._container
    },
    setOpacity: function(t) {
      return this.options.opacity = t, this._updateOpacity(), this
    },
    setZIndex: function(t) {
      return this.options.zIndex = t, this._updateZIndex(), this
    },
    isLoading: function() {
      return this._loading
    },
    redraw: function() {
      return this._map && (this._removeAllTiles(), this._update()), this
    },
    getEvents: function() {
      var t = {
        viewprereset: this._invalidateAll,
        viewreset: this._resetView,
        zoom: this._resetView,
        moveend: this._onMoveEnd
      };
      return this.options.updateWhenIdle || (this._onMove || (this._onMove = o(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t
    },
    createTile: function() {
      return document.createElement("div")
    },
    getTileSize: function() {
      var t = this.options.tileSize;
      return t instanceof B ? t : new B(t, t)
    },
    _updateZIndex: function() {
      this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex)
    },
    _setAutoZIndex: function(t) {
      for (var i, e = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = e.length; o < s; o++) i = e[o].style.zIndex, e[o] !== this._container && i && (n = t(n, +i));
      isFinite(n) && (this.options.zIndex = n + t(-1, 1), this._updateZIndex())
    },
    _updateOpacity: function() {
      if (this._map && !et) {
        vi(this._container, this.options.opacity);
        var t = +new Date,
          i = !1,
          e = !1;
        for (var n in this._tiles) {
          var o = this._tiles[n];
          if (o.current && o.loaded) {
            var s = Math.min(1, (t - o.loaded) / 200);
            vi(o.el, s), s < 1 ? i = !0 : (o.active ? e = !0 : this._onOpaqueTile(o), o.active = !0)
          }
        }
        e && !this._noPrune && this._pruneTiles(), i && (C(this._fadeFrame), this._fadeFrame = M(this._updateOpacity, this))
      }
    },
    _onOpaqueTile: l,
    _initContainer: function() {
      this._container || (this._container = hi("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container))
    },
    _updateLevels: function() {
      var t = this._tileZoom,
        i = this.options.maxZoom;
      if (void 0 !== t) {
        for (var e in this._levels) this._levels[e].el.children.length || e === t ? (this._levels[e].el.style.zIndex = i - Math.abs(t - e), this._onUpdateLevel(e)) : (ui(this._levels[e].el), this._removeTilesAtZoom(e), this._onRemoveLevel(e), delete this._levels[e]);
        var n = this._levels[t],
          o = this._map;
        return n || ((n = this._levels[t] = {}).el = hi("div", "leaflet-tile-container leaflet-zoom-animated", this._container), n.el.style.zIndex = i, n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, o.getCenter(), o.getZoom()), n.el.offsetWidth, this._onCreateLevel(n)), this._level = n
      }
    },
    _onUpdateLevel: l,
    _onRemoveLevel: l,
    _onCreateLevel: l,
    _pruneTiles: function() {
      if (this._map) {
        var t, i, e = this._map.getZoom();
        if (e > this.options.maxZoom || e < this.options.minZoom) this._removeAllTiles();
        else {
          for (t in this._tiles)(i = this._tiles[t]).retain = i.current;
          for (t in this._tiles)
            if ((i = this._tiles[t]).current && !i.active) {
              var n = i.coords;
              this._retainParent(n.x, n.y, n.z, n.z - 5) || this._retainChildren(n.x, n.y, n.z, n.z + 2)
            }
          for (t in this._tiles) this._tiles[t].retain || this._removeTile(t)
        }
      }
    },
    _removeTilesAtZoom: function(t) {
      for (var i in this._tiles) this._tiles[i].coords.z === t && this._removeTile(i)
    },
    _removeAllTiles: function() {
      for (var t in this._tiles) this._removeTile(t)
    },
    _invalidateAll: function() {
      for (var t in this._levels) ui(this._levels[t].el), this._onRemoveLevel(t), delete this._levels[t];
      this._removeAllTiles(), this._tileZoom = void 0
    },
    _retainParent: function(t, i, e, n) {
      var o = Math.floor(t / 2),
        s = Math.floor(i / 2),
        r = e - 1,
        a = new B(+o, +s);
      a.z = +r;
      var h = this._tileCoordsToKey(a),
        u = this._tiles[h];
      return u && u.active ? u.retain = !0 : (u && u.loaded && (u.retain = !0), n < r && this._retainParent(o, s, r, n))
    },
    _retainChildren: function(t, i, e, n) {
      for (var o = 2 * t; o < 2 * t + 2; o++)
        for (var s = 2 * i; s < 2 * i + 2; s++) {
          var r = new B(o, s);
          r.z = e + 1;
          var a = this._tileCoordsToKey(r),
            h = this._tiles[a];
          h && h.active ? h.retain = !0 : (h && h.loaded && (h.retain = !0), e + 1 < n && this._retainChildren(o, s, e + 1, n))
        }
    },
    _resetView: function(t) {
      var i = t && (t.pinch || t.flyTo);
      this._setView(this._map.getCenter(), this._map.getZoom(), i, i)
    },
    _animateZoom: function(t) {
      this._setView(t.center, t.zoom, !0, t.noUpdate)
    },
    _clampZoom: function(t) {
      var i = this.options;
      return void 0 !== i.minNativeZoom && t < i.minNativeZoom ? i.minNativeZoom : void 0 !== i.maxNativeZoom && i.maxNativeZoom < t ? i.maxNativeZoom : t
    },
    _setView: function(t, i, e, n) {
      var o = this._clampZoom(Math.round(i));
      (void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom) && (o = void 0);
      var s = this.options.updateWhenZooming && o !== this._tileZoom;
      n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), e || this._pruneTiles(), this._noPrune = !!e), this._setZoomTransforms(t, i)
    },
    _setZoomTransforms: function(t, i) {
      for (var e in this._levels) this._setZoomTransform(this._levels[e], t, i)
    },
    _setZoomTransform: function(t, i, e) {
      var n = this._map.getZoomScale(e, t.zoom),
        o = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(i, e)).round();
      yt ? xi(t.el, o, n) : wi(t.el, o)
    },
    _resetGrid: function() {
      var t = this._map,
        i = t.options.crs,
        e = this._tileSize = this.getTileSize(),
        n = this._tileZoom,
        o = this._map.getPixelWorldBounds(this._tileZoom);
      o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = i.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, i.wrapLng[0]], n).x / e.x), Math.ceil(t.project([0, i.wrapLng[1]], n).x / e.y)], this._wrapY = i.wrapLat && !this.options.noWrap && [Math.floor(t.project([i.wrapLat[0], 0], n).y / e.x), Math.ceil(t.project([i.wrapLat[1], 0], n).y / e.y)]
    },
    _onMoveEnd: function() {
      this._map && !this._map._animatingZoom && this._update()
    },
    _getTiledPixelBounds: function(t) {
      var i = this._map,
        e = i._animatingZoom ? Math.max(i._animateToZoom, i.getZoom()) : i.getZoom(),
        n = i.getZoomScale(e, this._tileZoom),
        o = i.project(t, this._tileZoom).floor(),
        s = i.getSize().divideBy(2 * n);
      return new O(o.subtract(s), o.add(s))
    },
    _update: function(t) {
      var i = this._map;
      if (i) {
        var e = this._clampZoom(i.getZoom());
        if (void 0 === t && (t = i.getCenter()), void 0 !== this._tileZoom) {
          var n = this._getTiledPixelBounds(t),
            o = this._pxBoundsToTileRange(n),
            s = o.getCenter(),
            r = [],
            a = this.options.keepBuffer,
            h = new O(o.getBottomLeft().subtract([a, -a]), o.getTopRight().add([a, -a]));
          if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) throw new Error("Attempted to load an infinite number of tiles");
          for (var u in this._tiles) {
            var l = this._tiles[u].coords;
            l.z === this._tileZoom && h.contains(new B(l.x, l.y)) || (this._tiles[u].current = !1)
          }
          if (1 < Math.abs(e - this._tileZoom)) this._setView(t, e);
          else {
            for (var c = o.min.y; c <= o.max.y; c++)
              for (var _ = o.min.x; _ <= o.max.x; _++) {
                var d = new B(_, c);
                if (d.z = this._tileZoom, this._isValidTile(d)) {
                  var p = this._tiles[this._tileCoordsToKey(d)];
                  p ? p.current = !0 : r.push(d)
                }
              }
            if (r.sort(function(t, i) {
                return t.distanceTo(s) - i.distanceTo(s)
              }), 0 !== r.length) {
              this._loading || (this._loading = !0, this.fire("loading"));
              var m = document.createDocumentFragment();
              for (_ = 0; _ < r.length; _++) this._addTile(r[_], m);
              this._level.el.appendChild(m)
            }
          }
        }
      }
    },
    _isValidTile: function(t) {
      var i = this._map.options.crs;
      if (!i.infinite) {
        var e = this._globalTileRange;
        if (!i.wrapLng && (t.x < e.min.x || t.x > e.max.x) || !i.wrapLat && (t.y < e.min.y || t.y > e.max.y)) return !1
      }
      if (!this.options.bounds) return !0;
      var n = this._tileCoordsToBounds(t);
      return D(this.options.bounds).overlaps(n)
    },
    _keyToBounds: function(t) {
      return this._tileCoordsToBounds(this._keyToTileCoords(t))
    },
    _tileCoordsToNwSe: function(t) {
      var i = this._map,
        e = this.getTileSize(),
        n = t.scaleBy(e),
        o = n.add(e);
      return [i.unproject(n, t.z), i.unproject(o, t.z)]
    },
    _tileCoordsToBounds: function(t) {
      var i = this._tileCoordsToNwSe(t),
        e = new N(i[0], i[1]);
      return this.options.noWrap || (e = this._map.wrapLatLngBounds(e)), e
    },
    _tileCoordsToKey: function(t) {
      return t.x + ":" + t.y + ":" + t.z
    },
    _keyToTileCoords: function(t) {
      var i = t.split(":"),
        e = new B(+i[0], +i[1]);
      return e.z = +i[2], e
    },
    _removeTile: function(t) {
      var i = this._tiles[t];
      i && (ui(i.el), delete this._tiles[t], this.fire("tileunload", {
        tile: i.el,
        coords: this._keyToTileCoords(t)
      }))
    },
    _initTile: function(t) {
      pi(t, "leaflet-tile");
      var i = this.getTileSize();
      t.style.width = i.x + "px", t.style.height = i.y + "px", t.onselectstart = l, t.onmousemove = l, et && this.options.opacity < 1 && vi(t, this.options.opacity), st && !rt && (t.style.WebkitBackfaceVisibility = "hidden")
    },
    _addTile: function(t, i) {
      var e = this._getTilePos(t),
        n = this._tileCoordsToKey(t),
        o = this.createTile(this._wrapCoords(t), a(this._tileReady, this, t));
      this._initTile(o), this.createTile.length < 2 && M(a(this._tileReady, this, t, null, o)), wi(o, e), this._tiles[n] = {
        el: o,
        coords: t,
        current: !0
      }, i.appendChild(o), this.fire("tileloadstart", {
        tile: o,
        coords: t
      })
    },
    _tileReady: function(t, i, e) {
      i && this.fire("tileerror", {
        error: i,
        tile: e,
        coords: t
      });
      var n = this._tileCoordsToKey(t);
      (e = this._tiles[n]) && (e.loaded = +new Date, this._map._fadeAnimated ? (vi(e.el, 0), C(this._fadeFrame), this._fadeFrame = M(this._updateOpacity, this)) : (e.active = !0, this._pruneTiles()), i || (pi(e.el, "leaflet-tile-loaded"), this.fire("tileload", {
        tile: e.el,
        coords: t
      })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), et || !this._map._fadeAnimated ? M(this._pruneTiles, this) : setTimeout(a(this._pruneTiles, this), 250)))
    },
    _getTilePos: function(t) {
      return t.scaleBy(this.getTileSize()).subtract(this._level.origin)
    },
    _wrapCoords: function(t) {
      var i = new B(this._wrapX ? r(t.x, this._wrapX) : t.x, this._wrapY ? r(t.y, this._wrapY) : t.y);
      return i.z = t.z, i
    },
    _pxBoundsToTileRange: function(t) {
      var i = this.getTileSize();
      return new O(t.min.unscaleBy(i).floor(), t.max.unscaleBy(i).ceil().subtract([1, 1]))
    },
    _noTilesToLoad: function() {
      for (var t in this._tiles)
        if (!this._tiles[t].loaded) return !1;
      return !0
    }
  });
  var an = rn.extend({
    options: {
      minZoom: 0,
      maxZoom: 18,
      subdomains: "abc",
      errorTileUrl: "",
      zoomOffset: 0,
      tms: !1,
      zoomReverse: !1,
      detectRetina: !1,
      crossOrigin: !1
    },
    initialize: function(t, i) {
      this._url = t, (i = p(this, i)).detectRetina && Ct && 0 < i.maxZoom && (i.tileSize = Math.floor(i.tileSize / 2), i.zoomReverse ? (i.zoomOffset--, i.minZoom++) : (i.zoomOffset++, i.maxZoom--), i.minZoom = Math.max(0, i.minZoom)), "string" == typeof i.subdomains && (i.subdomains = i.subdomains.split("")), st || this.on("tileunload", this._onTileRemove)
    },
    setUrl: function(t, i) {
      return this._url === t && void 0 === i && (i = !0), this._url = t, i || this.redraw(), this
    },
    createTile: function(t, i) {
      var e = document.createElement("img");
      return Ei(e, "load", a(this._tileOnLoad, this, i, e)), Ei(e, "error", a(this._tileOnError, this, i, e)), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), e.alt = "", e.setAttribute("role", "presentation"), e.src = this.getTileUrl(t), e
    },
    getTileUrl: function(t) {
      var i = {
        r: Ct ? "@2x" : "",
        s: this._getSubdomain(t),
        x: t.x,
        y: t.y,
        z: this._getZoomForUrl()
      };
      if (this._map && !this._map.options.crs.infinite) {
        var e = this._globalTileRange.max.y - t.y;
        this.options.tms && (i.y = e), i["-y"] = e
      }
      return g(this._url, h(i, this.options))
    },
    _tileOnLoad: function(t, i) {
      et ? setTimeout(a(t, this, null, i), 0) : t(null, i)
    },
    _tileOnError: function(t, i, e) {
      var n = this.options.errorTileUrl;
      n && i.getAttribute("src") !== n && (i.src = n), t(e, i)
    },
    _onTileRemove: function(t) {
      t.tile.onload = null
    },
    _getZoomForUrl: function() {
      var t = this._tileZoom,
        i = this.options.maxZoom;
      return this.options.zoomReverse && (t = i - t), t + this.options.zoomOffset
    },
    _getSubdomain: function(t) {
      var i = Math.abs(t.x + t.y) % this.options.subdomains.length;
      return this.options.subdomains[i]
    },
    _abortLoading: function() {
      var t, i;
      for (t in this._tiles) this._tiles[t].coords.z !== this._tileZoom && ((i = this._tiles[t].el).onload = l, i.onerror = l, i.complete || (i.src = x, ui(i), delete this._tiles[t]))
    },
    _removeTile: function(t) {
      var i = this._tiles[t];
      if (i) return ht || i.el.setAttribute("src", x), rn.prototype._removeTile.call(this, t)
    },
    _tileReady: function(t, i, e) {
      if (this._map && (!e || e.getAttribute("src") !== x)) return rn.prototype._tileReady.call(this, t, i, e)
    }
  });

  function hn(t, i) {
    return new an(t, i)
  }
  var un = an.extend({
    defaultWmsParams: {
      service: "WMS",
      request: "GetMap",
      layers: "",
      styles: "",
      format: "image/jpeg",
      transparent: !1,
      version: "1.1.1"
    },
    options: {
      crs: null,
      uppercase: !1
    },
    initialize: function(t, i) {
      this._url = t;
      var e = h({}, this.defaultWmsParams);
      for (var n in i) n in this.options || (e[n] = i[n]);
      var o = (i = p(this, i)).detectRetina && Ct ? 2 : 1,
        s = this.getTileSize();
      e.width = s.x * o, e.height = s.y * o, this.wmsParams = e
    },
    onAdd: function(t) {
      this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
      var i = 1.3 <= this._wmsVersion ? "crs" : "srs";
      this.wmsParams[i] = this._crs.code, an.prototype.onAdd.call(this, t)
    },
    getTileUrl: function(t) {
      var i = this._tileCoordsToNwSe(t),
        e = this._crs,
        n = R(e.project(i[0]), e.project(i[1])),
        o = n.min,
        s = n.max,
        r = (1.3 <= this._wmsVersion && this._crs === Me ? [o.y, o.x, s.y, s.x] : [o.x, o.y, s.x, s.y]).join(","),
        a = an.prototype.getTileUrl.call(this, t);
      return a + m(this.wmsParams, a, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + r
    },
    setParams: function(t, i) {
      return h(this.wmsParams, t), i || this.redraw(), this
    }
  });
  an.WMS = un, hn.wms = function(t, i) {
    return new un(t, i)
  };
  var ln = Se.extend({
      options: {
        padding: .1,
        tolerance: 0
      },
      initialize: function(t) {
        p(this, t), u(this), this._layers = this._layers || {}
      },
      onAdd: function() {
        this._container || (this._initContainer(), this._zoomAnimated && pi(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this)
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this), this._destroyContainer()
      },
      getEvents: function() {
        var t = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t
      },
      _onAnimZoom: function(t) {
        this._updateTransform(t.center, t.zoom)
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom())
      },
      _updateTransform: function(t, i) {
        var e = this._map.getZoomScale(i, this._zoom),
          n = Pi(this._container),
          o = this._map.getSize().multiplyBy(.5 + this.options.padding),
          s = this._map.project(this._center, i),
          r = this._map.project(t, i).subtract(s),
          a = o.multiplyBy(-e).add(n).add(o).subtract(r);
        yt ? xi(this._container, a, e) : wi(this._container, a)
      },
      _reset: function() {
        for (var t in this._update(), this._updateTransform(this._center, this._zoom), this._layers) this._layers[t]._reset()
      },
      _onZoomEnd: function() {
        for (var t in this._layers) this._layers[t]._project()
      },
      _updatePaths: function() {
        for (var t in this._layers) this._layers[t]._update()
      },
      _update: function() {
        var t = this.options.padding,
          i = this._map.getSize(),
          e = this._map.containerPointToLayerPoint(i.multiplyBy(-t)).round();
        this._bounds = new O(e, e.add(i.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom()
      }
    }),
    cn = ln.extend({
      getEvents: function() {
        var t = ln.prototype.getEvents.call(this);
        return t.viewprereset = this._onViewPreReset, t
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = !0
      },
      onAdd: function() {
        ln.prototype.onAdd.call(this), this._draw()
      },
      _initContainer: function() {
        var t = this._container = document.createElement("canvas");
        Ei(t, "mousemove", o(this._onMouseMove, 32, this), this), Ei(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), Ei(t, "mouseout", this._handleMouseOut, this), this._ctx = t.getContext("2d")
      },
      _destroyContainer: function() {
        C(this._redrawRequest), delete this._ctx, ui(this._container), Bi(this._container), delete this._container
      },
      _updatePaths: function() {
        if (!this._postponeUpdatePaths) {
          for (var t in this._redrawBounds = null, this._layers) this._layers[t]._update();
          this._redraw()
        }
      },
      _update: function() {
        if (!this._map._animatingZoom || !this._bounds) {
          ln.prototype._update.call(this);
          var t = this._bounds,
            i = this._container,
            e = t.getSize(),
            n = Ct ? 2 : 1;
          wi(i, t.min), i.width = n * e.x, i.height = n * e.y, i.style.width = e.x + "px", i.style.height = e.y + "px", Ct && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update")
        }
      },
      _reset: function() {
        ln.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths())
      },
      _initPath: function(t) {
        this._updateDashArray(t);
        var i = (this._layers[u(t)] = t)._order = {
          layer: t,
          prev: this._drawLast,
          next: null
        };
        this._drawLast && (this._drawLast.next = i), this._drawLast = i, this._drawFirst = this._drawFirst || this._drawLast
      },
      _addPath: function(t) {
        this._requestRedraw(t)
      },
      _removePath: function(t) {
        var i = t._order,
          e = i.next,
          n = i.prev;
        e ? e.prev = n : this._drawLast = n, n ? n.next = e : this._drawFirst = e, delete t._order, delete this._layers[u(t)], this._requestRedraw(t)
      },
      _updatePath: function(t) {
        this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t)
      },
      _updateStyle: function(t) {
        this._updateDashArray(t), this._requestRedraw(t)
      },
      _updateDashArray: function(t) {
        if ("string" == typeof t.options.dashArray) {
          var i, e, n = t.options.dashArray.split(/[, ]+/),
            o = [];
          for (e = 0; e < n.length; e++) {
            if (i = Number(n[e]), isNaN(i)) return;
            o.push(i)
          }
          t.options._dashArray = o
        } else t.options._dashArray = t.options.dashArray
      },
      _requestRedraw: function(t) {
        this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || M(this._redraw, this))
      },
      _extendRedrawBounds: function(t) {
        if (t._pxBounds) {
          var i = (t.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new O, this._redrawBounds.extend(t._pxBounds.min.subtract([i, i])), this._redrawBounds.extend(t._pxBounds.max.add([i, i]))
        }
      },
      _redraw: function() {
        this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null
      },
      _clear: function() {
        var t = this._redrawBounds;
        if (t) {
          var i = t.getSize();
          this._ctx.clearRect(t.min.x, t.min.y, i.x, i.y)
        } else this._ctx.clearRect(0, 0, this._container.width, this._container.height)
      },
      _draw: function() {
        var t, i = this._redrawBounds;
        if (this._ctx.save(), i) {
          var e = i.getSize();
          this._ctx.beginPath(), this._ctx.rect(i.min.x, i.min.y, e.x, e.y), this._ctx.clip()
        }
        this._drawing = !0;
        for (var n = this._drawFirst; n; n = n.next) t = n.layer, (!i || t._pxBounds && t._pxBounds.intersects(i)) && t._updatePath();
        this._drawing = !1, this._ctx.restore()
      },
      _updatePoly: function(t, i) {
        if (this._drawing) {
          var e, n, o, s, r = t._parts,
            a = r.length,
            h = this._ctx;
          if (a) {
            for (h.beginPath(), e = 0; e < a; e++) {
              for (n = 0, o = r[e].length; n < o; n++) s = r[e][n], h[n ? "lineTo" : "moveTo"](s.x, s.y);
              i && h.closePath()
            }
            this._fillStroke(h, t)
          }
        }
      },
      _updateCircle: function(t) {
        if (this._drawing && !t._empty()) {
          var i = t._point,
            e = this._ctx,
            n = Math.max(Math.round(t._radius), 1),
            o = (Math.max(Math.round(t._radiusY), 1) || n) / n;
          1 != o && (e.save(), e.scale(1, o)), e.beginPath(), e.arc(i.x, i.y / o, n, 0, 2 * Math.PI, !1), 1 != o && e.restore(), this._fillStroke(e, t)
        }
      },
      _fillStroke: function(t, i) {
        var e = i.options;
        e.fill && (t.globalAlpha = e.fillOpacity, t.fillStyle = e.fillColor || e.color, t.fill(e.fillRule || "evenodd")), e.stroke && 0 !== e.weight && (t.setLineDash && t.setLineDash(i.options && i.options._dashArray || []), t.globalAlpha = e.opacity, t.lineWidth = e.weight, t.strokeStyle = e.color, t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.stroke())
      },
      _onClick: function(t) {
        for (var i, e, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next)(i = o.layer).options.interactive && i._containsPoint(n) && !this._map._draggableMoved(i) && (e = i);
        e && (qi(t), this._fireEvent([e], t))
      },
      _onMouseMove: function(t) {
        if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {
          var i = this._map.mouseEventToLayerPoint(t);
          this._handleMouseHover(t, i)
        }
      },
      _handleMouseOut: function(t) {
        var i = this._hoveredLayer;
        i && (mi(this._container, "leaflet-interactive"), this._fireEvent([i], t, "mouseout"), this._hoveredLayer = null)
      },
      _handleMouseHover: function(t, i) {
        for (var e, n, o = this._drawFirst; o; o = o.next)(e = o.layer).options.interactive && e._containsPoint(i) && (n = e);
        n !== this._hoveredLayer && (this._handleMouseOut(t), n && (pi(this._container, "leaflet-interactive"), this._fireEvent([n], t, "mouseover"), this._hoveredLayer = n)), this._hoveredLayer && this._fireEvent([this._hoveredLayer], t)
      },
      _fireEvent: function(t, i, e) {
        this._map._fireDOMEvent(i, e || i.type, t)
      },
      _bringToFront: function(t) {
        var i = t._order;
        if (i) {
          var e = i.next,
            n = i.prev;
          e && ((e.prev = n) ? n.next = e : e && (this._drawFirst = e), i.prev = this._drawLast, (this._drawLast.next = i).next = null, this._drawLast = i, this._requestRedraw(t))
        }
      },
      _bringToBack: function(t) {
        var i = t._order;
        if (i) {
          var e = i.next,
            n = i.prev;
          n && ((n.next = e) ? e.prev = n : n && (this._drawLast = n), i.prev = null, i.next = this._drawFirst, this._drawFirst.prev = i, this._drawFirst = i, this._requestRedraw(t))
        }
      }
    });

  function _n(t) {
    return St ? new cn(t) : null
  }
  var dn = function() {
      try {
        return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
          function(t) {
            return document.createElement("<lvml:" + t + ' class="lvml">')
          }
      } catch (t) {
        return function(t) {
          return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
        }
      }
    }(),
    pn = {
      _initContainer: function() {
        this._container = hi("div", "leaflet-vml-container")
      },
      _update: function() {
        this._map._animatingZoom || (ln.prototype._update.call(this), this.fire("update"))
      },
      _initPath: function(t) {
        var i = t._container = dn("shape");
        pi(i, "leaflet-vml-shape " + (this.options.className || "")), i.coordsize = "1 1", t._path = dn("path"), i.appendChild(t._path), this._updateStyle(t), this._layers[u(t)] = t
      },
      _addPath: function(t) {
        var i = t._container;
        this._container.appendChild(i), t.options.interactive && t.addInteractiveTarget(i)
      },
      _removePath: function(t) {
        var i = t._container;
        ui(i), t.removeInteractiveTarget(i), delete this._layers[u(t)]
      },
      _updateStyle: function(t) {
        var i = t._stroke,
          e = t._fill,
          n = t.options,
          o = t._container;
        o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (i || (i = t._stroke = dn("stroke")), o.appendChild(i), i.weight = n.weight + "px", i.color = n.color, i.opacity = n.opacity, n.dashArray ? i.dashStyle = v(n.dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g, " ") : i.dashStyle = "", i.endcap = n.lineCap.replace("butt", "flat"), i.joinstyle = n.lineJoin) : i && (o.removeChild(i), t._stroke = null), n.fill ? (e || (e = t._fill = dn("fill")), o.appendChild(e), e.color = n.fillColor || n.color, e.opacity = n.fillOpacity) : e && (o.removeChild(e), t._fill = null)
      },
      _updateCircle: function(t) {
        var i = t._point.round(),
          e = Math.round(t._radius),
          n = Math.round(t._radiusY || e);
        this._setPath(t, t._empty() ? "M0 0" : "AL " + i.x + "," + i.y + " " + e + "," + n + " 0,23592600")
      },
      _setPath: function(t, i) {
        t._path.v = i
      },
      _bringToFront: function(t) {
        ci(t._container)
      },
      _bringToBack: function(t) {
        _i(t._container)
      }
    },
    mn = Et ? dn : $,
    fn = ln.extend({
      getEvents: function() {
        var t = ln.prototype.getEvents.call(this);
        return t.zoomstart = this._onZoomStart, t
      },
      _initContainer: function() {
        this._container = mn("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = mn("g"), this._container.appendChild(this._rootGroup)
      },
      _destroyContainer: function() {
        ui(this._container), Bi(this._container), delete this._container, delete this._rootGroup, delete this._svgSize
      },
      _onZoomStart: function() {
        this._update()
      },
      _update: function() {
        if (!this._map._animatingZoom || !this._bounds) {
          ln.prototype._update.call(this);
          var t = this._bounds,
            i = t.getSize(),
            e = this._container;
          this._svgSize && this._svgSize.equals(i) || (this._svgSize = i, e.setAttribute("width", i.x), e.setAttribute("height", i.y)), wi(e, t.min), e.setAttribute("viewBox", [t.min.x, t.min.y, i.x, i.y].join(" ")), this.fire("update")
        }
      },
      _initPath: function(t) {
        var i = t._path = mn("path");
        t.options.className && pi(i, t.options.className), t.options.interactive && pi(i, "leaflet-interactive"), this._updateStyle(t), this._layers[u(t)] = t
      },
      _addPath: function(t) {
        this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path)
      },
      _removePath: function(t) {
        ui(t._path), t.removeInteractiveTarget(t._path), delete this._layers[u(t)]
      },
      _updatePath: function(t) {
        t._project(), t._update()
      },
      _updateStyle: function(t) {
        var i = t._path,
          e = t.options;
        i && (e.stroke ? (i.setAttribute("stroke", e.color), i.setAttribute("stroke-opacity", e.opacity), i.setAttribute("stroke-width", e.weight), i.setAttribute("stroke-linecap", e.lineCap), i.setAttribute("stroke-linejoin", e.lineJoin), e.dashArray ? i.setAttribute("stroke-dasharray", e.dashArray) : i.removeAttribute("stroke-dasharray"), e.dashOffset ? i.setAttribute("stroke-dashoffset", e.dashOffset) : i.removeAttribute("stroke-dashoffset")) : i.setAttribute("stroke", "none"), e.fill ? (i.setAttribute("fill", e.fillColor || e.color), i.setAttribute("fill-opacity", e.fillOpacity), i.setAttribute("fill-rule", e.fillRule || "evenodd")) : i.setAttribute("fill", "none"))
      },
      _updatePoly: function(t, i) {
        this._setPath(t, Q(t._parts, i))
      },
      _updateCircle: function(t) {
        var i = t._point,
          e = Math.max(Math.round(t._radius), 1),
          n = "a" + e + "," + (Math.max(Math.round(t._radiusY), 1) || e) + " 0 1,0 ",
          o = t._empty() ? "M0 0" : "M" + (i.x - e) + "," + i.y + n + 2 * e + ",0 " + n + 2 * -e + ",0 ";
        this._setPath(t, o)
      },
      _setPath: function(t, i) {
        t._path.setAttribute("d", i)
      },
      _bringToFront: function(t) {
        ci(t._path)
      },
      _bringToBack: function(t) {
        _i(t._path)
      }
    });

  function gn(t) {
    return Zt || Et ? new fn(t) : null
  }
  Et && fn.include(pn), Ji.include({
    getRenderer: function(t) {
      var i = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer;
      return i || (i = this._renderer = this._createRenderer()), this.hasLayer(i) || this.addLayer(i), i
    },
    _getPaneRenderer: function(t) {
      if ("overlayPane" === t || void 0 === t) return !1;
      var i = this._paneRenderers[t];
      return void 0 === i && (i = this._createRenderer({
        pane: t
      }), this._paneRenderers[t] = i), i
    },
    _createRenderer: function(t) {
      return this.options.preferCanvas && _n(t) || gn(t)
    }
  });
  var vn = je.extend({
    initialize: function(t, i) {
      je.prototype.initialize.call(this, this._boundsToLatLngs(t), i)
    },
    setBounds: function(t) {
      return this.setLatLngs(this._boundsToLatLngs(t))
    },
    _boundsToLatLngs: function(t) {
      return [(t = D(t)).getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
    }
  });
  fn.create = mn, fn.pointsToPath = Q, We.geometryToLayer = He, We.coordsToLatLng = Fe, We.coordsToLatLngs = Ue, We.latLngToCoords = Ve, We.latLngsToCoords = qe, We.getFeature = Ge, We.asFeature = Ke, Ji.mergeOptions({
    boxZoom: !0
  });
  var yn = oe.extend({
    initialize: function(t) {
      this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this)
    },
    addHooks: function() {
      Ei(this._container, "mousedown", this._onMouseDown, this)
    },
    removeHooks: function() {
      Bi(this._container, "mousedown", this._onMouseDown, this)
    },
    moved: function() {
      return this._moved
    },
    _destroy: function() {
      ui(this._pane), delete this._pane
    },
    _resetState: function() {
      this._resetStateTimeout = 0, this._moved = !1
    },
    _clearDeferredResetState: function() {
      0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0)
    },
    _onMouseDown: function(t) {
      if (!t.shiftKey || 1 !== t.which && 1 !== t.button) return !1;
      this._clearDeferredResetState(), this._resetState(), $t(), Li(), this._startPoint = this._map.mouseEventToContainerPoint(t), Ei(document, {
        contextmenu: ji,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this)
    },
    _onMouseMove: function(t) {
      this._moved || (this._moved = !0, this._box = hi("div", "leaflet-zoom-box", this._container), pi(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t);
      var i = new O(this._point, this._startPoint),
        e = i.getSize();
      wi(this._box, i.min), this._box.style.width = e.x + "px", this._box.style.height = e.y + "px"
    },
    _finish: function() {
      this._moved && (ui(this._box), mi(this._container, "leaflet-crosshair")), Qt(), Ti(), Bi(document, {
        contextmenu: ji,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this)
    },
    _onMouseUp: function(t) {
      if ((1 === t.which || 1 === t.button) && (this._finish(), this._moved)) {
        this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(a(this._resetState, this), 0);
        var i = new N(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
        this._map.fitBounds(i).fire("boxzoomend", {
          boxZoomBounds: i
        })
      }
    },
    _onKeyDown: function(t) {
      27 === t.keyCode && this._finish()
    }
  });
  Ji.addInitHook("addHandler", "boxZoom", yn), Ji.mergeOptions({
    doubleClickZoom: !0
  });
  var xn = oe.extend({
    addHooks: function() {
      this._map.on("dblclick", this._onDoubleClick, this)
    },
    removeHooks: function() {
      this._map.off("dblclick", this._onDoubleClick, this)
    },
    _onDoubleClick: function(t) {
      var i = this._map,
        e = i.getZoom(),
        n = i.options.zoomDelta,
        o = t.originalEvent.shiftKey ? e - n : e + n;
      "center" === i.options.doubleClickZoom ? i.setZoom(o) : i.setZoomAround(t.containerPoint, o)
    }
  });
  Ji.addInitHook("addHandler", "doubleClickZoom", xn), Ji.mergeOptions({
    dragging: !0,
    inertia: !rt,
    inertiaDeceleration: 3400,
    inertiaMaxSpeed: 1 / 0,
    easeLinearity: .2,
    worldCopyJump: !1,
    maxBoundsViscosity: 0
  });
  var wn = oe.extend({
    addHooks: function() {
      if (!this._draggable) {
        var t = this._map;
        this._draggable = new le(t._mapPane, t._container), this._draggable.on({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this))
      }
      pi(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = []
    },
    removeHooks: function() {
      mi(this._map._container, "leaflet-grab"), mi(this._map._container, "leaflet-touch-drag"), this._draggable.disable()
    },
    moved: function() {
      return this._draggable && this._draggable._moved
    },
    moving: function() {
      return this._draggable && this._draggable._moving
    },
    _onDragStart: function() {
      var t = this._map;
      if (t._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var i = D(this._map.options.maxBounds);
        this._offsetLimit = R(this._map.latLngToContainerPoint(i.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(i.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))
      } else this._offsetLimit = null;
      t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = [])
    },
    _onDrag: function(t) {
      if (this._map.options.inertia) {
        var i = this._lastTime = +new Date,
          e = this._lastPos = this._draggable._absPos || this._draggable._newPos;
        this._positions.push(e), this._times.push(i), this._prunePositions(i)
      }
      this._map.fire("move", t).fire("drag", t)
    },
    _prunePositions: function(t) {
      for (; 1 < this._positions.length && 50 < t - this._times[0];) this._positions.shift(), this._times.shift()
    },
    _onZoomEnd: function() {
      var t = this._map.getSize().divideBy(2),
        i = this._map.latLngToLayerPoint([0, 0]);
      this._initialWorldOffset = i.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x
    },
    _viscousLimit: function(t, i) {
      return t - (t - i) * this._viscosity
    },
    _onPreDragLimit: function() {
      if (this._viscosity && this._offsetLimit) {
        var t = this._draggable._newPos.subtract(this._draggable._startPos),
          i = this._offsetLimit;
        t.x < i.min.x && (t.x = this._viscousLimit(t.x, i.min.x)), t.y < i.min.y && (t.y = this._viscousLimit(t.y, i.min.y)), t.x > i.max.x && (t.x = this._viscousLimit(t.x, i.max.x)), t.y > i.max.y && (t.y = this._viscousLimit(t.y, i.max.y)), this._draggable._newPos = this._draggable._startPos.add(t)
      }
    },
    _onPreDragWrap: function() {
      var t = this._worldWidth,
        i = Math.round(t / 2),
        e = this._initialWorldOffset,
        n = this._draggable._newPos.x,
        o = (n - i + e) % t + i - e,
        s = (n + i + e) % t - i - e,
        r = Math.abs(o + e) < Math.abs(s + e) ? o : s;
      this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = r
    },
    _onDragEnd: function(t) {
      var i = this._map,
        e = i.options,
        n = !e.inertia || this._times.length < 2;
      if (i.fire("dragend", t), n) i.fire("moveend");
      else {
        this._prunePositions(+new Date);
        var o = this._lastPos.subtract(this._positions[0]),
          s = (this._lastTime - this._times[0]) / 1e3,
          r = e.easeLinearity,
          a = o.multiplyBy(r / s),
          h = a.distanceTo([0, 0]),
          u = Math.min(e.inertiaMaxSpeed, h),
          l = a.multiplyBy(u / h),
          c = u / (e.inertiaDeceleration * r),
          _ = l.multiplyBy(-c / 2).round();
        _.x || _.y ? (_ = i._limitOffset(_, i.options.maxBounds), M(function() {
          i.panBy(_, {
            duration: c,
            easeLinearity: r,
            noMoveStart: !0,
            animate: !0
          })
        })) : i.fire("moveend")
      }
    }
  });
  Ji.addInitHook("addHandler", "dragging", wn), Ji.mergeOptions({
    keyboard: !0,
    keyboardPanDelta: 80
  });
  var Pn = oe.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 54, 173]
    },
    initialize: function(t) {
      this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta)
    },
    addHooks: function() {
      var t = this._map._container;
      t.tabIndex <= 0 && (t.tabIndex = "0"), Ei(t, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this), this._map.on({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this)
    },
    removeHooks: function() {
      this._removeHooks(), Bi(this._map._container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this), this._map.off({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this)
    },
    _onMouseDown: function() {
      if (!this._focused) {
        var t = document.body,
          i = document.documentElement,
          e = t.scrollTop || i.scrollTop,
          n = t.scrollLeft || i.scrollLeft;
        this._map._container.focus(), window.scrollTo(n, e)
      }
    },
    _onFocus: function() {
      this._focused = !0, this._map.fire("focus")
    },
    _onBlur: function() {
      this._focused = !1, this._map.fire("blur")
    },
    _setPanDelta: function(t) {
      var i, e, n = this._panKeys = {},
        o = this.keyCodes;
      for (i = 0, e = o.left.length; i < e; i++) n[o.left[i]] = [-1 * t, 0];
      for (i = 0, e = o.right.length; i < e; i++) n[o.right[i]] = [t, 0];
      for (i = 0, e = o.down.length; i < e; i++) n[o.down[i]] = [0, t];
      for (i = 0, e = o.up.length; i < e; i++) n[o.up[i]] = [0, -1 * t]
    },
    _setZoomDelta: function(t) {
      var i, e, n = this._zoomKeys = {},
        o = this.keyCodes;
      for (i = 0, e = o.zoomIn.length; i < e; i++) n[o.zoomIn[i]] = t;
      for (i = 0, e = o.zoomOut.length; i < e; i++) n[o.zoomOut[i]] = -t
    },
    _addHooks: function() {
      Ei(document, "keydown", this._onKeyDown, this)
    },
    _removeHooks: function() {
      Bi(document, "keydown", this._onKeyDown, this)
    },
    _onKeyDown: function(t) {
      if (!(t.altKey || t.ctrlKey || t.metaKey)) {
        var i, e = t.keyCode,
          n = this._map;
        if (e in this._panKeys) n._panAnim && n._panAnim._inProgress || (i = this._panKeys[e], t.shiftKey && (i = I(i).multiplyBy(3)), n.panBy(i), n.options.maxBounds && n.panInsideBounds(n.options.maxBounds));
        else if (e in this._zoomKeys) n.setZoom(n.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[e]);
        else {
          if (27 !== e || !n._popup || !n._popup.options.closeOnEscapeKey) return;
          n.closePopup()
        }
        ji(t)
      }
    }
  });
  Ji.addInitHook("addHandler", "keyboard", Pn), Ji.mergeOptions({
    scrollWheelZoom: !0,
    wheelDebounceTime: 40,
    wheelPxPerZoomLevel: 60
  });
  var bn = oe.extend({
    addHooks: function() {
      Ei(this._map._container, "mousewheel", this._onWheelScroll, this), this._delta = 0
    },
    removeHooks: function() {
      Bi(this._map._container, "mousewheel", this._onWheelScroll, this)
    },
    _onWheelScroll: function(t) {
      var i = Fi(t),
        e = this._map.options.wheelDebounceTime;
      this._delta += i, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date);
      var n = Math.max(e - (+new Date - this._startTime), 0);
      clearTimeout(this._timer), this._timer = setTimeout(a(this._performZoom, this), n), ji(t)
    },
    _performZoom: function() {
      var t = this._map,
        i = t.getZoom(),
        e = this._map.options.zoomSnap || 0;
      t._stop();
      var n = this._delta / (4 * this._map.options.wheelPxPerZoomLevel),
        o = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2,
        s = e ? Math.ceil(o / e) * e : o,
        r = t._limitZoom(i + (0 < this._delta ? s : -s)) - i;
      this._delta = 0, this._startTime = null, r && ("center" === t.options.scrollWheelZoom ? t.setZoom(i + r) : t.setZoomAround(this._lastMousePos, i + r))
    }
  });
  Ji.addInitHook("addHandler", "scrollWheelZoom", bn), Ji.mergeOptions({
    tap: !0,
    tapTolerance: 15
  });
  var Ln = oe.extend({
    addHooks: function() {
      Ei(this._map._container, "touchstart", this._onDown, this)
    },
    removeHooks: function() {
      Bi(this._map._container, "touchstart", this._onDown, this)
    },
    _onDown: function(t) {
      if (t.touches) {
        if (Di(t), this._fireClick = !0, 1 < t.touches.length) return this._fireClick = !1, void clearTimeout(this._holdTimeout);
        var i = t.touches[0],
          e = i.target;
        this._startPos = this._newPos = new B(i.clientX, i.clientY), e.tagName && "a" === e.tagName.toLowerCase() && pi(e, "leaflet-active"), this._holdTimeout = setTimeout(a(function() {
          this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", i))
        }, this), 1e3), this._simulateEvent("mousedown", i), Ei(document, {
          touchmove: this._onMove,
          touchend: this._onUp
        }, this)
      }
    },
    _onUp: function(t) {
      if (clearTimeout(this._holdTimeout), Bi(document, {
          touchmove: this._onMove,
          touchend: this._onUp
        }, this), this._fireClick && t && t.changedTouches) {
        var i = t.changedTouches[0],
          e = i.target;
        e && e.tagName && "a" === e.tagName.toLowerCase() && mi(e, "leaflet-active"), this._simulateEvent("mouseup", i), this._isTapValid() && this._simulateEvent("click", i)
      }
    },
    _isTapValid: function() {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
    },
    _onMove: function(t) {
      var i = t.touches[0];
      this._newPos = new B(i.clientX, i.clientY), this._simulateEvent("mousemove", i)
    },
    _simulateEvent: function(t, i) {
      var e = document.createEvent("MouseEvents");
      e._simulated = !0, i.target._simulatedClick = !0, e.initMouseEvent(t, !0, !0, window, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), i.target.dispatchEvent(e)
    }
  });
  Tt && !Lt && Ji.addInitHook("addHandler", "tap", Ln), Ji.mergeOptions({
    touchZoom: Tt && !rt,
    bounceAtZoomLimits: !0
  });
  var Tn = oe.extend({
    addHooks: function() {
      pi(this._map._container, "leaflet-touch-zoom"), Ei(this._map._container, "touchstart", this._onTouchStart, this)
    },
    removeHooks: function() {
      mi(this._map._container, "leaflet-touch-zoom"), Bi(this._map._container, "touchstart", this._onTouchStart, this)
    },
    _onTouchStart: function(t) {
      var i = this._map;
      if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {
        var e = i.mouseEventToContainerPoint(t.touches[0]),
          n = i.mouseEventToContainerPoint(t.touches[1]);
        this._centerPoint = i.getSize()._divideBy(2), this._startLatLng = i.containerPointToLatLng(this._centerPoint), "center" !== i.options.touchZoom && (this._pinchStartLatLng = i.containerPointToLatLng(e.add(n)._divideBy(2))), this._startDist = e.distanceTo(n), this._startZoom = i.getZoom(), this._moved = !1, this._zooming = !0, i._stop(), Ei(document, "touchmove", this._onTouchMove, this), Ei(document, "touchend", this._onTouchEnd, this), Di(t)
      }
    },
    _onTouchMove: function(t) {
      if (t.touches && 2 === t.touches.length && this._zooming) {
        var i = this._map,
          e = i.mouseEventToContainerPoint(t.touches[0]),
          n = i.mouseEventToContainerPoint(t.touches[1]),
          o = e.distanceTo(n) / this._startDist;
        if (this._zoom = i.getScaleZoom(o, this._startZoom), !i.options.bounceAtZoomLimits && (this._zoom < i.getMinZoom() && o < 1 || this._zoom > i.getMaxZoom() && 1 < o) && (this._zoom = i._limitZoom(this._zoom)), "center" === i.options.touchZoom) {
          if (this._center = this._startLatLng, 1 == o) return
        } else {
          var s = e._add(n)._divideBy(2)._subtract(this._centerPoint);
          if (1 == o && 0 === s.x && 0 === s.y) return;
          this._center = i.unproject(i.project(this._pinchStartLatLng, this._zoom).subtract(s), this._zoom)
        }
        this._moved || (i._moveStart(!0, !1), this._moved = !0), C(this._animRequest);
        var r = a(i._move, i, this._center, this._zoom, {
          pinch: !0,
          round: !1
        });
        this._animRequest = M(r, this, !0), Di(t)
      }
    },
    _onTouchEnd: function() {
      this._moved && this._zooming ? (this._zooming = !1, C(this._animRequest), Bi(document, "touchmove", this._onTouchMove), Bi(document, "touchend", this._onTouchEnd), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1
    }
  });
  Ji.addInitHook("addHandler", "touchZoom", Tn), Ji.BoxZoom = yn, Ji.DoubleClickZoom = xn, Ji.Drag = wn, Ji.Keyboard = Pn, Ji.ScrollWheelZoom = bn, Ji.Tap = Ln, Ji.TouchZoom = Tn, Object.freeze = i, t.version = "1.5.1+build.2e3e0ffb", t.Control = Qi, t.control = $i, t.Browser = Bt, t.Evented = k, t.Mixin = re, t.Util = S, t.Class = Z, t.Handler = oe, t.extend = h, t.bind = a, t.stamp = u, t.setOptions = p, t.DomEvent = Yi, t.DomUtil = Zi, t.PosAnimation = Xi, t.Draggable = le, t.LineUtil = ye, t.PolyUtil = Pe, t.Point = B, t.point = I, t.Bounds = O, t.bounds = R, t.Transformation = G, t.transformation = K, t.Projection = Te, t.LatLng = j, t.latLng = W, t.LatLngBounds = N, t.latLngBounds = D, t.CRS = F, t.GeoJSON = We, t.geoJSON = Xe, t.geoJson = Je, t.Layer = Se, t.LayerGroup = Ze, t.layerGroup = function(t, i) {
    return new Ze(t, i)
  }, t.FeatureGroup = Ee, t.featureGroup = function(t) {
    return new Ee(t)
  }, t.ImageOverlay = $e, t.imageOverlay = function(t, i, e) {
    return new $e(t, i, e)
  }, t.VideoOverlay = Qe, t.videoOverlay = function(t, i, e) {
    return new Qe(t, i, e)
  }, t.SVGOverlay = tn, t.svgOverlay = function(t, i, e) {
    return new tn(t, i, e)
  }, t.DivOverlay = en, t.Popup = nn, t.popup = function(t, i) {
    return new nn(t, i)
  }, t.Tooltip = on, t.tooltip = function(t, i) {
    return new on(t, i)
  }, t.Icon = ke, t.icon = function(t) {
    return new ke(t)
  }, t.DivIcon = sn, t.divIcon = function(t) {
    return new sn(t)
  }, t.Marker = Ie, t.marker = function(t, i) {
    return new Ie(t, i)
  }, t.TileLayer = an, t.tileLayer = hn, t.GridLayer = rn, t.gridLayer = function(t) {
    return new rn(t)
  }, t.SVG = fn, t.svg = gn, t.Renderer = ln, t.Canvas = cn, t.canvas = _n, t.Path = Oe, t.CircleMarker = Re, t.circleMarker = function(t, i) {
    return new Re(t, i)
  }, t.Circle = Ne, t.circle = function(t, i, e) {
    return new Ne(t, i, e)
  }, t.Polyline = De, t.polyline = function(t, i) {
    return new De(t, i)
  }, t.Polygon = je, t.polygon = function(t, i) {
    return new je(t, i)
  }, t.Rectangle = vn, t.rectangle = function(t, i) {
    return new vn(t, i)
  }, t.Map = Ji, t.map = function(t, i) {
    return new Ji(t, i)
  };
  var zn = window.L;
  t.noConflict = function() {
    return window.L = zn, this
  }, window.L = t
});


! function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e.Leaflet = e.Leaflet || {}, e.Leaflet.markercluster = e.Leaflet.markercluster || {}))
}(this, function(e) {
  "use strict";
  var t = L.MarkerClusterGroup = L.FeatureGroup.extend({
    options: {
      maxClusterRadius: 80,
      iconCreateFunction: null,
      clusterPane: L.Marker.prototype.options.pane,
      spiderfyOnMaxZoom: !0,
      showCoverageOnHover: !0,
      zoomToBoundsOnClick: !0,
      singleMarkerMode: !1,
      disableClusteringAtZoom: null,
      removeOutsideVisibleBounds: !0,
      animate: !0,
      animateAddingMarkers: !1,
      spiderfyDistanceMultiplier: 1,
      spiderLegPolylineOptions: {
        weight: 1.5,
        color: "#222",
        opacity: .5
      },
      chunkedLoading: !1,
      chunkInterval: 200,
      chunkDelay: 50,
      chunkProgress: null,
      polygonOptions: {}
    },
    initialize: function(e) {
      L.Util.setOptions(this, e), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {
        dragstart: this._childMarkerDragStart,
        move: this._childMarkerMoved,
        dragend: this._childMarkerDragEnd
      };
      var t = L.DomUtil.TRANSITION && this.options.animate;
      L.extend(this, t ? this._withAnimation : this._noAnimation), this._markerCluster = t ? L.MarkerCluster : L.MarkerClusterNonAnimated
    },
    addLayer: function(e) {
      if (e instanceof L.LayerGroup) return this.addLayers([e]);
      if (!e.getLatLng) return this._nonPointGroup.addLayer(e), this.fire("layeradd", {
        layer: e
      }), this;
      if (!this._map) return this._needsClustering.push(e), this.fire("layeradd", {
        layer: e
      }), this;
      if (this.hasLayer(e)) return this;
      this._unspiderfy && this._unspiderfy(), this._addLayer(e, this._maxZoom), this.fire("layeradd", {
        layer: e
      }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();
      var t = e,
        i = this._zoom;
      if (e.__parent)
        for (; t.__parent._zoom >= i;) t = t.__parent;
      return this._currentShownBounds.contains(t.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(e, t) : this._animationAddLayerNonAnimated(e, t)), this
    },
    removeLayer: function(e) {
      return e instanceof L.LayerGroup ? this.removeLayers([e]) : e.getLatLng ? this._map ? e.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(e)), this._removeLayer(e, !0), this.fire("layerremove", {
        layer: e
      }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), e.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(e) && (this._featureGroup.removeLayer(e), e.clusterShow && e.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, e) && this.hasLayer(e) && this._needsRemoving.push({
        layer: e,
        latlng: e._latlng
      }), this.fire("layerremove", {
        layer: e
      }), this) : (this._nonPointGroup.removeLayer(e), this.fire("layerremove", {
        layer: e
      }), this)
    },
    addLayers: function(e, t) {
      if (!L.Util.isArray(e)) return this.addLayer(e);
      var i, n = this._featureGroup,
        r = this._nonPointGroup,
        s = this.options.chunkedLoading,
        o = this.options.chunkInterval,
        a = this.options.chunkProgress,
        h = e.length,
        l = 0,
        u = !0;
      if (this._map) {
        var _ = (new Date).getTime(),
          d = L.bind(function() {
            for (var c = (new Date).getTime(); h > l; l++) {
              if (s && 0 === l % 200) {
                var p = (new Date).getTime() - c;
                if (p > o) break
              }
              if (i = e[l], i instanceof L.LayerGroup) u && (e = e.slice(), u = !1), this._extractNonGroupLayers(i, e), h = e.length;
              else if (i.getLatLng) {
                if (!this.hasLayer(i) && (this._addLayer(i, this._maxZoom), t || this.fire("layeradd", {
                    layer: i
                  }), i.__parent && 2 === i.__parent.getChildCount())) {
                  var f = i.__parent.getAllChildMarkers(),
                    m = f[0] === i ? f[1] : f[0];
                  n.removeLayer(m)
                }
              } else r.addLayer(i), t || this.fire("layeradd", {
                layer: i
              })
            }
            a && a(l, h, (new Date).getTime() - _), l === h ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(d, this.options.chunkDelay)
          }, this);
        d()
      } else
        for (var c = this._needsClustering; h > l; l++) i = e[l], i instanceof L.LayerGroup ? (u && (e = e.slice(), u = !1), this._extractNonGroupLayers(i, e), h = e.length) : i.getLatLng ? this.hasLayer(i) || c.push(i) : r.addLayer(i);
      return this
    },
    removeLayers: function(e) {
      var t, i, n = e.length,
        r = this._featureGroup,
        s = this._nonPointGroup,
        o = !0;
      if (!this._map) {
        for (t = 0; n > t; t++) i = e[t], i instanceof L.LayerGroup ? (o && (e = e.slice(), o = !1), this._extractNonGroupLayers(i, e), n = e.length) : (this._arraySplice(this._needsClustering, i), s.removeLayer(i), this.hasLayer(i) && this._needsRemoving.push({
          layer: i,
          latlng: i._latlng
        }), this.fire("layerremove", {
          layer: i
        }));
        return this
      }
      if (this._unspiderfy) {
        this._unspiderfy();
        var a = e.slice(),
          h = n;
        for (t = 0; h > t; t++) i = a[t], i instanceof L.LayerGroup ? (this._extractNonGroupLayers(i, a), h = a.length) : this._unspiderfyLayer(i)
      }
      for (t = 0; n > t; t++) i = e[t], i instanceof L.LayerGroup ? (o && (e = e.slice(), o = !1), this._extractNonGroupLayers(i, e), n = e.length) : i.__parent ? (this._removeLayer(i, !0, !0), this.fire("layerremove", {
        layer: i
      }), r.hasLayer(i) && (r.removeLayer(i), i.clusterShow && i.clusterShow())) : (s.removeLayer(i), this.fire("layerremove", {
        layer: i
      }));
      return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this
    },
    clearLayers: function() {
      return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function(e) {
        e.off(this._childMarkerEventHandlers, this), delete e.__parent
      }, this), this._map && this._generateInitialClusters(), this
    },
    getBounds: function() {
      var e = new L.LatLngBounds;
      this._topClusterLevel && e.extend(this._topClusterLevel._bounds);
      for (var t = this._needsClustering.length - 1; t >= 0; t--) e.extend(this._needsClustering[t].getLatLng());
      return e.extend(this._nonPointGroup.getBounds()), e
    },
    eachLayer: function(e, t) {
      var i, n, r, s = this._needsClustering.slice(),
        o = this._needsRemoving;
      for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(s), n = s.length - 1; n >= 0; n--) {
        for (i = !0, r = o.length - 1; r >= 0; r--)
          if (o[r].layer === s[n]) {
            i = !1;
            break
          }
        i && e.call(t, s[n])
      }
      this._nonPointGroup.eachLayer(e, t)
    },
    getLayers: function() {
      var e = [];
      return this.eachLayer(function(t) {
        e.push(t)
      }), e
    },
    getLayer: function(e) {
      var t = null;
      return e = parseInt(e, 10), this.eachLayer(function(i) {
        L.stamp(i) === e && (t = i)
      }), t
    },
    hasLayer: function(e) {
      if (!e) return !1;
      var t, i = this._needsClustering;
      for (t = i.length - 1; t >= 0; t--)
        if (i[t] === e) return !0;
      for (i = this._needsRemoving, t = i.length - 1; t >= 0; t--)
        if (i[t].layer === e) return !1;
      return !(!e.__parent || e.__parent._group !== this) || this._nonPointGroup.hasLayer(e)
    },
    zoomToShowLayer: function(e, t) {
      "function" != typeof t && (t = function() {});
      var i = function() {
        !e._icon && !e.__parent._icon || this._inZoomAnimation || (this._map.off("moveend", i, this), this.off("animationend", i, this), e._icon ? t() : e.__parent._icon && (this.once("spiderfied", t, this), e.__parent.spiderfy()))
      };
      e._icon && this._map.getBounds().contains(e.getLatLng()) ? t() : e.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", i, this), this._map.panTo(e.getLatLng())) : (this._map.on("moveend", i, this), this.on("animationend", i, this), e.__parent.zoomToBounds())
    },
    onAdd: function(e) {
      this._map = e;
      var t, i, n;
      if (!isFinite(this._map.getMaxZoom())) throw "Map has no maxZoom specified";
      for (this._featureGroup.addTo(e), this._nonPointGroup.addTo(e), this._gridClusters || this._generateInitialClusters(), this._maxLat = e.options.crs.projection.MAX_LATITUDE, t = 0, i = this._needsRemoving.length; i > t; t++) n = this._needsRemoving[t], n.newlatlng = n.layer._latlng, n.layer._latlng = n.latlng;
      for (t = 0, i = this._needsRemoving.length; i > t; t++) n = this._needsRemoving[t], this._removeLayer(n.layer, !0), n.layer._latlng = n.newlatlng;
      this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), i = this._needsClustering, this._needsClustering = [], this.addLayers(i, !0)
    },
    onRemove: function(e) {
      e.off("zoomend", this._zoomEnd, this), e.off("moveend", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null
    },
    getVisibleParent: function(e) {
      for (var t = e; t && !t._icon;) t = t.__parent;
      return t || null
    },
    _arraySplice: function(e, t) {
      for (var i = e.length - 1; i >= 0; i--)
        if (e[i] === t) return e.splice(i, 1), !0
    },
    _removeFromGridUnclustered: function(e, t) {
      for (var i = this._map, n = this._gridUnclustered, r = Math.floor(this._map.getMinZoom()); t >= r && n[t].removeObject(e, i.project(e.getLatLng(), t)); t--);
    },
    _childMarkerDragStart: function(e) {
      e.target.__dragStart = e.target._latlng
    },
    _childMarkerMoved: function(e) {
      if (!this._ignoreMove && !e.target.__dragStart) {
        var t = e.target._popup && e.target._popup.isOpen();
        this._moveChild(e.target, e.oldLatLng, e.latlng), t && e.target.openPopup()
      }
    },
    _moveChild: function(e, t, i) {
      e._latlng = t, this.removeLayer(e), e._latlng = i, this.addLayer(e)
    },
    _childMarkerDragEnd: function(e) {
      e.target.__dragStart && this._moveChild(e.target, e.target.__dragStart, e.target._latlng), delete e.target.__dragStart
    },
    _removeLayer: function(e, t, i) {
      var n = this._gridClusters,
        r = this._gridUnclustered,
        s = this._featureGroup,
        o = this._map,
        a = Math.floor(this._map.getMinZoom());
      t && this._removeFromGridUnclustered(e, this._maxZoom);
      var h, l = e.__parent,
        u = l._markers;
      for (this._arraySplice(u, e); l && (l._childCount--, l._boundsNeedUpdate = !0, !(l._zoom < a));) t && l._childCount <= 1 ? (h = l._markers[0] === e ? l._markers[1] : l._markers[0], n[l._zoom].removeObject(l, o.project(l._cLatLng, l._zoom)), r[l._zoom].addObject(h, o.project(h.getLatLng(), l._zoom)), this._arraySplice(l.__parent._childClusters, l), l.__parent._markers.push(h), h.__parent = l.__parent, l._icon && (s.removeLayer(l), i || s.addLayer(h))) : l._iconNeedsUpdate = !0, l = l.__parent;
      delete e.__parent
    },
    _isOrIsParent: function(e, t) {
      for (; t;) {
        if (e === t) return !0;
        t = t.parentNode
      }
      return !1
    },
    fire: function(e, t, i) {
      if (t && t.layer instanceof L.MarkerCluster) {
        if (t.originalEvent && this._isOrIsParent(t.layer._icon, t.originalEvent.relatedTarget)) return;
        e = "cluster" + e
      }
      L.FeatureGroup.prototype.fire.call(this, e, t, i)
    },
    listens: function(e, t) {
      return L.FeatureGroup.prototype.listens.call(this, e, t) || L.FeatureGroup.prototype.listens.call(this, "cluster" + e, t)
    },
    _defaultIconCreateFunction: function(e) {
      var t = e.getChildCount(),
        i = " marker-cluster-";
      return i += 10 > t ? "small" : 100 > t ? "medium" : "large", new L.DivIcon({
        html: "<div><span>" + t + "</span></div>",
        className: "marker-cluster" + i,
        iconSize: new L.Point(40, 40)
      })
    },
    _bindEvents: function() {
      var e = this._map,
        t = this.options.spiderfyOnMaxZoom,
        i = this.options.showCoverageOnHover,
        n = this.options.zoomToBoundsOnClick;
      (t || n) && this.on("clusterclick", this._zoomOrSpiderfy, this), i && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), e.on("zoomend", this._hideCoverage, this))
    },
    _zoomOrSpiderfy: function(e) {
      for (var t = e.layer, i = t; 1 === i._childClusters.length;) i = i._childClusters[0];
      i._zoom === this._maxZoom && i._childCount === t._childCount && this.options.spiderfyOnMaxZoom ? t.spiderfy() : this.options.zoomToBoundsOnClick && t.zoomToBounds(), e.originalEvent && 13 === e.originalEvent.keyCode && this._map._container.focus()
    },
    _showCoverage: function(e) {
      var t = this._map;
      this._inZoomAnimation || (this._shownPolygon && t.removeLayer(this._shownPolygon), e.layer.getChildCount() > 2 && e.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions), t.addLayer(this._shownPolygon)))
    },
    _hideCoverage: function() {
      this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null)
    },
    _unbindEvents: function() {
      var e = this.options.spiderfyOnMaxZoom,
        t = this.options.showCoverageOnHover,
        i = this.options.zoomToBoundsOnClick,
        n = this._map;
      (e || i) && this.off("clusterclick", this._zoomOrSpiderfy, this), t && (this.off("clustermouseover", this._showCoverage, this), this.off("clustermouseout", this._hideCoverage, this), n.off("zoomend", this._hideCoverage, this))
    },
    _zoomEnd: function() {
      this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds())
    },
    _moveEnd: function() {
      if (!this._inZoomAnimation) {
        var e = this._getExpandedVisibleBounds();
        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, e), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), e), this._currentShownBounds = e
      }
    },
    _generateInitialClusters: function() {
      var e = Math.ceil(this._map.getMaxZoom()),
        t = Math.floor(this._map.getMinZoom()),
        i = this.options.maxClusterRadius,
        n = i;
      "function" != typeof i && (n = function() {
        return i
      }), null !== this.options.disableClusteringAtZoom && (e = this.options.disableClusteringAtZoom - 1), this._maxZoom = e, this._gridClusters = {}, this._gridUnclustered = {};
      for (var r = e; r >= t; r--) this._gridClusters[r] = new L.DistanceGrid(n(r)), this._gridUnclustered[r] = new L.DistanceGrid(n(r));
      this._topClusterLevel = new this._markerCluster(this, t - 1)
    },
    _addLayer: function(e, t) {
      var i, n, r = this._gridClusters,
        s = this._gridUnclustered,
        o = Math.floor(this._map.getMinZoom());
      for (this.options.singleMarkerMode && this._overrideMarkerIcon(e), e.on(this._childMarkerEventHandlers, this); t >= o; t--) {
        i = this._map.project(e.getLatLng(), t);
        var a = r[t].getNearObject(i);
        if (a) return a._addChild(e), e.__parent = a, void 0;
        if (a = s[t].getNearObject(i)) {
          var h = a.__parent;
          h && this._removeLayer(a, !1);
          var l = new this._markerCluster(this, t, a, e);
          r[t].addObject(l, this._map.project(l._cLatLng, t)), a.__parent = l, e.__parent = l;
          var u = l;
          for (n = t - 1; n > h._zoom; n--) u = new this._markerCluster(this, n, u), r[n].addObject(u, this._map.project(a.getLatLng(), n));
          return h._addChild(u), this._removeFromGridUnclustered(a, t), void 0
        }
        s[t].addObject(e, i)
      }
      this._topClusterLevel._addChild(e), e.__parent = this._topClusterLevel
    },
    _refreshClustersIcons: function() {
      this._featureGroup.eachLayer(function(e) {
        e instanceof L.MarkerCluster && e._iconNeedsUpdate && e._updateIcon()
      })
    },
    _enqueue: function(e) {
      this._queue.push(e), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300))
    },
    _processQueue: function() {
      for (var e = 0; e < this._queue.length; e++) this._queue[e].call(this);
      this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null
    },
    _mergeSplitClusters: function() {
      var e = Math.round(this._map._zoom);
      this._processQueue(), this._zoom < e && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, e)) : this._zoom > e ? (this._animationStart(), this._animationZoomOut(this._zoom, e)) : this._moveEnd()
    },
    _getExpandedVisibleBounds: function() {
      return this.options.removeOutsideVisibleBounds ? L.Browser.mobile ? this._checkBoundsMaxLat(this._map.getBounds()) : this._checkBoundsMaxLat(this._map.getBounds().pad(1)) : this._mapBoundsInfinite
    },
    _checkBoundsMaxLat: function(e) {
      var t = this._maxLat;
      return void 0 !== t && (e.getNorth() >= t && (e._northEast.lat = 1 / 0), e.getSouth() <= -t && (e._southWest.lat = -1 / 0)), e
    },
    _animationAddLayerNonAnimated: function(e, t) {
      if (t === e) this._featureGroup.addLayer(e);
      else if (2 === t._childCount) {
        t._addToMap();
        var i = t.getAllChildMarkers();
        this._featureGroup.removeLayer(i[0]), this._featureGroup.removeLayer(i[1])
      } else t._updateIcon()
    },
    _extractNonGroupLayers: function(e, t) {
      var i, n = e.getLayers(),
        r = 0;
      for (t = t || []; r < n.length; r++) i = n[r], i instanceof L.LayerGroup ? this._extractNonGroupLayers(i, t) : t.push(i);
      return t
    },
    _overrideMarkerIcon: function(e) {
      var t = e.options.icon = this.options.iconCreateFunction({
        getChildCount: function() {
          return 1
        },
        getAllChildMarkers: function() {
          return [e]
        }
      });
      return t
    }
  });
  L.MarkerClusterGroup.include({
    _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))
  }), L.MarkerClusterGroup.include({
    _noAnimation: {
      _animationStart: function() {},
      _animationZoomIn: function(e, t) {
        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), e), this._topClusterLevel._recursivelyAddChildrenToMap(null, t, this._getExpandedVisibleBounds()), this.fire("animationend")
      },
      _animationZoomOut: function(e, t) {
        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), e), this._topClusterLevel._recursivelyAddChildrenToMap(null, t, this._getExpandedVisibleBounds()), this.fire("animationend")
      },
      _animationAddLayer: function(e, t) {
        this._animationAddLayerNonAnimated(e, t)
      }
    },
    _withAnimation: {
      _animationStart: function() {
        this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++
      },
      _animationZoomIn: function(e, t) {
        var i, n = this._getExpandedVisibleBounds(),
          r = this._featureGroup,
          s = Math.floor(this._map.getMinZoom());
        this._ignoreMove = !0, this._topClusterLevel._recursively(n, e, s, function(s) {
          var o, a = s._latlng,
            h = s._markers;
          for (n.contains(a) || (a = null), s._isSingleParent() && e + 1 === t ? (r.removeLayer(s), s._recursivelyAddChildrenToMap(null, t, n)) : (s.clusterHide(), s._recursivelyAddChildrenToMap(a, t, n)), i = h.length - 1; i >= 0; i--) o = h[i], n.contains(o._latlng) || r.removeLayer(o)
        }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(n, t), r.eachLayer(function(e) {
          e instanceof L.MarkerCluster || !e._icon || e.clusterShow()
        }), this._topClusterLevel._recursively(n, e, t, function(e) {
          e._recursivelyRestoreChildPositions(t)
        }), this._ignoreMove = !1, this._enqueue(function() {
          this._topClusterLevel._recursively(n, e, s, function(e) {
            r.removeLayer(e), e.clusterShow()
          }), this._animationEnd()
        })
      },
      _animationZoomOut: function(e, t) {
        this._animationZoomOutSingle(this._topClusterLevel, e - 1, t), this._topClusterLevel._recursivelyAddChildrenToMap(null, t, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), e, this._getExpandedVisibleBounds())
      },
      _animationAddLayer: function(e, t) {
        var i = this,
          n = this._featureGroup;
        n.addLayer(e), t !== e && (t._childCount > 2 ? (t._updateIcon(), this._forceLayout(), this._animationStart(), e._setPos(this._map.latLngToLayerPoint(t.getLatLng())), e.clusterHide(), this._enqueue(function() {
          n.removeLayer(e), e.clusterShow(), i._animationEnd()
        })) : (this._forceLayout(), i._animationStart(), i._animationZoomOutSingle(t, this._map.getMaxZoom(), this._zoom)))
      }
    },
    _animationZoomOutSingle: function(e, t, i) {
      var n = this._getExpandedVisibleBounds(),
        r = Math.floor(this._map.getMinZoom());
      e._recursivelyAnimateChildrenInAndAddSelfToMap(n, r, t + 1, i);
      var s = this;
      this._forceLayout(), e._recursivelyBecomeVisible(n, i), this._enqueue(function() {
        if (1 === e._childCount) {
          var o = e._markers[0];
          this._ignoreMove = !0, o.setLatLng(o.getLatLng()), this._ignoreMove = !1, o.clusterShow && o.clusterShow()
        } else e._recursively(n, i, r, function(e) {
          e._recursivelyRemoveChildrenFromMap(n, r, t + 1)
        });
        s._animationEnd()
      })
    },
    _animationEnd: function() {
      this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), this._inZoomAnimation--, this.fire("animationend")
    },
    _forceLayout: function() {
      L.Util.falseFn(document.body.offsetWidth)
    }
  }), L.markerClusterGroup = function(e) {
    return new L.MarkerClusterGroup(e)
  };
  var i = L.MarkerCluster = L.Marker.extend({
    options: L.Icon.prototype.options,
    initialize: function(e, t, i, n) {
      L.Marker.prototype.initialize.call(this, i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0), {
        icon: this,
        pane: e.options.clusterPane
      }), this._group = e, this._zoom = t, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds, i && this._addChild(i), n && this._addChild(n)
    },
    getAllChildMarkers: function(e) {
      e = e || [];
      for (var t = this._childClusters.length - 1; t >= 0; t--) this._childClusters[t].getAllChildMarkers(e);
      for (var i = this._markers.length - 1; i >= 0; i--) e.push(this._markers[i]);
      return e
    },
    getChildCount: function() {
      return this._childCount
    },
    zoomToBounds: function(e) {
      for (var t, i = this._childClusters.slice(), n = this._group._map, r = n.getBoundsZoom(this._bounds), s = this._zoom + 1, o = n.getZoom(); i.length > 0 && r > s;) {
        s++;
        var a = [];
        for (t = 0; t < i.length; t++) a = a.concat(i[t]._childClusters);
        i = a
      }
      r > s ? this._group._map.setView(this._latlng, s) : o >= r ? this._group._map.setView(this._latlng, o + 1) : this._group._map.fitBounds(this._bounds, e)
    },
    getBounds: function() {
      var e = new L.LatLngBounds;
      return e.extend(this._bounds), e
    },
    _updateIcon: function() {
      this._iconNeedsUpdate = !0, this._icon && this.setIcon(this)
    },
    createIcon: function() {
      return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon()
    },
    createShadow: function() {
      return this._iconObj.createShadow()
    },
    _addChild: function(e, t) {
      this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(e), e instanceof L.MarkerCluster ? (t || (this._childClusters.push(e), e.__parent = this), this._childCount += e._childCount) : (t || this._markers.push(e), this._childCount++), this.__parent && this.__parent._addChild(e, !0)
    },
    _setClusterCenter: function(e) {
      this._cLatLng || (this._cLatLng = e._cLatLng || e._latlng)
    },
    _resetBounds: function() {
      var e = this._bounds;
      e._southWest && (e._southWest.lat = 1 / 0, e._southWest.lng = 1 / 0), e._northEast && (e._northEast.lat = -1 / 0, e._northEast.lng = -1 / 0)
    },
    _recalculateBounds: function() {
      var e, t, i, n, r = this._markers,
        s = this._childClusters,
        o = 0,
        a = 0,
        h = this._childCount;
      if (0 !== h) {
        for (this._resetBounds(), e = 0; e < r.length; e++) i = r[e]._latlng, this._bounds.extend(i), o += i.lat, a += i.lng;
        for (e = 0; e < s.length; e++) t = s[e], t._boundsNeedUpdate && t._recalculateBounds(), this._bounds.extend(t._bounds), i = t._wLatLng, n = t._childCount, o += i.lat * n, a += i.lng * n;
        this._latlng = this._wLatLng = new L.LatLng(o / h, a / h), this._boundsNeedUpdate = !1
      }
    },
    _addToMap: function(e) {
      e && (this._backupLatlng = this._latlng, this.setLatLng(e)), this._group._featureGroup.addLayer(this)
    },
    _recursivelyAnimateChildrenIn: function(e, t, i) {
      this._recursively(e, this._group._map.getMinZoom(), i - 1, function(e) {
        var i, n, r = e._markers;
        for (i = r.length - 1; i >= 0; i--) n = r[i], n._icon && (n._setPos(t), n.clusterHide())
      }, function(e) {
        var i, n, r = e._childClusters;
        for (i = r.length - 1; i >= 0; i--) n = r[i], n._icon && (n._setPos(t), n.clusterHide())
      })
    },
    _recursivelyAnimateChildrenInAndAddSelfToMap: function(e, t, i, n) {
      this._recursively(e, n, t, function(r) {
        r._recursivelyAnimateChildrenIn(e, r._group._map.latLngToLayerPoint(r.getLatLng()).round(), i), r._isSingleParent() && i - 1 === n ? (r.clusterShow(), r._recursivelyRemoveChildrenFromMap(e, t, i)) : r.clusterHide(), r._addToMap()
      })
    },
    _recursivelyBecomeVisible: function(e, t) {
      this._recursively(e, this._group._map.getMinZoom(), t, null, function(e) {
        e.clusterShow()
      })
    },
    _recursivelyAddChildrenToMap: function(e, t, i) {
      this._recursively(i, this._group._map.getMinZoom() - 1, t, function(n) {
        if (t !== n._zoom)
          for (var r = n._markers.length - 1; r >= 0; r--) {
            var s = n._markers[r];
            i.contains(s._latlng) && (e && (s._backupLatlng = s.getLatLng(), s.setLatLng(e), s.clusterHide && s.clusterHide()), n._group._featureGroup.addLayer(s))
          }
      }, function(t) {
        t._addToMap(e)
      })
    },
    _recursivelyRestoreChildPositions: function(e) {
      for (var t = this._markers.length - 1; t >= 0; t--) {
        var i = this._markers[t];
        i._backupLatlng && (i.setLatLng(i._backupLatlng), delete i._backupLatlng)
      }
      if (e - 1 === this._zoom)
        for (var n = this._childClusters.length - 1; n >= 0; n--) this._childClusters[n]._restorePosition();
      else
        for (var r = this._childClusters.length - 1; r >= 0; r--) this._childClusters[r]._recursivelyRestoreChildPositions(e)
    },
    _restorePosition: function() {
      this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng)
    },
    _recursivelyRemoveChildrenFromMap: function(e, t, i, n) {
      var r, s;
      this._recursively(e, t - 1, i - 1, function(e) {
        for (s = e._markers.length - 1; s >= 0; s--) r = e._markers[s], n && n.contains(r._latlng) || (e._group._featureGroup.removeLayer(r), r.clusterShow && r.clusterShow())
      }, function(e) {
        for (s = e._childClusters.length - 1; s >= 0; s--) r = e._childClusters[s], n && n.contains(r._latlng) || (e._group._featureGroup.removeLayer(r), r.clusterShow && r.clusterShow())
      })
    },
    _recursively: function(e, t, i, n, r) {
      var s, o, a = this._childClusters,
        h = this._zoom;
      if (h >= t && (n && n(this), r && h === i && r(this)), t > h || i > h)
        for (s = a.length - 1; s >= 0; s--) o = a[s], o._boundsNeedUpdate && o._recalculateBounds(), e.intersects(o._bounds) && o._recursively(e, t, i, n, r)
    },
    _isSingleParent: function() {
      return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount
    }
  });
  L.Marker.include({
      clusterHide: function() {
        var e = this.options.opacity;
        return this.setOpacity(0), this.options.opacity = e, this
      },
      clusterShow: function() {
        return this.setOpacity(this.options.opacity)
      }
    }), L.DistanceGrid = function(e) {
      this._cellSize = e, this._sqCellSize = e * e, this._grid = {}, this._objectPoint = {}
    }, L.DistanceGrid.prototype = {
      addObject: function(e, t) {
        var i = this._getCoord(t.x),
          n = this._getCoord(t.y),
          r = this._grid,
          s = r[n] = r[n] || {},
          o = s[i] = s[i] || [],
          a = L.Util.stamp(e);
        this._objectPoint[a] = t, o.push(e)
      },
      updateObject: function(e, t) {
        this.removeObject(e), this.addObject(e, t)
      },
      removeObject: function(e, t) {
        var i, n, r = this._getCoord(t.x),
          s = this._getCoord(t.y),
          o = this._grid,
          a = o[s] = o[s] || {},
          h = a[r] = a[r] || [];
        for (delete this._objectPoint[L.Util.stamp(e)], i = 0, n = h.length; n > i; i++)
          if (h[i] === e) return h.splice(i, 1), 1 === n && delete a[r], !0
      },
      eachObject: function(e, t) {
        var i, n, r, s, o, a, h, l = this._grid;
        for (i in l) {
          o = l[i];
          for (n in o)
            for (a = o[n], r = 0, s = a.length; s > r; r++) h = e.call(t, a[r]), h && (r--, s--)
        }
      },
      getNearObject: function(e) {
        var t, i, n, r, s, o, a, h, l = this._getCoord(e.x),
          u = this._getCoord(e.y),
          _ = this._objectPoint,
          d = this._sqCellSize,
          c = null;
        for (t = u - 1; u + 1 >= t; t++)
          if (r = this._grid[t])
            for (i = l - 1; l + 1 >= i; i++)
              if (s = r[i])
                for (n = 0, o = s.length; o > n; n++) a = s[n], h = this._sqDist(_[L.Util.stamp(a)], e), (d > h || d >= h && null === c) && (d = h, c = a);
        return c
      },
      _getCoord: function(e) {
        var t = Math.floor(e / this._cellSize);
        return isFinite(t) ? t : e
      },
      _sqDist: function(e, t) {
        var i = t.x - e.x,
          n = t.y - e.y;
        return i * i + n * n
      }
    },
    function() {
      L.QuickHull = {
        getDistant: function(e, t) {
          var i = t[1].lat - t[0].lat,
            n = t[0].lng - t[1].lng;
          return n * (e.lat - t[0].lat) + i * (e.lng - t[0].lng)
        },
        findMostDistantPointFromBaseLine: function(e, t) {
          var i, n, r, s = 0,
            o = null,
            a = [];
          for (i = t.length - 1; i >= 0; i--) n = t[i], r = this.getDistant(n, e), r > 0 && (a.push(n), r > s && (s = r, o = n));
          return {
            maxPoint: o,
            newPoints: a
          }
        },
        buildConvexHull: function(e, t) {
          var i = [],
            n = this.findMostDistantPointFromBaseLine(e, t);
          return n.maxPoint ? (i = i.concat(this.buildConvexHull([e[0], n.maxPoint], n.newPoints)), i = i.concat(this.buildConvexHull([n.maxPoint, e[1]], n.newPoints))) : [e[0]]
        },
        getConvexHull: function(e) {
          var t, i = !1,
            n = !1,
            r = !1,
            s = !1,
            o = null,
            a = null,
            h = null,
            l = null,
            u = null,
            _ = null;
          for (t = e.length - 1; t >= 0; t--) {
            var d = e[t];
            (i === !1 || d.lat > i) && (o = d, i = d.lat), (n === !1 || d.lat < n) && (a = d, n = d.lat), (r === !1 || d.lng > r) && (h = d, r = d.lng), (s === !1 || d.lng < s) && (l = d, s = d.lng)
          }
          n !== i ? (_ = a, u = o) : (_ = l, u = h);
          var c = [].concat(this.buildConvexHull([_, u], e), this.buildConvexHull([u, _], e));
          return c
        }
      }
    }(), L.MarkerCluster.include({
      getConvexHull: function() {
        var e, t, i = this.getAllChildMarkers(),
          n = [];
        for (t = i.length - 1; t >= 0; t--) e = i[t].getLatLng(), n.push(e);
        return L.QuickHull.getConvexHull(n)
      }
    }), L.MarkerCluster.include({
      _2PI: 2 * Math.PI,
      _circleFootSeparation: 25,
      _circleStartAngle: 0,
      _spiralFootSeparation: 28,
      _spiralLengthStart: 11,
      _spiralLengthFactor: 5,
      _circleSpiralSwitchover: 9,
      spiderfy: function() {
        if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {
          var e, t = this.getAllChildMarkers(),
            i = this._group,
            n = i._map,
            r = n.latLngToLayerPoint(this._latlng);
          this._group._unspiderfy(), this._group._spiderfied = this, t.length >= this._circleSpiralSwitchover ? e = this._generatePointsSpiral(t.length, r) : (r.y += 10, e = this._generatePointsCircle(t.length, r)), this._animationSpiderfy(t, e)
        }
      },
      unspiderfy: function(e) {
        this._group._inZoomAnimation || (this._animationUnspiderfy(e), this._group._spiderfied = null)
      },
      _generatePointsCircle: function(e, t) {
        var i, n, r = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + e),
          s = r / this._2PI,
          o = this._2PI / e,
          a = [];
        for (s = Math.max(s, 35), a.length = e, i = 0; e > i; i++) n = this._circleStartAngle + i * o, a[i] = new L.Point(t.x + s * Math.cos(n), t.y + s * Math.sin(n))._round();
        return a
      },
      _generatePointsSpiral: function(e, t) {
        var i, n = this._group.options.spiderfyDistanceMultiplier,
          r = n * this._spiralLengthStart,
          s = n * this._spiralFootSeparation,
          o = n * this._spiralLengthFactor * this._2PI,
          a = 0,
          h = [];
        for (h.length = e, i = e; i >= 0; i--) e > i && (h[i] = new L.Point(t.x + r * Math.cos(a), t.y + r * Math.sin(a))._round()), a += s / r + 5e-4 * i, r += o / a;
        return h
      },
      _noanimationUnspiderfy: function() {
        var e, t, i = this._group,
          n = i._map,
          r = i._featureGroup,
          s = this.getAllChildMarkers();
        for (i._ignoreMove = !0, this.setOpacity(1), t = s.length - 1; t >= 0; t--) e = s[t], r.removeLayer(e), e._preSpiderfyLatlng && (e.setLatLng(e._preSpiderfyLatlng), delete e._preSpiderfyLatlng), e.setZIndexOffset && e.setZIndexOffset(0), e._spiderLeg && (n.removeLayer(e._spiderLeg), delete e._spiderLeg);
        i.fire("unspiderfied", {
          cluster: this,
          markers: s
        }), i._ignoreMove = !1, i._spiderfied = null
      }
    }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
      _animationSpiderfy: function(e, t) {
        var i, n, r, s, o = this._group,
          a = o._map,
          h = o._featureGroup,
          l = this._group.options.spiderLegPolylineOptions;
        for (o._ignoreMove = !0, i = 0; i < e.length; i++) s = a.layerPointToLatLng(t[i]), n = e[i], r = new L.Polyline([this._latlng, s], l), a.addLayer(r), n._spiderLeg = r, n._preSpiderfyLatlng = n._latlng, n.setLatLng(s), n.setZIndexOffset && n.setZIndexOffset(1e6), h.addLayer(n);
        this.setOpacity(.3), o._ignoreMove = !1, o.fire("spiderfied", {
          cluster: this,
          markers: e
        })
      },
      _animationUnspiderfy: function() {
        this._noanimationUnspiderfy()
      }
    }), L.MarkerCluster.include({
      _animationSpiderfy: function(e, t) {
        var i, n, r, s, o, a, h = this,
          l = this._group,
          u = l._map,
          _ = l._featureGroup,
          d = this._latlng,
          c = u.latLngToLayerPoint(d),
          p = L.Path.SVG,
          f = L.extend({}, this._group.options.spiderLegPolylineOptions),
          m = f.opacity;
        for (void 0 === m && (m = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), p ? (f.opacity = 0, f.className = (f.className || "") + " leaflet-cluster-spider-leg") : f.opacity = m, l._ignoreMove = !0, i = 0; i < e.length; i++) n = e[i], a = u.layerPointToLatLng(t[i]), r = new L.Polyline([d, a], f), u.addLayer(r), n._spiderLeg = r, p && (s = r._path, o = s.getTotalLength() + .1, s.style.strokeDasharray = o, s.style.strokeDashoffset = o), n.setZIndexOffset && n.setZIndexOffset(1e6), n.clusterHide && n.clusterHide(), _.addLayer(n), n._setPos && n._setPos(c);
        for (l._forceLayout(), l._animationStart(), i = e.length - 1; i >= 0; i--) a = u.layerPointToLatLng(t[i]), n = e[i], n._preSpiderfyLatlng = n._latlng, n.setLatLng(a), n.clusterShow && n.clusterShow(), p && (r = n._spiderLeg, s = r._path, s.style.strokeDashoffset = 0, r.setStyle({
          opacity: m
        }));
        this.setOpacity(.3), l._ignoreMove = !1, setTimeout(function() {
          l._animationEnd(), l.fire("spiderfied", {
            cluster: h,
            markers: e
          })
        }, 200)
      },
      _animationUnspiderfy: function(e) {
        var t, i, n, r, s, o, a = this,
          h = this._group,
          l = h._map,
          u = h._featureGroup,
          _ = e ? l._latLngToNewLayerPoint(this._latlng, e.zoom, e.center) : l.latLngToLayerPoint(this._latlng),
          d = this.getAllChildMarkers(),
          c = L.Path.SVG;
        for (h._ignoreMove = !0, h._animationStart(), this.setOpacity(1), i = d.length - 1; i >= 0; i--) t = d[i], t._preSpiderfyLatlng && (t.closePopup(), t.setLatLng(t._preSpiderfyLatlng), delete t._preSpiderfyLatlng, o = !0, t._setPos && (t._setPos(_), o = !1), t.clusterHide && (t.clusterHide(), o = !1), o && u.removeLayer(t), c && (n = t._spiderLeg, r = n._path, s = r.getTotalLength() + .1, r.style.strokeDashoffset = s, n.setStyle({
          opacity: 0
        })));
        h._ignoreMove = !1, setTimeout(function() {
          var e = 0;
          for (i = d.length - 1; i >= 0; i--) t = d[i], t._spiderLeg && e++;
          for (i = d.length - 1; i >= 0; i--) t = d[i], t._spiderLeg && (t.clusterShow && t.clusterShow(), t.setZIndexOffset && t.setZIndexOffset(0), e > 1 && u.removeLayer(t), l.removeLayer(t._spiderLeg), delete t._spiderLeg);
          h._animationEnd(), h.fire("unspiderfied", {
            cluster: a,
            markers: d
          })
        }, 200)
      }
    }), L.MarkerClusterGroup.include({
      _spiderfied: null,
      unspiderfy: function() {
        this._unspiderfy.apply(this, arguments)
      },
      _spiderfierOnAdd: function() {
        this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this)
      },
      _spiderfierOnRemove: function() {
        this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this), this._noanimationUnspiderfy()
      },
      _unspiderfyZoomStart: function() {
        this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this)
      },
      _unspiderfyZoomAnim: function(e) {
        L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy(e))
      },
      _unspiderfyWrapper: function() {
        this._unspiderfy()
      },
      _unspiderfy: function(e) {
        this._spiderfied && this._spiderfied.unspiderfy(e)
      },
      _noanimationUnspiderfy: function() {
        this._spiderfied && this._spiderfied._noanimationUnspiderfy()
      },
      _unspiderfyLayer: function(e) {
        e._spiderLeg && (this._featureGroup.removeLayer(e), e.clusterShow && e.clusterShow(), e.setZIndexOffset && e.setZIndexOffset(0), this._map.removeLayer(e._spiderLeg), delete e._spiderLeg)
      }
    }), L.MarkerClusterGroup.include({
      refreshClusters: function(e) {
        return e ? e instanceof L.MarkerClusterGroup ? e = e._topClusterLevel.getAllChildMarkers() : e instanceof L.LayerGroup ? e = e._layers : e instanceof L.MarkerCluster ? e = e.getAllChildMarkers() : e instanceof L.Marker && (e = [e]) : e = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(e), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(e), this
      },
      _flagParentsIconsNeedUpdate: function(e) {
        var t, i;
        for (t in e)
          for (i = e[t].__parent; i;) i._iconNeedsUpdate = !0, i = i.__parent
      },
      _refreshSingleMarkerModeMarkers: function(e) {
        var t, i;
        for (t in e) i = e[t], this.hasLayer(i) && i.setIcon(this._overrideMarkerIcon(i))
      }
    }), L.Marker.include({
      refreshIconOptions: function(e, t) {
        var i = this.options.icon;
        return L.setOptions(i, e), this.setIcon(i), t && this.__parent && this.__parent._group.refreshClusters(this), this
      }
    }), e.MarkerClusterGroup = t, e.MarkerCluster = i
});
//# sourceMappingURL=leaflet.markercluster.js.map



L.Photo = L.FeatureGroup.extend({
	options: {
		icon: {						
			iconSize: [40, 40]
		}
	},

	initialize: function (photos, options) {
		L.setOptions(this, options);
		L.FeatureGroup.prototype.initialize.call(this, photos);
	},

	addLayers: function (photos) {
		if (photos) {
			for (var i = 0, len = photos.length; i < len; i++) {
				this.addLayer(photos[i]);
			}
		}
		return this;
	},

	addLayer: function (photo) {	
		L.FeatureGroup.prototype.addLayer.call(this, this.createMarker(photo));
	},

	createMarker: function (photo) {
		var marker = L.marker(photo, {
			icon: L.divIcon(L.extend({
				html: '<div style="background-image: url(' + photo.thumbnail + ');"></div>',
				className: 'leaflet-marker-photo'
			}, photo, this.options.icon)),
			title: photo.caption || ''
		});		
		marker.photo = photo;
		return marker;
	}
});

L.photo = function (photos, options) {
	return new L.Photo(photos, options);
};

if (L.MarkerClusterGroup) {

	L.Photo.Cluster = L.MarkerClusterGroup.extend({
		options: {
			featureGroup: L.photo,		
			maxClusterRadius: 100,		
			showCoverageOnHover: false,
			iconCreateFunction: function(cluster) {
				return new L.DivIcon(L.extend({
					className: 'leaflet-marker-photo', 
					html: '<div style="background-image: url(' + cluster.getAllChildMarkers()[0].photo.thumbnail + ');"></div><b>' + cluster.getChildCount() + '</b>'
				}, this.icon));
		   	},	
			icon: {						
				iconSize: [40, 40]
			}		   		
		},

		initialize: function (options) {	
			options = L.Util.setOptions(this, options);
			L.MarkerClusterGroup.prototype.initialize.call(this);
			this._photos = options.featureGroup(null, options);
		},

		add: function (photos) {
			this.addLayer(this._photos.addLayers(photos));
			return this;
		},

		clear: function () {
			this._photos.clearLayers();
			this.clearLayers();
		}

	});

	L.photo.cluster = function (options) {
		return new L.Photo.Cluster(options);	
	};

}



/**
 * Copyright (C) 2011-2012 Pavel Shramov
 * Copyright (C) 2013-2017 Maxime Petazzoni <maxime.petazzoni@bulix.org>
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Thanks to Pavel Shramov who provided the initial implementation and Leaflet
 * integration. Original code was at https://github.com/shramov/leaflet-plugins.
 *
 * It was then cleaned-up and modified to record and make available more
 * information about the GPX track while it is being parsed so that the result
 * can be used to display additional information about the track that is
 * rendered on the Leaflet map.
 */

var L = L || require('leaflet');

var _MAX_POINT_INTERVAL_MS = 15000;
var _SECOND_IN_MILLIS = 1000;
var _MINUTE_IN_MILLIS = 60 * _SECOND_IN_MILLIS;
var _HOUR_IN_MILLIS = 60 * _MINUTE_IN_MILLIS;
var _DAY_IN_MILLIS = 24 * _HOUR_IN_MILLIS;

var _GPX_STYLE_NS = 'http://www.topografix.com/GPX/gpx_style/0/2';

var _DEFAULT_MARKER_OPTS = {
  startIconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAtCAMAAAAX+PImAAABC1BMVEUAAAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAAAgAD///8AlAAAkgAAgQAAgwAAhgAAjQAAkAAAhwAElQQAigD7/fv3/PcfoR8LmQsAjABRtlFGskY8rTw0qjQAkQDx+fHp9unX7te+5L6W05ZjvmMUnRTi8+Lc8NzP68+q26qc1px0xXRAr0DM6szI6Mi04LSIzYhyxHJpwGkupy4spyzxfiXGAAAALXRSTlMA/QL59OffBr60qG9iDuzPujoJ746Ff3l0TUhAMycjGxJd18WunJhZLRgMZVI0U6/AAAACQklEQVQ4y32U53baQBBGR6L33k1zjZ0sLJJA9GoDjmt63v9JMrNarELs+4ODVvd8MxrtCmzU62opmg6no6VqU4VjQieFVI4JFH8qnwl5hUY+wJwkL+vgRK2kmJfTL6pDiMuAnqbrutaTMbGQLVgNaMM+J9YzXUj+8kGpioTekHcPcENjSK4NguaZCDDELUL8GTAkeAJEUQh9WjYny8XrxORvynmCnvOUSoiE1e5uMxo/PC9NUqiQ7wqNGLkDXDL3XzsWt7+meG1Qu5EbyEYogmrsN50D4xdT1glkoBG0IvjKSpApr9wKUWJQ8aNhYI3njpMnU3YShbgiivDJg8u4/YMhVCYMMTQ03uWLscsYzdEYonEGZWnMRx0Xv8mwM46N0V4aEYhLY7lxGeOFNPL0LKLT++8u426Cho5DbUOd5jHDR3txlfkp5x78BIk0GjrHkK1D+EYRBrWRBSjKqfPVo11jiQLHIiwGAJkcjZ1W/j6NrS5/rLh8c0Hazzfi1c2o7nSx2z5ud/MpCWua+YUKSNv3tkF4d3o/xV8SqEayBkQrzGSKJQn6JLBoFgRXfoWUQd/eyTONyQhB4pyhQo6x5kh/SPdx7TIEkkyAKYo8UvJE4QJN64BaVAhmQ5e+Mthch5nihaVb4KAWYF4hUHMf/rLPY/hKKrhIRJk7ItICD/WUU6ETe0Ql6VD8cThGLTlayctxv9cKCzfhvzRSTDaRAS/2x8jVxDHqZz9NohCCdwkVsduLBHxAtuBLN+FDWgXvqP4Bkoed0xIT03MAAAAASUVORK5CYII=',
  endIconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAtCAMAAAAX+PImAAABAlBMVEUAAADGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkLGQkL///+3LCy4Li62KSnFQEDDPT3COzu7MjK9NDT9+Pi6MDC/NzfARUXBOTn+/PzUf3/Ob2/GV1e6NTX57e303t7iqKjYjIzLZGTJX1/78/P35+f14uLx19fx1NTtysrrxMTkrq7MaGjIXFzEUVG8PDznubnnuLjdnJy+Pz/5SaUvAAAALHRSTlMA/AL5Cgb08ObdurSoGg3sz75zbmM6joV/eVpNSEAzJyMSX+jh18SunJgtUvqwWL0AAAJBSURBVDjLfZN3e6JAEIcHsAXF3kssudRbAQFBjSWx5NLLle//VW5nWaUYff/hYZ+X3wyzu+AhKs1aSpblVK2piLBP9LSSjROGEM+WS9Gw0CkniJ/MdRv8iI0sCXP+U/QJxTPCGBimaRoDHlOI7oSe24AxsjRN1TRnaDIplt8qzQT7fqSpWzTLwKV4HRjKBRMsFdEpzDFx8eQUkOpO0LXxZr0Za/pOuUzjf56jMFQp8+W9bduPbx8sBQtJWKeA7gSXpr/6LncrTLSw3WQEIkmMcOjK9KG/xV5hCtY5K0HnxI3Q524CT1nrNAR3IA+NGH0OaY23vp8/Fu8kBUWBFdHHjwHj7pOGTKiRgwI1DE3V13bAuJ1RY0SNC8hzY3bbDzBFg2ccN5JQ5MbHQ0Cw37lRxn9h4/h6Dhj3Y50NROpBG+eBM18FyvzFIdOh/riBtEwNk77/e/EJzxhhuVOHKt9Zff7k1djofHcLAFCKY4hGlc/fttvl61ylDLFIGwC3jneiL96Xr08vy9kCD4iDM78SgVKXdgdEVxdfC9U7ZJkWIN0c4YoPBwWSigCjHhNQmTjeScYeeASSviRUQcdyNIo1whbo2nUUOKUEEQR+pQxjgN/jwsmNd+eqAkI88FXKg4eSI0IYInfBRytBwkKiBX7EvBQypJoIAdIpEoxIdiFEO+tX8Mbu0cj4lFgR9hFrvlbKfNyHWiE5Bb6lkyW8iRIcoOlOJdaDQ4jFOE6iEoWDRKu026s0HCFSkWQFjtKthEf1H+4TmsxXLEfyAAAAAElFTkSuQmCC',
  shadowUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAQAAAC0NkA6AAAELklEQVR4AWIYBaNgFIyCUTAKRsEoADRLF2uSFEEcwCMjpaRlfb9vcXeHK+5whjP+GuzzMFfuzBl3d4fx6ZK0iGC2exenC4d/tHdV/NL+bNTf2kf+ODLUFEF9X4sIMMip+tPIouX16FWLEROKYiXzAlh80FxQyWfQ6gL8w4gCvB53cJ/2OMZOJ8xIyEjYLeYiyGM2VOVp5rxLl9GKAP8RBEFdrqe60EaLAYM66KiTbjWjR1CMAEqQKprkKpWhjhTLDLQyn436nUukz9Ejc451dmLRZkOms9F0xuuwVwlPQ4Av2VGR98ex399N+txvxQP5NAIGMMdhWY6fBFozsUedcVOHBRbksh3Z7DbsV0Y0acKvEECxpiPxaBi11iBMOfNnvMUAAOaNJcSKAgR9mtmxh1xdmBJLXx2uUvlcEV2y4cSMNCMhICiAzMzrcdZPzU2s0nbyaZzX1BxZG9jq00xb7C/rkutcQ/1J/VxFZXbZRkNzAhQrWJwuFsoGoEkvuwvsTAfcVhOYI78trCrAM8ysmNR6lEcXTF4eh5pLLnORjGjWCQF5TgAszhYAI++B6+os+EZa2IUXABTIso3HC+xmMRnh1E7Hk0+mapQqKcixBUx4cg7zoIAgIUlErxrcOXPTb/KO7sB/nICWzgSUx8PO1WdNPtr3yZQmeUQFWdCsfzJ+QUYG0hmSCtxhc6T5phVPqcprDLJ8udQtCjSYfcWn9bcjGu8RVXKMgKcAFGBkJEuaIKnEUXpoj862d2SWuzY0CWgIgZm6BMFku1GYMhfiyLL5MWBIE5LNOpnMUYL41J3drM2kyW3bQwQCHkSuhwNqot7W1rCJBjQj4wJARtJksk4um2iiRB1Cf2nP3Uetabu+9ZAgL4hBJEiCs+BFyDDvrkAQgM0ccEnHItpog/Xkr+t3+22/04Nv/Sg2+RQxgAisyq4EtnQRvSpOohgGQNH5BOBOAL7wyl/fH+sb33rrdaBYpgPpYwJeEIOIkmdgKkl62S9aNGvmrBBzuQeYUPqyt/29fdUpzz2FFEOC1OY5IPOCQWSRo7Ah1V5ZimQTihKdquB83evu/u5wZzrnfQixSZyYZvzxL4Eh5BZ4E2owotmQSbWiBFSGsnPd/e2xbtzZ3gUKmD7Mn9Mar/Iv2w8iokAdVZ8pB4pcYp8zAEbX39uc1h7oRp3zOu7GNmf6nC+X478BDCCLsCCnbAOyKKRrwg1t0Rzs9nv0IULeogP8MAOsLAEGkBdgDB1s88fR9jrUfG9y/aSbdpWHAHmSP+QnGERgOGbZReuwxbOUPeQ7ZJSLtM8f6DFMUpXfoAf4+uH+gzNRAC0jfRDOkmtUSzVVCQLElGf0ND8pIPC7o+Q3/1nVL9novLU6SkEVTQlTpK/ojwEDyIN4ud7RQY9VI5lPY+A36Cn+/cAwMpz/G/IdAqGyx1q2VHAAAAAASUVORK5CYII=',
  wptIcons: [],
  wptIconUrls : {
    '': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAzCAMAAAAuJJHNAAAAkFBMVEUAAAAAru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru8Aru9ovJP8AAAAL3RSTlMA+AT68Fr0FA8H3MSXQDkL6+bg1o6CUkcxwbitbV8sJyQZz76neH1yTB6yolWHaUf8FCEAAAGESURBVDjLfdTnloIwEAXgmyxVKUoTxLWsvezO+7/dqkgGDPH7B2dOuJkwQVe8Dgv7Fq48DIqjfJtYQggrGWczvcifXSxiTmXH6DkHFvWJeomOcky6dNYp+KEhiSrZbGlY+vqQzMikbuKGEzIRNu7klcwqD8BySmbiEXbRi18Hu/SLWAbIHSlOtpaQm30n2NjFhnvxtZd4srnB0xIlx5h7aMiAgxSYOdT6RivklwvYQqWI+CATVZHjWyW3uGIzUhW/uAkV1EYr4qgHRLy1nY+XvNt3l3frtFHDKe92CQTEj38egLhISZnHQNFpsqjyxWHuENs/cqdkNilxl5FZ7fPWdNwAvyaTHxdPhSCDIxqe6V8frfHCZ9OXo+WOh5dYAZ8XycHcypCC2YI0B3R5c31oz+g5Oe/tXKDPV2PDg/ImmmgzzYbuiEsMzWpEbBJiwJFYIMG03nO/NYXDpz7Mv1KjcmFQJvRgnWC0b2L6YENhR0t8cLLUgRjIgG8ig9U2xGdy/R7zH4uopdSUohgfAAAAAElFTkSuQmCC',
  },
  pointMatchers: [],
  iconSize: [33, 50],
  shadowSize: [50, 50],
  iconAnchor: [16, 45],
  shadowAnchor: [16, 47],
  clickable: false
};
var _DEFAULT_POLYLINE_OPTS = {
  color: 'blue'
};
var _DEFAULT_GPX_OPTS = {
  parseElements: ['track', 'route', 'waypoint']
};
L.GPX = L.FeatureGroup.extend({
  initialize: function(gpx, options) {
    options.max_point_interval = options.max_point_interval || _MAX_POINT_INTERVAL_MS;
    options.marker_options = this._merge_objs(
      _DEFAULT_MARKER_OPTS,
      options.marker_options || {});
    options.polyline_options = options.polyline_options || {};
    options.gpx_options = this._merge_objs(
      _DEFAULT_GPX_OPTS,
      options.gpx_options || {});

    L.Util.setOptions(this, options);

    // Base icon class for track pins.
    L.GPXTrackIcon = L.Icon.extend({ options: options.marker_options });

    this._gpx = gpx;
    this._layers = {};
    this._init_info();

    if (gpx) {
      this._parse(gpx, options, this.options.async);
    }
  },

  get_duration_string: function(duration, hidems) {
    var s = '';

    if (duration >= _DAY_IN_MILLIS) {
      s += Math.floor(duration / _DAY_IN_MILLIS) + 'd ';
      duration = duration % _DAY_IN_MILLIS;
    }

    if (duration >= _HOUR_IN_MILLIS) {
      s += Math.floor(duration / _HOUR_IN_MILLIS) + ':';
      duration = duration % _HOUR_IN_MILLIS;
    }

    var mins = Math.floor(duration / _MINUTE_IN_MILLIS);
    duration = duration % _MINUTE_IN_MILLIS;
    if (mins < 10) s += '0';
    s += mins + '\\'';

    var secs = Math.floor(duration / _SECOND_IN_MILLIS);
    duration = duration % _SECOND_IN_MILLIS;
    if (secs < 10) s += '0';
    s += secs;

    if (!hidems && duration > 0) s += '.' + Math.round(Math.floor(duration)*1000)/1000;
    else s += '"';

    return s;
  },

  get_duration_string_iso: function(duration, hidems) {
    var s = this.get_duration_string(duration, hidems);
    return s.replace("'",':').replace('"','');
  },

  // Public methods
  to_miles:            function(v) { return v / 1.60934; },
  to_ft:               function(v) { return v * 3.28084; },
  m_to_km:             function(v) { return v / 1000; },
  m_to_mi:             function(v) { return v / 1609.34; },

  get_name:            function() { return this._info.name; },
  get_desc:            function() { return this._info.desc; },
  get_author:          function() { return this._info.author; },
  get_copyright:       function() { return this._info.copyright; },
  get_distance:        function() { return this._info.length; },
  get_distance_imp:    function() { return this.to_miles(this.m_to_km(this.get_distance())); },

  get_start_time:      function() { return this._info.duration.start; },
  get_end_time:        function() { return this._info.duration.end; },
  get_moving_time:     function() { return this._info.duration.moving; },
  get_total_time:      function() { return this._info.duration.total; },

  get_moving_pace:     function() { return this.get_moving_time() / this.m_to_km(this.get_distance()); },
  get_moving_pace_imp: function() { return this.get_moving_time() / this.get_distance_imp(); },

  get_moving_speed:    function() { return this.m_to_km(this.get_distance()) / (this.get_moving_time() / (3600 * 1000)) ; },
  get_moving_speed_imp:function() { return this.to_miles(this.m_to_km(this.get_distance())) / (this.get_moving_time() / (3600 * 1000)) ; },

  get_total_speed:     function() { return this.m_to_km(this.get_distance()) / (this.get_total_time() / (3600 * 1000)); },
  get_total_speed_imp: function() { return this.to_miles(this.m_to_km(this.get_distance())) / (this.get_total_time() / (3600 * 1000)); },

  get_elevation_gain:     function() { return this._info.elevation.gain; },
  get_elevation_loss:     function() { return this._info.elevation.loss; },
  get_elevation_gain_imp: function() { return this.to_ft(this.get_elevation_gain()); },
  get_elevation_loss_imp: function() { return this.to_ft(this.get_elevation_loss()); },
  get_elevation_data:     function() {
    var _this = this;
    return this._info.elevation._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' m'; });
      });
  },
  get_elevation_data_imp: function() {
    var _this = this;
    return this._info.elevation._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, _this.to_ft,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' ft'; });
      });
  },
  get_elevation_max:      function() { return this._info.elevation.max; },
  get_elevation_min:      function() { return this._info.elevation.min; },
  get_elevation_max_imp:  function() { return this.to_ft(this.get_elevation_max()); },
  get_elevation_min_imp:  function() { return this.to_ft(this.get_elevation_min()); },

  get_average_hr:         function() { return this._info.hr.avg; },
  get_average_temp:         function() { return this._info.atemp.avg; },
  get_average_cadence:         function() { return this._info.cad.avg; },
  get_heartrate_data:     function() {
    var _this = this;
    return this._info.hr._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' bpm'; });
      });
  },
  get_heartrate_data_imp: function() {
    var _this = this;
    return this._info.hr._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' bpm'; });
      });
  },
  get_cadence_data:     function() {
    var _this = this;
    return this._info.cad._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' rpm'; });
      });
  },
  get_temp_data:     function() {
    var _this = this;
    return this._info.atemp._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' degrees'; });
      });
  },
  get_cadence_data_imp:     function() {
    var _this = this;
    return this._info.cad._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' rpm'; });
      });
  },
  get_temp_data_imp:     function() {
    var _this = this;
    return this._info.atemp._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' degrees'; });
      });
  },

  reload: function() {
    this._init_info();
    this.clearLayers();
    this._parse(this._gpx, this.options, this.options.async);
  },

  // Private methods
  _merge_objs: function(a, b) {
    var _ = {};
    for (var attr in a) { _[attr] = a[attr]; }
    for (var attr in b) { _[attr] = b[attr]; }
    return _;
  },

  _prepare_data_point: function(p, trans1, trans2, trans_tooltip) {
    var r = [trans1 && trans1(p[0]) || p[0], trans2 && trans2(p[1]) || p[1]];
    r.push(trans_tooltip && trans_tooltip(r[0], r[1]) || (r[0] + ': ' + r[1]));
    return r;
  },

  _init_info: function() {
    this._info = {
      name: null,
      length: 0.0,
      elevation: {gain: 0.0, loss: 0.0, max: 0.0, min: Infinity, _points: []},
      hr: {avg: 0, _total: 0, _points: []},
      duration: {start: null, end: null, moving: 0, total: 0},
      atemp: {avg: 0, _total: 0, _points: []},
      cad: {avg: 0, _total: 0, _points: []}
    };
  },

  _load_xml: function(url, cb, options, async) {
    if (async == undefined) async = this.options.async;
    if (options == undefined) options = this.options;

    var req = new window.XMLHttpRequest();
    req.open('GET', url, async);
    try {
      req.overrideMimeType('text/xml'); // unsupported by IE
    } catch(e) {}
    req.onreadystatechange = function() {
      if (req.readyState != 4) return;
      if(req.status == 200) cb(req.responseXML, options);
    };
    req.send(null);
  },

  _parse: function(input, options, async) {
    var _this = this;
    var cb = function(gpx, options) {
      var layers = _this._parse_gpx_data(gpx, options);
      if (!layers) {
        _this.fire('error', { err: 'No parseable layers of type(s) ' + JSON.stringify(options.gpx_options.parseElements) });
        return;
      }
      _this.addLayer(layers);
      _this.fire('loaded', { layers: layers, element: gpx });
    }
    if (input.substr(0,1)==='<') { // direct XML has to start with a <
      var parser = new DOMParser();
      if (async) {
        setTimeout(function() {
          cb(parser.parseFromString(input, "text/xml"), options);
        });
      } else {
        cb(parser.parseFromString(input, "text/xml"), options);
      }
    } else {
      this._load_xml(input, cb, options, async);
    }
  },

  _parse_gpx_data: function(xml, options) {
    var i, t, l, el, layers = [];
    var tags = [];

    var parseElements = options.gpx_options.parseElements;
    if (parseElements.indexOf('route') > -1) {
      tags.push(['rte','rtept']);
    }
    if (parseElements.indexOf('track') > -1) {
      tags.push(['trkseg','trkpt']);
    }

    var name = xml.getElementsByTagName('name');
    if (name.length > 0) {
      this._info.name = name[0].textContent;
    }
    var desc = xml.getElementsByTagName('desc');
    if (desc.length > 0) {
      this._info.desc = desc[0].textContent;
    }
    var author = xml.getElementsByTagName('author');
    if (author.length > 0) {
      this._info.author = author[0].textContent;
    }
    var copyright = xml.getElementsByTagName('copyright');
    if (copyright.length > 0) {
      this._info.copyright = copyright[0].textContent;
    }
this._info.number_of_points = 0;
    for (t = 0; t < tags.length; t++) {
      el = xml.getElementsByTagName(tags[t][0]);
      for (i = 0; i < el.length; i++) {
        var trackLayers = this._parse_trkseg(el[i], options, tags[t][1]);
        for (l = 0; l < trackLayers.length; l++) {
          layers.push(trackLayers[l]);
        }
      }
    }

    this._info.hr.avg = Math.round(this._info.hr._total / this._info.hr._points.length);
    this._info.cad.avg = Math.round(this._info.cad._total / this._info.cad._points.length);
    this._info.atemp.avg = Math.round(this._info.atemp._total / this._info.atemp._points.length);

    // parse waypoints and add markers for each of them
    if (parseElements.indexOf('waypoint') > -1) {
      el = xml.getElementsByTagName('wpt');
      for (i = 0; i < el.length; i++) {
        var ll = new L.LatLng(
            el[i].getAttribute('lat'),
            el[i].getAttribute('lon'));

        var nameEl = el[i].getElementsByTagName('name');
        var name = '';
        if (nameEl.length > 0) {
          name = nameEl[0].textContent;
        }

        var descEl = el[i].getElementsByTagName('desc');
        var desc = '';
        if (descEl.length > 0) {
          desc = descEl[0].textContent;
        }

        var symEl = el[i].getElementsByTagName('sym');
        var symKey = '';
        if (symEl.length > 0) {
          symKey = symEl[0].textContent;
        }

        /*
         * Add waypoint marker based on the waypoint symbol key.
         *
         * First look for a configured icon for that symKey. If not found, look
         * for a configured icon URL for that symKey and build an icon from it.
         * Otherwise, fall back to the default icon if one was configured, or
         * finally to the default icon URL.
         */
        var wptIcons = options.marker_options.wptIcons;
        var wptIconUrls = options.marker_options.wptIconUrls;
        var symIcon;
        if (wptIcons && wptIcons[symKey]) {
          symIcon = wptIcons[symKey];
        } else if (wptIconUrls && wptIconUrls[symKey]) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconUrls[symKey]});
        } else if (wptIcons && wptIcons['']) {
          symIcon = wptIcons[''];
        } else if (wptIconUrls && wptIconUrls['']) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconUrls['']});
        } else {
          console.log('No icon or icon URL configured for symbol type "' + symKey
            + '", and no fallback configured; ignoring waypoint.');
          continue;
        }

        var marker = new L.Marker(ll, {
          clickable: options.marker_options.clickable,
          title: name,
          icon: symIcon
        });
        marker.bindPopup("<b>" + name + "</b>" + (desc.length > 0 ? '<br>' + desc : '')).openPopup();
        this.fire('addpoint', { point: marker, point_type: 'waypoint', element: el[i] });
        layers.push(marker);
      }
    }

    if (layers.length > 1) {
       return new L.FeatureGroup(layers);
    } else if (layers.length == 1) {
      return layers[0];
    }
  },

  _parse_trkseg: function(line, options, tag) {
    var el = line.getElementsByTagName(tag);
    if (!el.length) return [];

    var coords = [];
    var markers = [];
    var layers = [];
    var last = null;

    for (var i = 0; i < el.length; i++) {
this._info.number_of_points++;
      var _, ll = new L.LatLng(
        el[i].getAttribute('lat'),
        el[i].getAttribute('lon'));
      ll.meta = { time: null, ele: null, hr: null, cad: null, atemp: null };

      _ = el[i].getElementsByTagName('time');
      if (_.length > 0) {
        ll.meta.time = new Date(Date.parse(_[0].textContent));
      } else {
        ll.meta.time = new Date('1970-01-01T00:00:00');
      }

      _ = el[i].getElementsByTagName('ele');
      if (_.length > 0) {
        ll.meta.ele = parseFloat(_[0].textContent);
      }

      _ = el[i].getElementsByTagName('name');
      if (_.length > 0) {
        var name = _[0].textContent;
        var ptMatchers = options.marker_options.pointMatchers || [];

        for (var j = 0; j < ptMatchers.length; j++) {
          if (ptMatchers[j].regex.test(name)) {
            markers.push({ label: name, coords: ll, icon: ptMatchers[j].icon, element: el[i] });
            break;
          }
        }
      }

      _ = el[i].getElementsByTagNameNS('*', 'hr');
      if (_.length > 0) {
        ll.meta.hr = parseInt(_[0].textContent);
        this._info.hr._points.push([this._info.length, ll.meta.hr]);
        this._info.hr._total += ll.meta.hr;
      }

      _ = el[i].getElementsByTagNameNS('*', 'cad');
      if (_.length > 0) {
        ll.meta.cad = parseInt(_[0].textContent);
        this._info.cad._points.push([this._info.length, ll.meta.cad]);
        this._info.cad._total += ll.meta.cad;
      }

      _ = el[i].getElementsByTagNameNS('*', 'atemp');
      if (_.length > 0) {
        ll.meta.atemp = parseInt(_[0].textContent);
        this._info.atemp._points.push([this._info.length, ll.meta.atemp]);
        this._info.atemp._total += ll.meta.atemp;
      }

      if (ll.meta.ele > this._info.elevation.max) {
        this._info.elevation.max = ll.meta.ele;
      }

      if (ll.meta.ele < this._info.elevation.min) {
        this._info.elevation.min = ll.meta.ele;
      }

      this._info.elevation._points.push([this._info.length, ll.meta.ele]);
      this._info.duration.end = ll.meta.time;

      if (last != null) {
        this._info.length += this._dist3d(last, ll);

        var t = ll.meta.ele - last.meta.ele;
        if (t > 0) {
          this._info.elevation.gain += t;
        } else {
          this._info.elevation.loss += Math.abs(t);
        }

        t = Math.abs(ll.meta.time - last.meta.time);
        this._info.duration.total += t;
        if (t < options.max_point_interval) {
          this._info.duration.moving += t;
        }
      } else if (this._info.duration.start == null) {
        this._info.duration.start = ll.meta.time;
      }

      last = ll;
      coords.push(ll);
    }

    // check for gpx_style styling extension
    var polyline_options = this._merge_objs(_DEFAULT_POLYLINE_OPTS, {});
    var e = line.getElementsByTagNameNS(_GPX_STYLE_NS, 'line');
    if (e.length > 0) {
      var _ = e[0].getElementsByTagName('color');
      if (_.length > 0) polyline_options.color = '#' + _[0].textContent;
      var _ = e[0].getElementsByTagName('opacity');
      if (_.length > 0) polyline_options.opacity = _[0].textContent;
      var _ = e[0].getElementsByTagName('weight');
      if (_.length > 0) polyline_options.weight = _[0].textContent;
      var _ = e[0].getElementsByTagName('linecap');
      if (_.length > 0) polyline_options.lineCap = _[0].textContent;
    }

    // add track
    var l = new L.Polyline(coords, this._merge_objs(polyline_options, options.polyline_options));
    this.fire('addline', { line: l, element: line });
    layers.push(l);

    if (options.marker_options.startIcon || options.marker_options.startIconUrl) {
      // add start pin
      var marker = new L.Marker(coords[0], {
        clickable: options.marker_options.clickable,
        icon: options.marker_options.startIcon || new L.GPXTrackIcon({iconUrl: options.marker_options.startIconUrl})
      });
      this.fire('addpoint', { point: marker, point_type: 'start', element: el[0] });
      layers.push(marker);
    }

    if (options.marker_options.endIcon || options.marker_options.endIconUrl) {
      // add end pin
      var marker = new L.Marker(coords[coords.length-1], {
        clickable: options.marker_options.clickable,
        icon: options.marker_options.endIcon || new L.GPXTrackIcon({iconUrl: options.marker_options.endIconUrl})
      });
      this.fire('addpoint', { point: marker, point_type: 'end', element: el[el.length-1] });
      layers.push(marker);
    }

    // add named markers
    for (var i = 0; i < markers.length; i++) {
      var marker = new L.Marker(markers[i].coords, {
        clickable: options.marker_options.clickable,
        title: markers[i].label,
        icon: markers[i].icon
      });
      this.fire('addpoint', { point: marker, point_type: 'label', element: markers[i].element });
      layers.push(marker);
    }

    return layers;
  },

  _dist2d: function(a, b) {
    var R = 6371000;
    var dLat = this._deg2rad(b.lat - a.lat);
    var dLon = this._deg2rad(b.lng - a.lng);
    var r = Math.sin(dLat/2) *
      Math.sin(dLat/2) +
      Math.cos(this._deg2rad(a.lat)) *
      Math.cos(this._deg2rad(b.lat)) *
      Math.sin(dLon/2) *
      Math.sin(dLon/2);
    var c = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1-r));
    var d = R * c;
    return d;
  },

  _dist3d: function(a, b) {
    var planar = this._dist2d(a, b);
    var height = Math.abs(b.meta.ele - a.meta.ele);
    return Math.sqrt(Math.pow(planar, 2) + Math.pow(height, 2));
  },

  _deg2rad: function(deg) {
    return deg * Math.PI / 180;
  }
});

if (typeof module === 'object' && typeof module.exports === 'object') {
  module.exports = L;
} else if (typeof define === 'function' && define.amd) {
  define(L);
}



(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Dygraph = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the custom bars option.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _bars = require('./bars');

var _bars2 = _interopRequireDefault(_bars);

/**
 * @constructor
 * @extends Dygraph.DataHandlers.BarsHandler
 */
var CustomBarsHandler = function CustomBarsHandler() {};

CustomBarsHandler.prototype = new _bars2['default']();

/** @inheritDoc */
CustomBarsHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, point;
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[1] <= 0 || point[2] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      y = point[1];
      if (y !== null && !isNaN(y)) {
        series.push([x, y, [point[0], point[2]]]);
      } else {
        series.push([x, y, [y, y]]);
      }
    } else {
      series.push([x, null, [null, null]]);
    }
  }
  return series;
};

/** @inheritDoc */
CustomBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];
  var y, low, high, mid, count, i, extremes;

  low = 0;
  mid = 0;
  high = 0;
  count = 0;
  for (i = 0; i < originalData.length; i++) {
    y = originalData[i][1];
    extremes = originalData[i][2];
    rollingData[i] = originalData[i];

    if (y !== null && !isNaN(y)) {
      low += extremes[0];
      mid += y;
      high += extremes[1];
      count += 1;
    }
    if (i - rollPeriod >= 0) {
      var prev = originalData[i - rollPeriod];
      if (prev[1] !== null && !isNaN(prev[1])) {
        low -= prev[2][0];
        mid -= prev[1];
        high -= prev[2][1];
        count -= 1;
      }
    }
    if (count) {
      rollingData[i] = [originalData[i][0], 1.0 * mid / count, [1.0 * low / count, 1.0 * high / count]];
    } else {
      rollingData[i] = [originalData[i][0], null, [null, null]];
    }
  }

  return rollingData;
};

exports['default'] = CustomBarsHandler;
module.exports = exports['default'];

},{"./bars":5}],3:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the error bars option.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _bars = require('./bars');

var _bars2 = _interopRequireDefault(_bars);

/**
 * @constructor
 * @extends BarsHandler
 */
var ErrorBarsHandler = function ErrorBarsHandler() {};

ErrorBarsHandler.prototype = new _bars2["default"]();

/** @inheritDoc */
ErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, variance, point;
  var sigma = options.get("sigma");
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      y = point[0];
      if (y !== null && !isNaN(y)) {
        variance = sigma * point[1];
        // preserve original error value in extras for further
        // filtering
        series.push([x, y, [y - variance, y + variance, point[1]]]);
      } else {
        series.push([x, y, [y, y, y]]);
      }
    } else {
      series.push([x, null, [null, null, null]]);
    }
  }
  return series;
};

/** @inheritDoc */
ErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];
  var sigma = options.get("sigma");

  var i, j, y, v, sum, num_ok, stddev, variance, value;

  // Calculate the rolling average for the first rollPeriod - 1 points
  // where there is not enough data to roll over the full number of points
  for (i = 0; i < originalData.length; i++) {
    sum = 0;
    variance = 0;
    num_ok = 0;
    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {
      y = originalData[j][1];
      if (y === null || isNaN(y)) continue;
      num_ok++;
      sum += y;
      variance += Math.pow(originalData[j][2][2], 2);
    }
    if (num_ok) {
      stddev = Math.sqrt(variance) / num_ok;
      value = sum / num_ok;
      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];
    } else {
      // This explicitly preserves NaNs to aid with "independent
      // series".
      // See testRollingAveragePreservesNaNs.
      v = rollPeriod == 1 ? originalData[i][1] : null;
      rollingData[i] = [originalData[i][0], v, [v, v]];
    }
  }

  return rollingData;
};

exports["default"] = ErrorBarsHandler;
module.exports = exports["default"];

},{"./bars":5}],4:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the combination 
 * of error bars and fractions options.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _bars = require('./bars');

var _bars2 = _interopRequireDefault(_bars);

/**
 * @constructor
 * @extends Dygraph.DataHandlers.BarsHandler
 */
var FractionsBarsHandler = function FractionsBarsHandler() {};

FractionsBarsHandler.prototype = new _bars2["default"]();

/** @inheritDoc */
FractionsBarsHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, point, num, den, value, stddev, variance;
  var mult = 100.0;
  var sigma = options.get("sigma");
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[1] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      num = point[0];
      den = point[1];
      if (num !== null && !isNaN(num)) {
        value = den ? num / den : 0.0;
        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;
        variance = mult * stddev;
        y = mult * value;
        // preserve original values in extras for further filtering
        series.push([x, y, [y - variance, y + variance, num, den]]);
      } else {
        series.push([x, num, [num, num, num, den]]);
      }
    } else {
      series.push([x, null, [null, null, null, null]]);
    }
  }
  return series;
};

/** @inheritDoc */
FractionsBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];
  var sigma = options.get("sigma");
  var wilsonInterval = options.get("wilsonInterval");

  var low, high, i, stddev;
  var num = 0;
  var den = 0; // numerator/denominator
  var mult = 100.0;
  for (i = 0; i < originalData.length; i++) {
    num += originalData[i][2][2];
    den += originalData[i][2][3];
    if (i - rollPeriod >= 0) {
      num -= originalData[i - rollPeriod][2][2];
      den -= originalData[i - rollPeriod][2][3];
    }

    var date = originalData[i][0];
    var value = den ? num / den : 0.0;
    if (wilsonInterval) {
      // For more details on this confidence interval, see:
      // http://en.wikipedia.org/wiki/Binomial_confidence_interval
      if (den) {
        var p = value < 0 ? 0 : value,
            n = den;
        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));
        var denom = 1 + sigma * sigma / den;
        low = (p + sigma * sigma / (2 * den) - pm) / denom;
        high = (p + sigma * sigma / (2 * den) + pm) / denom;
        rollingData[i] = [date, p * mult, [low * mult, high * mult]];
      } else {
        rollingData[i] = [date, 0, [0, 0]];
      }
    } else {
      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;
      rollingData[i] = [date, mult * value, [mult * (value - stddev), mult * (value + stddev)]];
    }
  }

  return rollingData;
};

exports["default"] = FractionsBarsHandler;
module.exports = exports["default"];

},{"./bars":5}],5:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler base implementation for the "bar" 
 * data formats. This implementation must be extended and the
 * extractSeries and rollingAverage must be implemented.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
/*global DygraphLayout:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _datahandler = require('./datahandler');

var _datahandler2 = _interopRequireDefault(_datahandler);

var _dygraphLayout = require('../dygraph-layout');

var _dygraphLayout2 = _interopRequireDefault(_dygraphLayout);

/**
 * @constructor
 * @extends {Dygraph.DataHandler}
 */
var BarsHandler = function BarsHandler() {
  _datahandler2['default'].call(this);
};
BarsHandler.prototype = new _datahandler2['default']();

// TODO(danvk): figure out why the jsdoc has to be copy/pasted from superclass.
//   (I get closure compiler errors if this isn't here.)
/**
 * @override
 * @param {!Array.<Array>} rawData The raw data passed into dygraphs where 
 *     rawData[i] = [x,ySeries1,...,ySeriesN].
 * @param {!number} seriesIndex Index of the series to extract. All other
 *     series should be ignored.
 * @param {!DygraphOptions} options Dygraph options.
 * @return {Array.<[!number,?number,?]>} The series in the unified data format
 *     where series[i] = [x,y,{extras}]. 
 */
BarsHandler.prototype.extractSeries = function (rawData, seriesIndex, options) {
  // Not implemented here must be extended
};

/**
 * @override
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *          data format where series[i] = [x,y,{extras}].
 * @param {!number} rollPeriod The number of points over which to average the data
 * @param {!DygraphOptions} options The dygraph options.
 * TODO(danvk): be more specific than "Array" here.
 * @return {!Array.<[!number,?number,?]>} the rolled series.
 */
BarsHandler.prototype.rollingAverage = function (series, rollPeriod, options) {
  // Not implemented here, must be extended.
};

/** @inheritDoc */
BarsHandler.prototype.onPointsCreated_ = function (series, points) {
  for (var i = 0; i < series.length; ++i) {
    var item = series[i];
    var point = points[i];
    point.y_top = NaN;
    point.y_bottom = NaN;
    point.yval_minus = _datahandler2['default'].parseFloat(item[2][0]);
    point.yval_plus = _datahandler2['default'].parseFloat(item[2][1]);
  }
};

/** @inheritDoc */
BarsHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {
  var minY = null,
      maxY = null,
      y;

  var firstIdx = 0;
  var lastIdx = series.length - 1;

  for (var j = firstIdx; j <= lastIdx; j++) {
    y = series[j][1];
    if (y === null || isNaN(y)) continue;

    var low = series[j][2][0];
    var high = series[j][2][1];

    if (low > y) low = y; // this can happen with custom bars,
    if (high < y) high = y; // e.g. in tests/custom-bars.html

    if (maxY === null || high > maxY) maxY = high;
    if (minY === null || low < minY) minY = low;
  }

  return [minY, maxY];
};

/** @inheritDoc */
BarsHandler.prototype.onLineEvaluated = function (points, axis, logscale) {
  var point;
  for (var j = 0; j < points.length; j++) {
    // Copy over the error terms
    point = points[j];
    point.y_top = _dygraphLayout2['default'].calcYNormal_(axis, point.yval_minus, logscale);
    point.y_bottom = _dygraphLayout2['default'].calcYNormal_(axis, point.yval_plus, logscale);
  }
};

exports['default'] = BarsHandler;
module.exports = exports['default'];

},{"../dygraph-layout":13,"./datahandler":6}],6:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview This file contains the managment of data handlers
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 *
 * The idea is to define a common, generic data format that works for all data
 * structures supported by dygraphs. To make this possible, the DataHandler
 * interface is introduced. This makes it possible, that dygraph itself can work
 * with the same logic for every data type independent of the actual format and
 * the DataHandler takes care of the data format specific jobs.
 * DataHandlers are implemented for all data types supported by Dygraphs and
 * return Dygraphs compliant formats.
 * By default the correct DataHandler is chosen based on the options set.
 * Optionally the user may use his own DataHandler (similar to the plugin
 * system).
 *
 *
 * The unified data format returend by each handler is defined as so:
 * series[n][point] = [x,y,(extras)]
 *
 * This format contains the common basis that is needed to draw a simple line
 * series extended by optional extras for more complex graphing types. It
 * contains a primitive x value as first array entry, a primitive y value as
 * second array entry and an optional extras object for additional data needed.
 *
 * x must always be a number.
 * y must always be a number, NaN of type number or null.
 * extras is optional and must be interpreted by the DataHandler. It may be of
 * any type.
 *
 * In practice this might look something like this:
 * default: [x, yVal]
 * errorBar / customBar: [x, yVal, [yTopVariance, yBottomVariance] ]
 *
 */
/*global Dygraph:false */
/*global DygraphLayout:false */

"use strict";

/**
 *
 * The data handler is responsible for all data specific operations. All of the
 * series data it receives and returns is always in the unified data format.
 * Initially the unified data is created by the extractSeries method
 * @constructor
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
var DygraphDataHandler = function DygraphDataHandler() {};

var handler = DygraphDataHandler;

/**
 * X-value array index constant for unified data samples.
 * @const
 * @type {number}
 */
handler.X = 0;

/**
 * Y-value array index constant for unified data samples.
 * @const
 * @type {number}
 */
handler.Y = 1;

/**
 * Extras-value array index constant for unified data samples.
 * @const
 * @type {number}
 */
handler.EXTRAS = 2;

/**
 * Extracts one series from the raw data (a 2D array) into an array of the
 * unified data format.
 * This is where undesirable points (i.e. negative values on log scales and
 * missing values through which we wish to connect lines) are dropped.
 * TODO(danvk): the "missing values" bit above doesn't seem right.
 *
 * @param {!Array.<Array>} rawData The raw data passed into dygraphs where
 *     rawData[i] = [x,ySeries1,...,ySeriesN].
 * @param {!number} seriesIndex Index of the series to extract. All other
 *     series should be ignored.
 * @param {!DygraphOptions} options Dygraph options.
 * @return {Array.<[!number,?number,?]>} The series in the unified data format
 *     where series[i] = [x,y,{extras}].
 */
handler.prototype.extractSeries = function (rawData, seriesIndex, options) {};

/**
 * Converts a series to a Point array.  The resulting point array must be
 * returned in increasing order of idx property.
 *
 * @param {!Array.<[!number,?number,?]>} series The series in the unified
 *          data format where series[i] = [x,y,{extras}].
 * @param {!string} setName Name of the series.
 * @param {!number} boundaryIdStart Index offset of the first point, equal to the
 *          number of skipped points left of the date window minimum (if any).
 * @return {!Array.<Dygraph.PointType>} List of points for this series.
 */
handler.prototype.seriesToPoints = function (series, setName, boundaryIdStart) {
  // TODO(bhs): these loops are a hot-spot for high-point-count charts. In
  // fact,
  // on chrome+linux, they are 6 times more expensive than iterating through
  // the
  // points and drawing the lines. The brunt of the cost comes from allocating
  // the |point| structures.
  var points = [];
  for (var i = 0; i < series.length; ++i) {
    var item = series[i];
    var yraw = item[1];
    var yval = yraw === null ? null : handler.parseFloat(yraw);
    var point = {
      x: NaN,
      y: NaN,
      xval: handler.parseFloat(item[0]),
      yval: yval,
      name: setName, // TODO(danvk): is this really necessary?
      idx: i + boundaryIdStart
    };
    points.push(point);
  }
  this.onPointsCreated_(series, points);
  return points;
};

/**
 * Callback called for each series after the series points have been generated
 * which will later be used by the plotters to draw the graph.
 * Here data may be added to the seriesPoints which is needed by the plotters.
 * The indexes of series and points are in sync meaning the original data
 * sample for series[i] is points[i].
 *
 * @param {!Array.<[!number,?number,?]>} series The series in the unified
 *     data format where series[i] = [x,y,{extras}].
 * @param {!Array.<Dygraph.PointType>} points The corresponding points passed
 *     to the plotter.
 * @protected
 */
handler.prototype.onPointsCreated_ = function (series, points) {};

/**
 * Calculates the rolling average of a data set.
 *
 * @param {!Array.<[!number,?number,?]>} series The series in the unified
 *          data format where series[i] = [x,y,{extras}].
 * @param {!number} rollPeriod The number of points over which to average the data
 * @param {!DygraphOptions} options The dygraph options.
 * @return {!Array.<[!number,?number,?]>} the rolled series.
 */
handler.prototype.rollingAverage = function (series, rollPeriod, options) {};

/**
 * Computes the range of the data series (including confidence intervals).
 *
 * @param {!Array.<[!number,?number,?]>} series The series in the unified
 *     data format where series[i] = [x, y, {extras}].
 * @param {!Array.<number>} dateWindow The x-value range to display with
 *     the format: [min, max].
 * @param {!DygraphOptions} options The dygraph options.
 * @return {Array.<number>} The low and high extremes of the series in the
 *     given window with the format: [low, high].
 */
handler.prototype.getExtremeYValues = function (series, dateWindow, options) {};

/**
 * Callback called for each series after the layouting data has been
 * calculated before the series is drawn. Here normalized positioning data
 * should be calculated for the extras of each point.
 *
 * @param {!Array.<Dygraph.PointType>} points The points passed to
 *          the plotter.
 * @param {!Object} axis The axis on which the series will be plotted.
 * @param {!boolean} logscale Weather or not to use a logscale.
 */
handler.prototype.onLineEvaluated = function (points, axis, logscale) {};

/**
 * Optimized replacement for parseFloat, which was way too slow when almost
 * all values were type number, with few edge cases, none of which were strings.
 * @param {?number} val
 * @return {number}
 * @protected
 */
handler.parseFloat = function (val) {
  // parseFloat(null) is NaN
  if (val === null) {
    return NaN;
  }

  // Assume it's a number or NaN. If it's something else, I'll be shocked.
  return val;
};

exports["default"] = DygraphDataHandler;
module.exports = exports["default"];

},{}],7:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the fractions option.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _datahandler = require('./datahandler');

var _datahandler2 = _interopRequireDefault(_datahandler);

var _default = require('./default');

var _default2 = _interopRequireDefault(_default);

/**
 * @extends DefaultHandler
 * @constructor
 */
var DefaultFractionHandler = function DefaultFractionHandler() {};

DefaultFractionHandler.prototype = new _default2['default']();

DefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, point, num, den, value;
  var mult = 100.0;
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[1] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      num = point[0];
      den = point[1];
      if (num !== null && !isNaN(num)) {
        value = den ? num / den : 0.0;
        y = mult * value;
        // preserve original values in extras for further filtering
        series.push([x, y, [num, den]]);
      } else {
        series.push([x, num, [num, den]]);
      }
    } else {
      series.push([x, null, [null, null]]);
    }
  }
  return series;
};

DefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];

  var i;
  var num = 0;
  var den = 0; // numerator/denominator
  var mult = 100.0;
  for (i = 0; i < originalData.length; i++) {
    num += originalData[i][2][0];
    den += originalData[i][2][1];
    if (i - rollPeriod >= 0) {
      num -= originalData[i - rollPeriod][2][0];
      den -= originalData[i - rollPeriod][2][1];
    }

    var date = originalData[i][0];
    var value = den ? num / den : 0.0;
    rollingData[i] = [date, mult * value];
  }

  return rollingData;
};

exports['default'] = DefaultFractionHandler;
module.exports = exports['default'];

},{"./datahandler":6,"./default":8}],8:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler default implementation used for simple line charts.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _datahandler = require('./datahandler');

var _datahandler2 = _interopRequireDefault(_datahandler);

/**
 * @constructor
 * @extends Dygraph.DataHandler
 */
var DefaultHandler = function DefaultHandler() {};

DefaultHandler.prototype = new _datahandler2['default']();

/** @inheritDoc */
DefaultHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    var x = rawData[j][0];
    var point = rawData[j][i];
    if (logScale) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point <= 0) {
        point = null;
      }
    }
    series.push([x, point]);
  }
  return series;
};

/** @inheritDoc */
DefaultHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];

  var i, j, y, sum, num_ok;
  // Calculate the rolling average for the first rollPeriod - 1 points
  // where
  // there is not enough data to roll over the full number of points
  if (rollPeriod == 1) {
    return originalData;
  }
  for (i = 0; i < originalData.length; i++) {
    sum = 0;
    num_ok = 0;
    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {
      y = originalData[j][1];
      if (y === null || isNaN(y)) continue;
      num_ok++;
      sum += originalData[j][1];
    }
    if (num_ok) {
      rollingData[i] = [originalData[i][0], sum / num_ok];
    } else {
      rollingData[i] = [originalData[i][0], null];
    }
  }

  return rollingData;
};

/** @inheritDoc */
DefaultHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {
  var minY = null,
      maxY = null,
      y;
  var firstIdx = 0,
      lastIdx = series.length - 1;

  for (var j = firstIdx; j <= lastIdx; j++) {
    y = series[j][1];
    if (y === null || isNaN(y)) continue;
    if (maxY === null || y > maxY) {
      maxY = y;
    }
    if (minY === null || y < minY) {
      minY = y;
    }
  }
  return [minY, maxY];
};

exports['default'] = DefaultHandler;
module.exports = exports['default'];

},{"./datahandler":6}],9:[function(require,module,exports){
/**
 * @license
 * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the
 * needs of dygraphs.
 *
 * In particular, support for:
 * - grid overlays
 * - error bars
 * - dygraphs attribute system
 */

/**
 * The DygraphCanvasRenderer class does the actual rendering of the chart onto
 * a canvas. It's based on PlotKit.CanvasRenderer.
 * @param {Object} element The canvas to attach to
 * @param {Object} elementContext The 2d context of the canvas (injected so it
 * can be mocked for testing.)
 * @param {Layout} layout The DygraphLayout object for this graph.
 * @constructor
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

var _dygraph = require('./dygraph');

var _dygraph2 = _interopRequireDefault(_dygraph);

/**
 * @constructor
 *
 * This gets called when there are "new points" to chart. This is generally the
 * case when the underlying data being charted has changed. It is _not_ called
 * in the common case that the user has zoomed or is panning the view.
 *
 * The chart canvas has already been created by the Dygraph object. The
 * renderer simply gets a drawing context.
 *
 * @param {Dygraph} dygraph The chart to which this renderer belongs.
 * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.
 * @param {CanvasRenderingContext2D} elementContext The drawing context.
 * @param {DygraphLayout} layout The chart's DygraphLayout object.
 *
 * TODO(danvk): remove the elementContext property.
 */
var DygraphCanvasRenderer = function DygraphCanvasRenderer(dygraph, element, elementContext, layout) {
  this.dygraph_ = dygraph;

  this.layout = layout;
  this.element = element;
  this.elementContext = elementContext;

  this.height = dygraph.height_;
  this.width = dygraph.width_;

  // --- check whether everything is ok before we return
  if (!utils.isCanvasSupported(this.element)) {
    throw "Canvas is not supported.";
  }

  // internal state
  this.area = layout.getPlotArea();

  // Set up a clipping area for the canvas (and the interaction canvas).
  // This ensures that we don't overdraw.
  var ctx = this.dygraph_.canvas_ctx_;
  ctx.beginPath();
  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);
  ctx.clip();

  ctx = this.dygraph_.hidden_ctx_;
  ctx.beginPath();
  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);
  ctx.clip();
};

/**
 * Clears out all chart content and DOM elements.
 * This is called immediately before render() on every frame, including
 * during zooms and pans.
 * @private
 */
DygraphCanvasRenderer.prototype.clear = function () {
  this.elementContext.clearRect(0, 0, this.width, this.height);
};

/**
 * This method is responsible for drawing everything on the chart, including
 * lines, error bars, fills and axes.
 * It is called immediately after clear() on every frame, including during pans
 * and zooms.
 * @private
 */
DygraphCanvasRenderer.prototype.render = function () {
  // attaches point.canvas{x,y}
  this._updatePoints();

  // actually draws the chart.
  this._renderLineChart();
};

/**
 * Returns a predicate to be used with an iterator, which will
 * iterate over points appropriately, depending on whether
 * connectSeparatedPoints is true. When it's false, the predicate will
 * skip over points with missing yVals.
 */
DygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {
  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;
};

DygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {
  return array[idx].yval !== null;
};

/**
 * Draws a line with the styles passed in and calls all the drawPointCallbacks.
 * @param {Object} e The dictionary passed to the plotter function.
 * @private
 */
DygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {
  var g = e.dygraph;
  // TODO(konigsberg): Compute attributes outside this method call.
  var stepPlot = g.getBooleanOption("stepPlot", e.setName);

  if (!utils.isArrayLike(strokePattern)) {
    strokePattern = null;
  }

  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);

  var points = e.points;
  var setName = e.setName;
  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

  var stroking = strokePattern && strokePattern.length >= 2;

  var ctx = e.drawingContext;
  ctx.save();
  if (stroking) {
    if (ctx.setLineDash) ctx.setLineDash(strokePattern);
  }

  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);
  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);

  if (stroking) {
    if (ctx.setLineDash) ctx.setLineDash([]);
  }

  ctx.restore();
};

/**
 * This does the actual drawing of lines on the canvas, for just one series.
 * Returns a list of [canvasx, canvasy] pairs for points for which a
 * drawPointCallback should be fired.  These include isolated points, or all
 * points if drawPoints=true.
 * @param {Object} e The dictionary passed to the plotter function.
 * @private
 */
DygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {

  var prevCanvasX = null;
  var prevCanvasY = null;
  var nextCanvasY = null;
  var isIsolated; // true if this point is isolated (no line segments)
  var point; // the point being processed in the while loop
  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.
  var first = true; // the first cycle through the while loop

  var ctx = e.drawingContext;
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = strokeWidth;

  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.
  var arr = iter.array_;
  var limit = iter.end_;
  var predicate = iter.predicate_;

  for (var i = iter.start_; i < limit; i++) {
    point = arr[i];
    if (predicate) {
      while (i < limit && !predicate(arr, i)) {
        i++;
      }
      if (i == limit) break;
      point = arr[i];
    }

    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test
    // doesn't catch Infinity values. Could change this to
    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?
    if (point.canvasy === null || point.canvasy != point.canvasy) {
      if (stepPlot && prevCanvasX !== null) {
        // Draw a horizontal line to the start of the missing data
        ctx.moveTo(prevCanvasX, prevCanvasY);
        ctx.lineTo(point.canvasx, prevCanvasY);
      }
      prevCanvasX = prevCanvasY = null;
    } else {
      isIsolated = false;
      if (drawGapPoints || prevCanvasX === null) {
        iter.nextIdx_ = i;
        iter.next();
        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;

        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;
        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;
        if (drawGapPoints) {
          // Also consider a point to be "isolated" if it's adjacent to a
          // null point, excluding the graph edges.
          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {
            isIsolated = true;
          }
        }
      }

      if (prevCanvasX !== null) {
        if (strokeWidth) {
          if (stepPlot) {
            ctx.moveTo(prevCanvasX, prevCanvasY);
            ctx.lineTo(point.canvasx, prevCanvasY);
          }

          ctx.lineTo(point.canvasx, point.canvasy);
        }
      } else {
        ctx.moveTo(point.canvasx, point.canvasy);
      }
      if (drawPoints || isIsolated) {
        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);
      }
      prevCanvasX = point.canvasx;
      prevCanvasY = point.canvasy;
    }
    first = false;
  }
  ctx.stroke();
  return pointsOnLine;
};

/**
 * This fires the drawPointCallback functions, which draw dots on the points by
 * default. This gets used when the "drawPoints" option is set, or when there
 * are isolated points.
 * @param {Object} e The dictionary passed to the plotter function.
 * @private
 */
DygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {
  var ctx = e.drawingContext;
  for (var idx = 0; idx < pointsOnLine.length; idx++) {
    var cb = pointsOnLine[idx];
    ctx.save();
    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);
    ctx.restore();
  }
};

/**
 * Attaches canvas coordinates to the points array.
 * @private
 */
DygraphCanvasRenderer.prototype._updatePoints = function () {
  // Update Points
  // TODO(danvk): here
  //
  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These
  // transformations can be pushed into the canvas via linear transformation
  // matrices.
  // NOTE(danvk): this is trickier than it sounds at first. The transformation
  // needs to be done before the .moveTo() and .lineTo() calls, but must be
  // undone before the .stroke() call to ensure that the stroke width is
  // unaffected.  An alternative is to reduce the stroke width in the
  // transformed coordinate space, but you can't specify different values for
  // each dimension (as you can with .scale()). The speedup here is ~12%.
  var sets = this.layout.points;
  for (var i = sets.length; i--;) {
    var points = sets[i];
    for (var j = points.length; j--;) {
      var point = points[j];
      point.canvasx = this.area.w * point.x + this.area.x;
      point.canvasy = this.area.h * point.y + this.area.y;
    }
  }
};

/**
 * Add canvas Actually draw the lines chart, including error bars.
 *
 * This function can only be called if DygraphLayout's points array has been
 * updated with canvas{x,y} attributes, i.e. by
 * DygraphCanvasRenderer._updatePoints.
 *
 * @param {string=} opt_seriesName when specified, only that series will
 *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)
 * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing
 *     context.  However, lines are typically drawn on the object's
 *     elementContext.
 * @private
 */
DygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {
  var ctx = opt_ctx || this.elementContext;
  var i;

  var sets = this.layout.points;
  var setNames = this.layout.setNames;
  var setName;

  this.colors = this.dygraph_.colorsMap_;

  // Determine which series have specialized plotters.
  var plotter_attr = this.dygraph_.getOption("plotter");
  var plotters = plotter_attr;
  if (!utils.isArrayLike(plotters)) {
    plotters = [plotters];
  }

  var setPlotters = {}; // series name -> plotter fn.
  for (i = 0; i < setNames.length; i++) {
    setName = setNames[i];
    var setPlotter = this.dygraph_.getOption("plotter", setName);
    if (setPlotter == plotter_attr) continue; // not specialized.

    setPlotters[setName] = setPlotter;
  }

  for (i = 0; i < plotters.length; i++) {
    var plotter = plotters[i];
    var is_last = i == plotters.length - 1;

    for (var j = 0; j < sets.length; j++) {
      setName = setNames[j];
      if (opt_seriesName && setName != opt_seriesName) continue;

      var points = sets[j];

      // Only throw in the specialized plotters on the last iteration.
      var p = plotter;
      if (setName in setPlotters) {
        if (is_last) {
          p = setPlotters[setName];
        } else {
          // Don't use the standard plotters in this case.
          continue;
        }
      }

      var color = this.colors[setName];
      var strokeWidth = this.dygraph_.getOption("strokeWidth", setName);

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = strokeWidth;
      p({
        points: points,
        setName: setName,
        drawingContext: ctx,
        color: color,
        strokeWidth: strokeWidth,
        dygraph: this.dygraph_,
        axis: this.dygraph_.axisPropertiesForSeries(setName),
        plotArea: this.area,
        seriesIndex: j,
        seriesCount: sets.length,
        singleSeriesName: opt_seriesName,
        allSeriesPoints: sets
      });
      ctx.restore();
    }
  }
};

/**
 * Standard plotters. These may be used by clients via Dygraph.Plotters.
 * See comments there for more details.
 */
DygraphCanvasRenderer._Plotters = {
  linePlotter: function linePlotter(e) {
    DygraphCanvasRenderer._linePlotter(e);
  },

  fillPlotter: function fillPlotter(e) {
    DygraphCanvasRenderer._fillPlotter(e);
  },

  errorPlotter: function errorPlotter(e) {
    DygraphCanvasRenderer._errorPlotter(e);
  }
};

/**
 * Plotter which draws the central lines for a series.
 * @private
 */
DygraphCanvasRenderer._linePlotter = function (e) {
  var g = e.dygraph;
  var setName = e.setName;
  var strokeWidth = e.strokeWidth;

  // TODO(danvk): Check if there's any performance impact of just calling
  // getOption() inside of _drawStyledLine. Passing in so many parameters makes
  // this code a bit nasty.
  var borderWidth = g.getNumericOption("strokeBorderWidth", setName);
  var drawPointCallback = g.getOption("drawPointCallback", setName) || utils.Circles.DEFAULT;
  var strokePattern = g.getOption("strokePattern", setName);
  var drawPoints = g.getBooleanOption("drawPoints", setName);
  var pointSize = g.getNumericOption("pointSize", setName);

  if (borderWidth && strokeWidth) {
    DygraphCanvasRenderer._drawStyledLine(e, g.getOption("strokeBorderColor", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);
  }

  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);
};

/**
 * Draws the shaded error bars/confidence intervals for each series.
 * This happens before the center lines are drawn, since the center lines
 * need to be drawn on top of the error bars for all series.
 * @private
 */
DygraphCanvasRenderer._errorPlotter = function (e) {
  var g = e.dygraph;
  var setName = e.setName;
  var errorBars = g.getBooleanOption("errorBars") || g.getBooleanOption("customBars");
  if (!errorBars) return;

  var fillGraph = g.getBooleanOption("fillGraph", setName);
  if (fillGraph) {
    console.warn("Can't use fillGraph option with error bars");
  }

  var ctx = e.drawingContext;
  var color = e.color;
  var fillAlpha = g.getNumericOption('fillAlpha', setName);
  var stepPlot = g.getBooleanOption("stepPlot", setName);
  var points = e.points;

  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

  var newYs;

  // setup graphics context
  var prevX = NaN;
  var prevY = NaN;
  var prevYs = [-1, -1];
  // should be same color as the lines but only 15% opaque.
  var rgb = utils.toRGB_(color);
  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';
  ctx.fillStyle = err_color;
  ctx.beginPath();

  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(x) {
    return x === null || x === undefined || isNaN(x);
  };

  while (iter.hasNext) {
    var point = iter.next();
    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {
      prevX = NaN;
      continue;
    }

    newYs = [point.y_bottom, point.y_top];
    if (stepPlot) {
      prevY = point.y;
    }

    // The documentation specifically disallows nulls inside the point arrays,
    // but in case it happens we should do something sensible.
    if (isNaN(newYs[0])) newYs[0] = point.y;
    if (isNaN(newYs[1])) newYs[1] = point.y;

    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;
    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;
    if (!isNaN(prevX)) {
      if (stepPlot) {
        ctx.moveTo(prevX, prevYs[0]);
        ctx.lineTo(point.canvasx, prevYs[0]);
        ctx.lineTo(point.canvasx, prevYs[1]);
      } else {
        ctx.moveTo(prevX, prevYs[0]);
        ctx.lineTo(point.canvasx, newYs[0]);
        ctx.lineTo(point.canvasx, newYs[1]);
      }
      ctx.lineTo(prevX, prevYs[1]);
      ctx.closePath();
    }
    prevYs = newYs;
    prevX = point.canvasx;
  }
  ctx.fill();
};

/**
 * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are
 * superfluous. It accumulates all movements which haven't changed the x-value
 * and only applies the two with the most extreme y-values.
 *
 * Calls to lineTo/moveTo must have non-decreasing x-values.
 */
DygraphCanvasRenderer._fastCanvasProxy = function (context) {
  var pendingActions = []; // array of [type, x, y] tuples
  var lastRoundedX = null;
  var lastFlushedX = null;

  var LINE_TO = 1,
      MOVE_TO = 2;

  var actionCount = 0; // number of moveTos and lineTos passed to context.

  // Drop superfluous motions
  // Assumes all pendingActions have the same (rounded) x-value.
  var compressActions = function compressActions(opt_losslessOnly) {
    if (pendingActions.length <= 1) return;

    // Lossless compression: drop inconsequential moveTos.
    for (var i = pendingActions.length - 1; i > 0; i--) {
      var action = pendingActions[i];
      if (action[0] == MOVE_TO) {
        var prevAction = pendingActions[i - 1];
        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {
          pendingActions.splice(i, 1);
        }
      }
    }

    // Lossless compression: ... drop consecutive moveTos ...
    for (var i = 0; i < pendingActions.length - 1;) /* incremented internally */{
      var action = pendingActions[i];
      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {
        pendingActions.splice(i, 1);
      } else {
        i++;
      }
    }

    // Lossy compression: ... drop all but the extreme y-values ...
    if (pendingActions.length > 2 && !opt_losslessOnly) {
      // keep an initial moveTo, but drop all others.
      var startIdx = 0;
      if (pendingActions[0][0] == MOVE_TO) startIdx++;
      var minIdx = null,
          maxIdx = null;
      for (var i = startIdx; i < pendingActions.length; i++) {
        var action = pendingActions[i];
        if (action[0] != LINE_TO) continue;
        if (minIdx === null && maxIdx === null) {
          minIdx = i;
          maxIdx = i;
        } else {
          var y = action[2];
          if (y < pendingActions[minIdx][2]) {
            minIdx = i;
          } else if (y > pendingActions[maxIdx][2]) {
            maxIdx = i;
          }
        }
      }
      var minAction = pendingActions[minIdx],
          maxAction = pendingActions[maxIdx];
      pendingActions.splice(startIdx, pendingActions.length - startIdx);
      if (minIdx < maxIdx) {
        pendingActions.push(minAction);
        pendingActions.push(maxAction);
      } else if (minIdx > maxIdx) {
        pendingActions.push(maxAction);
        pendingActions.push(minAction);
      } else {
        pendingActions.push(minAction);
      }
    }
  };

  var flushActions = function flushActions(opt_noLossyCompression) {
    compressActions(opt_noLossyCompression);
    for (var i = 0, len = pendingActions.length; i < len; i++) {
      var action = pendingActions[i];
      if (action[0] == LINE_TO) {
        context.lineTo(action[1], action[2]);
      } else if (action[0] == MOVE_TO) {
        context.moveTo(action[1], action[2]);
      }
    }
    if (pendingActions.length) {
      lastFlushedX = pendingActions[pendingActions.length - 1][1];
    }
    actionCount += pendingActions.length;
    pendingActions = [];
  };

  var addAction = function addAction(action, x, y) {
    var rx = Math.round(x);
    if (lastRoundedX === null || rx != lastRoundedX) {
      // if there are large gaps on the x-axis, it's essential to keep the
      // first and last point as well.
      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,
          hasGapOnRight = rx - lastRoundedX > 1,
          hasGap = hasGapOnLeft || hasGapOnRight;
      flushActions(hasGap);
      lastRoundedX = rx;
    }
    pendingActions.push([action, x, y]);
  };

  return {
    moveTo: function moveTo(x, y) {
      addAction(MOVE_TO, x, y);
    },
    lineTo: function lineTo(x, y) {
      addAction(LINE_TO, x, y);
    },

    // for major operations like stroke/fill, we skip compression to ensure
    // that there are no artifacts at the right edge.
    stroke: function stroke() {
      flushActions(true);context.stroke();
    },
    fill: function fill() {
      flushActions(true);context.fill();
    },
    beginPath: function beginPath() {
      flushActions(true);context.beginPath();
    },
    closePath: function closePath() {
      flushActions(true);context.closePath();
    },

    _count: function _count() {
      return actionCount;
    }
  };
};

/**
 * Draws the shaded regions when "fillGraph" is set. Not to be confused with
 * error bars.
 *
 * For stacked charts, it's more convenient to handle all the series
 * simultaneously. So this plotter plots all the points on the first series
 * it's asked to draw, then ignores all the other series.
 *
 * @private
 */
DygraphCanvasRenderer._fillPlotter = function (e) {
  // Skip if we're drawing a single series for interactive highlight overlay.
  if (e.singleSeriesName) return;

  // We'll handle all the series at once, not one-by-one.
  if (e.seriesIndex !== 0) return;

  var g = e.dygraph;
  var setNames = g.getLabels().slice(1); // remove x-axis

  // getLabels() includes names for invisible series, which are not included in
  // allSeriesPoints. We remove those to make the two match.
  // TODO(danvk): provide a simpler way to get this information.
  for (var i = setNames.length; i >= 0; i--) {
    if (!g.visibility()[i]) setNames.splice(i, 1);
  }

  var anySeriesFilled = (function () {
    for (var i = 0; i < setNames.length; i++) {
      if (g.getBooleanOption("fillGraph", setNames[i])) return true;
    }
    return false;
  })();

  if (!anySeriesFilled) return;

  var area = e.plotArea;
  var sets = e.allSeriesPoints;
  var setCount = sets.length;

  var stackedGraph = g.getBooleanOption("stackedGraph");
  var colors = g.getColors();

  // For stacked graphs, track the baseline for filling.
  //
  // The filled areas below graph lines are trapezoids with two
  // vertical edges. The top edge is the line segment being drawn, and
  // the baseline is the bottom edge. Each baseline corresponds to the
  // top line segment from the previous stacked line. In the case of
  // step plots, the trapezoids are rectangles.
  var baseline = {};
  var currBaseline;
  var prevStepPlot; // for different line drawing modes (line/step) per series

  // Helper function to trace a line back along the baseline.
  var traceBackPath = function traceBackPath(ctx, baselineX, baselineY, pathBack) {
    ctx.lineTo(baselineX, baselineY);
    if (stackedGraph) {
      for (var i = pathBack.length - 1; i >= 0; i--) {
        var pt = pathBack[i];
        ctx.lineTo(pt[0], pt[1]);
      }
    }
  };

  // process sets in reverse order (needed for stacked graphs)
  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {
    var ctx = e.drawingContext;
    var setName = setNames[setIdx];
    if (!g.getBooleanOption('fillGraph', setName)) continue;

    var fillAlpha = g.getNumericOption('fillAlpha', setName);
    var stepPlot = g.getBooleanOption('stepPlot', setName);
    var color = colors[setIdx];
    var axis = g.axisPropertiesForSeries(setName);
    var axisY = 1.0 + axis.minyval * axis.yscale;
    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;
    axisY = area.h * axisY + area.y;

    var points = sets[setIdx];
    var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

    // setup graphics context
    var prevX = NaN;
    var prevYs = [-1, -1];
    var newYs;
    // should be same color as the lines but only 15% opaque.
    var rgb = utils.toRGB_(color);
    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';
    ctx.fillStyle = err_color;
    ctx.beginPath();
    var last_x,
        is_first = true;

    // If the point density is high enough, dropping segments on their way to
    // the canvas justifies the overhead of doing so.
    if (points.length > 2 * g.width_ || _dygraph2['default'].FORCE_FAST_PROXY) {
      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);
    }

    // For filled charts, we draw points from left to right, then back along
    // the x-axis to complete a shape for filling.
    // For stacked plots, this "back path" is a more complex shape. This array
    // stores the [x, y] values needed to trace that shape.
    var pathBack = [];

    // TODO(danvk): there are a lot of options at play in this loop.
    //     The logic would be much clearer if some (e.g. stackGraph and
    //     stepPlot) were split off into separate sub-plotters.
    var point;
    while (iter.hasNext) {
      point = iter.next();
      if (!utils.isOK(point.y) && !stepPlot) {
        traceBackPath(ctx, prevX, prevYs[1], pathBack);
        pathBack = [];
        prevX = NaN;
        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {
          baseline[point.canvasx] = area.h * point.y_stacked + area.y;
        }
        continue;
      }
      if (stackedGraph) {
        if (!is_first && last_x == point.xval) {
          continue;
        } else {
          is_first = false;
          last_x = point.xval;
        }

        currBaseline = baseline[point.canvasx];
        var lastY;
        if (currBaseline === undefined) {
          lastY = axisY;
        } else {
          if (prevStepPlot) {
            lastY = currBaseline[0];
          } else {
            lastY = currBaseline;
          }
        }
        newYs = [point.canvasy, lastY];

        if (stepPlot) {
          // Step plots must keep track of the top and bottom of
          // the baseline at each point.
          if (prevYs[0] === -1) {
            baseline[point.canvasx] = [point.canvasy, axisY];
          } else {
            baseline[point.canvasx] = [point.canvasy, prevYs[0]];
          }
        } else {
          baseline[point.canvasx] = point.canvasy;
        }
      } else {
        if (isNaN(point.canvasy) && stepPlot) {
          newYs = [area.y + area.h, axisY];
        } else {
          newYs = [point.canvasy, axisY];
        }
      }
      if (!isNaN(prevX)) {
        // Move to top fill point
        if (stepPlot) {
          ctx.lineTo(point.canvasx, prevYs[0]);
          ctx.lineTo(point.canvasx, newYs[0]);
        } else {
          ctx.lineTo(point.canvasx, newYs[0]);
        }

        // Record the baseline for the reverse path.
        if (stackedGraph) {
          pathBack.push([prevX, prevYs[1]]);
          if (prevStepPlot && currBaseline) {
            // Draw to the bottom of the baseline
            pathBack.push([point.canvasx, currBaseline[1]]);
          } else {
            pathBack.push([point.canvasx, newYs[1]]);
          }
        }
      } else {
        ctx.moveTo(point.canvasx, newYs[1]);
        ctx.lineTo(point.canvasx, newYs[0]);
      }
      prevYs = newYs;
      prevX = point.canvasx;
    }
    prevStepPlot = stepPlot;
    if (newYs && point) {
      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);
      pathBack = [];
    }
    ctx.fill();
  }
};

exports['default'] = DygraphCanvasRenderer;
module.exports = exports['default'];

},{"./dygraph":18,"./dygraph-utils":17}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphTickers = require('./dygraph-tickers');

var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

var _dygraphInteractionModel = require('./dygraph-interaction-model');

var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

var _dygraphCanvas = require('./dygraph-canvas');

var _dygraphCanvas2 = _interopRequireDefault(_dygraphCanvas);

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

// Default attribute values.
var DEFAULT_ATTRS = {
  highlightCircleSize: 3,
  highlightSeriesOpts: null,
  highlightSeriesBackgroundAlpha: 0.5,
  highlightSeriesBackgroundColor: 'rgb(255, 255, 255)',

  labelsSeparateLines: false,
  labelsShowZeroValues: true,
  labelsKMB: false,
  labelsKMG2: false,
  showLabelsOnHighlight: true,

  digitsAfterDecimal: 2,
  maxNumberWidth: 6,
  sigFigs: null,

  strokeWidth: 1.0,
  strokeBorderWidth: 0,
  strokeBorderColor: "white",

  axisTickSize: 3,
  axisLabelFontSize: 14,
  rightGap: 5,

  showRoller: false,
  xValueParser: undefined,

  delimiter: ',',

  sigma: 2.0,
  errorBars: false,
  fractions: false,
  wilsonInterval: true, // only relevant if fractions is true
  customBars: false,
  fillGraph: false,
  fillAlpha: 0.15,
  connectSeparatedPoints: false,

  stackedGraph: false,
  stackedGraphNaNFill: 'all',
  hideOverlayOnMouseOut: true,

  legend: 'onmouseover',
  stepPlot: false,
  xRangePad: 0,
  yRangePad: null,
  drawAxesAtZero: false,

  // Sizes of the various chart labels.
  titleHeight: 28,
  xLabelHeight: 18,
  yLabelWidth: 18,

  axisLineColor: "black",
  axisLineWidth: 0.3,
  gridLineWidth: 0.3,
  axisLabelWidth: 50,
  gridLineColor: "rgb(128,128,128)",

  interactionModel: _dygraphInteractionModel2['default'].defaultModel,
  animatedZooms: false, // (for now)

  // Range selector options
  showRangeSelector: false,
  rangeSelectorHeight: 40,
  rangeSelectorPlotStrokeColor: "#808FAB",
  rangeSelectorPlotFillGradientColor: "white",
  rangeSelectorPlotFillColor: "#A7B1C4",
  rangeSelectorBackgroundStrokeColor: "gray",
  rangeSelectorBackgroundLineWidth: 1,
  rangeSelectorPlotLineWidth: 1.5,
  rangeSelectorForegroundStrokeColor: "black",
  rangeSelectorForegroundLineWidth: 1,
  rangeSelectorAlpha: 0.6,
  showInRangeSelector: null,

  // The ordering here ensures that central lines always appear above any
  // fill bars/error bars.
  plotter: [_dygraphCanvas2['default']._fillPlotter, _dygraphCanvas2['default']._errorPlotter, _dygraphCanvas2['default']._linePlotter],

  plugins: [],

  // per-axis options
  axes: {
    x: {
      pixelsPerLabel: 70,
      axisLabelWidth: 60,
      axisLabelFormatter: utils.dateAxisLabelFormatter,
      valueFormatter: utils.dateValueFormatter,
      drawGrid: true,
      drawAxis: true,
      independentTicks: true,
      ticker: DygraphTickers.dateTicker
    },
    y: {
      axisLabelWidth: 50,
      pixelsPerLabel: 30,
      valueFormatter: utils.numberValueFormatter,
      axisLabelFormatter: utils.numberAxisLabelFormatter,
      drawGrid: true,
      drawAxis: true,
      independentTicks: true,
      ticker: DygraphTickers.numericTicks
    },
    y2: {
      axisLabelWidth: 50,
      pixelsPerLabel: 30,
      valueFormatter: utils.numberValueFormatter,
      axisLabelFormatter: utils.numberAxisLabelFormatter,
      drawAxis: true, // only applies when there are two axes of data.
      drawGrid: false,
      independentTicks: false,
      ticker: DygraphTickers.numericTicks
    }
  }
};

exports['default'] = DEFAULT_ATTRS;
module.exports = exports['default'];

},{"./dygraph-canvas":9,"./dygraph-interaction-model":12,"./dygraph-tickers":16,"./dygraph-utils":17}],11:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview A wrapper around the Dygraph class which implements the
 * interface for a GViz (aka Google Visualization API) visualization.
 * It is designed to be a drop-in replacement for Google's AnnotatedTimeline,
 * so the documentation at
 * http://code.google.com/apis/chart/interactive/docs/gallery/annotatedtimeline.html
 * translates over directly.
 *
 * For a full demo, see:
 * - http://dygraphs.com/tests/gviz.html
 * - http://dygraphs.com/tests/annotation-gviz.html
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _dygraph = require('./dygraph');

var _dygraph2 = _interopRequireDefault(_dygraph);

/**
 * A wrapper around Dygraph that implements the gviz API.
 * @param {!HTMLDivElement} container The DOM object the visualization should
 *     live in.
 * @constructor
 */
var GVizChart = function GVizChart(container) {
  this.container = container;
};

/**
 * @param {GVizDataTable} data
 * @param {Object.<*>} options
 */
GVizChart.prototype.draw = function (data, options) {
  // Clear out any existing dygraph.
  // TODO(danvk): would it make more sense to simply redraw using the current
  // date_graph object?
  this.container.innerHTML = '';
  if (typeof this.date_graph != 'undefined') {
    this.date_graph.destroy();
  }

  this.date_graph = new _dygraph2['default'](this.container, data, options);
};

/**
 * Google charts compatible setSelection
 * Only row selection is supported, all points in the row will be highlighted
 * @param {Array.<{row:number}>} selection_array array of the selected cells
 * @public
 */
GVizChart.prototype.setSelection = function (selection_array) {
  var row = false;
  if (selection_array.length) {
    row = selection_array[0].row;
  }
  this.date_graph.setSelection(row);
};

/**
 * Google charts compatible getSelection implementation
 * @return {Array.<{row:number,column:number}>} array of the selected cells
 * @public
 */
GVizChart.prototype.getSelection = function () {
  var selection = [];

  var row = this.date_graph.getSelection();

  if (row < 0) return selection;

  var points = this.date_graph.layout_.points;
  for (var setIdx = 0; setIdx < points.length; ++setIdx) {
    selection.push({ row: row, column: setIdx + 1 });
  }

  return selection;
};

exports['default'] = GVizChart;
module.exports = exports['default'];

},{"./dygraph":18}],12:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Robert Konigsberg (konigsberg@google.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview The default interaction model for Dygraphs. This is kept out
 * of dygraph.js for better navigability.
 * @author Robert Konigsberg (konigsberg@google.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * You can drag this many pixels past the edge of the chart and still have it
 * be considered a zoom. This makes it easier to zoom to the exact edge of the
 * chart, a fairly common operation.
 */
var DRAG_EDGE_MARGIN = 100;

/**
 * A collection of functions to facilitate build custom interaction models.
 * @class
 */
var DygraphInteraction = {};

/**
 * Checks whether the beginning & ending of an event were close enough that it
 * should be considered a click. If it should, dispatch appropriate events.
 * Returns true if the event was treated as a click.
 *
 * @param {Event} event
 * @param {Dygraph} g
 * @param {Object} context
 */
DygraphInteraction.maybeTreatMouseOpAsClick = function (event, g, context) {
  context.dragEndX = utils.dragGetX_(event, context);
  context.dragEndY = utils.dragGetY_(event, context);
  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);
  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);

  if (regionWidth < 2 && regionHeight < 2 && g.lastx_ !== undefined && g.lastx_ != -1) {
    DygraphInteraction.treatMouseOpAsClick(g, event, context);
  }

  context.regionWidth = regionWidth;
  context.regionHeight = regionHeight;
};

/**
 * Called in response to an interaction model operation that
 * should start the default panning behavior.
 *
 * It's used in the default callback for "mousedown" operations.
 * Custom interaction model builders can use it to provide the default
 * panning behavior.
 *
 * @param {Event} event the event object which led to the startPan call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.startPan = function (event, g, context) {
  var i, axis;
  context.isPanning = true;
  var xRange = g.xAxisRange();

  if (g.getOptionForAxis("logscale", "x")) {
    context.initialLeftmostDate = utils.log10(xRange[0]);
    context.dateRange = utils.log10(xRange[1]) - utils.log10(xRange[0]);
  } else {
    context.initialLeftmostDate = xRange[0];
    context.dateRange = xRange[1] - xRange[0];
  }
  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);

  if (g.getNumericOption("panEdgeFraction")) {
    var maxXPixelsToDraw = g.width_ * g.getNumericOption("panEdgeFraction");
    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!

    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;
    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;

    var boundedLeftDate = g.toDataXCoord(boundedLeftX);
    var boundedRightDate = g.toDataXCoord(boundedRightX);
    context.boundedDates = [boundedLeftDate, boundedRightDate];

    var boundedValues = [];
    var maxYPixelsToDraw = g.height_ * g.getNumericOption("panEdgeFraction");

    for (i = 0; i < g.axes_.length; i++) {
      axis = g.axes_[i];
      var yExtremes = axis.extremeRange;

      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;
      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;

      var boundedTopValue = g.toDataYCoord(boundedTopY, i);
      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);

      boundedValues[i] = [boundedTopValue, boundedBottomValue];
    }
    context.boundedValues = boundedValues;
  }

  // Record the range of each y-axis at the start of the drag.
  // If any axis has a valueRange, then we want a 2D pan.
  // We can't store data directly in g.axes_, because it does not belong to us
  // and could change out from under us during a pan (say if there's a data
  // update).
  context.is2DPan = false;
  context.axes = [];
  for (i = 0; i < g.axes_.length; i++) {
    axis = g.axes_[i];
    var axis_data = {};
    var yRange = g.yAxisRange(i);
    // TODO(konigsberg): These values should be in |context|.
    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.
    var logscale = g.attributes_.getForAxis("logscale", i);
    if (logscale) {
      axis_data.initialTopValue = utils.log10(yRange[1]);
      axis_data.dragValueRange = utils.log10(yRange[1]) - utils.log10(yRange[0]);
    } else {
      axis_data.initialTopValue = yRange[1];
      axis_data.dragValueRange = yRange[1] - yRange[0];
    }
    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);
    context.axes.push(axis_data);

    // While calculating axes, set 2dpan.
    if (axis.valueRange) context.is2DPan = true;
  }
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that pans the view.
 *
 * It's used in the default callback for "mousemove" operations.
 * Custom interaction model builders can use it to provide the default
 * panning behavior.
 *
 * @param {Event} event the event object which led to the movePan call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.movePan = function (event, g, context) {
  context.dragEndX = utils.dragGetX_(event, context);
  context.dragEndY = utils.dragGetY_(event, context);

  var minDate = context.initialLeftmostDate - (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;
  if (context.boundedDates) {
    minDate = Math.max(minDate, context.boundedDates[0]);
  }
  var maxDate = minDate + context.dateRange;
  if (context.boundedDates) {
    if (maxDate > context.boundedDates[1]) {
      // Adjust minDate, and recompute maxDate.
      minDate = minDate - (maxDate - context.boundedDates[1]);
      maxDate = minDate + context.dateRange;
    }
  }

  if (g.getOptionForAxis("logscale", "x")) {
    g.dateWindow_ = [Math.pow(utils.LOG_SCALE, minDate), Math.pow(utils.LOG_SCALE, maxDate)];
  } else {
    g.dateWindow_ = [minDate, maxDate];
  }

  // y-axis scaling is automatic unless this is a full 2D pan.
  if (context.is2DPan) {

    var pixelsDragged = context.dragEndY - context.dragStartY;

    // Adjust each axis appropriately.
    for (var i = 0; i < g.axes_.length; i++) {
      var axis = g.axes_[i];
      var axis_data = context.axes[i];
      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;

      var boundedValue = context.boundedValues ? context.boundedValues[i] : null;

      // In log scale, maxValue and minValue are the logs of those values.
      var maxValue = axis_data.initialTopValue + unitsDragged;
      if (boundedValue) {
        maxValue = Math.min(maxValue, boundedValue[1]);
      }
      var minValue = maxValue - axis_data.dragValueRange;
      if (boundedValue) {
        if (minValue < boundedValue[0]) {
          // Adjust maxValue, and recompute minValue.
          maxValue = maxValue - (minValue - boundedValue[0]);
          minValue = maxValue - axis_data.dragValueRange;
        }
      }
      if (g.attributes_.getForAxis("logscale", i)) {
        axis.valueRange = [Math.pow(utils.LOG_SCALE, minValue), Math.pow(utils.LOG_SCALE, maxValue)];
      } else {
        axis.valueRange = [minValue, maxValue];
      }
    }
  }

  g.drawGraph_(false);
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that ends panning.
 *
 * It's used in the default callback for "mouseup" operations.
 * Custom interaction model builders can use it to provide the default
 * panning behavior.
 *
 * @param {Event} event the event object which led to the endPan call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;

/**
 * Called in response to an interaction model operation that
 * responds to an event that starts zooming.
 *
 * It's used in the default callback for "mousedown" operations.
 * Custom interaction model builders can use it to provide the default
 * zooming behavior.
 *
 * @param {Event} event the event object which led to the startZoom call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.startZoom = function (event, g, context) {
  context.isZooming = true;
  context.zoomMoved = false;
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that defines zoom boundaries.
 *
 * It's used in the default callback for "mousemove" operations.
 * Custom interaction model builders can use it to provide the default
 * zooming behavior.
 *
 * @param {Event} event the event object which led to the moveZoom call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.moveZoom = function (event, g, context) {
  context.zoomMoved = true;
  context.dragEndX = utils.dragGetX_(event, context);
  context.dragEndY = utils.dragGetY_(event, context);

  var xDelta = Math.abs(context.dragStartX - context.dragEndX);
  var yDelta = Math.abs(context.dragStartY - context.dragEndY);

  // drag direction threshold for y axis is twice as large as x axis
  context.dragDirection = xDelta < yDelta / 2 ? utils.VERTICAL : utils.HORIZONTAL;

  g.drawZoomRect_(context.dragDirection, context.dragStartX, context.dragEndX, context.dragStartY, context.dragEndY, context.prevDragDirection, context.prevEndX, context.prevEndY);

  context.prevEndX = context.dragEndX;
  context.prevEndY = context.dragEndY;
  context.prevDragDirection = context.dragDirection;
};

/**
 * TODO(danvk): move this logic into dygraph.js
 * @param {Dygraph} g
 * @param {Event} event
 * @param {Object} context
 */
DygraphInteraction.treatMouseOpAsClick = function (g, event, context) {
  var clickCallback = g.getFunctionOption('clickCallback');
  var pointClickCallback = g.getFunctionOption('pointClickCallback');

  var selectedPoint = null;

  // Find out if the click occurs on a point.
  var closestIdx = -1;
  var closestDistance = Number.MAX_VALUE;

  // check if the click was on a particular point.
  for (var i = 0; i < g.selPoints_.length; i++) {
    var p = g.selPoints_[i];
    var distance = Math.pow(p.canvasx - context.dragEndX, 2) + Math.pow(p.canvasy - context.dragEndY, 2);
    if (!isNaN(distance) && (closestIdx == -1 || distance < closestDistance)) {
      closestDistance = distance;
      closestIdx = i;
    }
  }

  // Allow any click within two pixels of the dot.
  var radius = g.getNumericOption('highlightCircleSize') + 2;
  if (closestDistance <= radius * radius) {
    selectedPoint = g.selPoints_[closestIdx];
  }

  if (selectedPoint) {
    var e = {
      cancelable: true,
      point: selectedPoint,
      canvasx: context.dragEndX,
      canvasy: context.dragEndY
    };
    var defaultPrevented = g.cascadeEvents_('pointClick', e);
    if (defaultPrevented) {
      // Note: this also prevents click / clickCallback from firing.
      return;
    }
    if (pointClickCallback) {
      pointClickCallback.call(g, event, selectedPoint);
    }
  }

  var e = {
    cancelable: true,
    xval: g.lastx_, // closest point by x value
    pts: g.selPoints_,
    canvasx: context.dragEndX,
    canvasy: context.dragEndY
  };
  if (!g.cascadeEvents_('click', e)) {
    if (clickCallback) {
      // TODO(danvk): pass along more info about the points, e.g. 'x'
      clickCallback.call(g, event, g.lastx_, g.selPoints_);
    }
  }
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that performs a zoom based on previously defined
 * bounds..
 *
 * It's used in the default callback for "mouseup" operations.
 * Custom interaction model builders can use it to provide the default
 * zooming behavior.
 *
 * @param {Event} event the event object which led to the endZoom call.
 * @param {Dygraph} g The dygraph on which to end the zoom.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.endZoom = function (event, g, context) {
  g.clearZoomRect_();
  context.isZooming = false;
  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);

  // The zoom rectangle is visibly clipped to the plot area, so its behavior
  // should be as well.
  // See http://code.google.com/p/dygraphs/issues/detail?id=280
  var plotArea = g.getArea();
  if (context.regionWidth >= 10 && context.dragDirection == utils.HORIZONTAL) {
    var left = Math.min(context.dragStartX, context.dragEndX),
        right = Math.max(context.dragStartX, context.dragEndX);
    left = Math.max(left, plotArea.x);
    right = Math.min(right, plotArea.x + plotArea.w);
    if (left < right) {
      g.doZoomX_(left, right);
    }
    context.cancelNextDblclick = true;
  } else if (context.regionHeight >= 10 && context.dragDirection == utils.VERTICAL) {
    var top = Math.min(context.dragStartY, context.dragEndY),
        bottom = Math.max(context.dragStartY, context.dragEndY);
    top = Math.max(top, plotArea.y);
    bottom = Math.min(bottom, plotArea.y + plotArea.h);
    if (top < bottom) {
      g.doZoomY_(top, bottom);
    }
    context.cancelNextDblclick = true;
  }
  context.dragStartX = null;
  context.dragStartY = null;
};

/**
 * @private
 */
DygraphInteraction.startTouch = function (event, g, context) {
  event.preventDefault(); // touch browsers are all nice.
  if (event.touches.length > 1) {
    // If the user ever puts two fingers down, it's not a double tap.
    context.startTimeForDoubleTapMs = null;
  }

  var touches = [];
  for (var i = 0; i < event.touches.length; i++) {
    var t = event.touches[i];
    // we dispense with 'dragGetX_' because all touchBrowsers support pageX
    touches.push({
      pageX: t.pageX,
      pageY: t.pageY,
      dataX: g.toDataXCoord(t.pageX),
      dataY: g.toDataYCoord(t.pageY)
      // identifier: t.identifier
    });
  }
  context.initialTouches = touches;

  if (touches.length == 1) {
    // This is just a swipe.
    context.initialPinchCenter = touches[0];
    context.touchDirections = { x: true, y: true };
  } else if (touches.length >= 2) {
    // It's become a pinch!
    // In case there are 3+ touches, we ignore all but the "first" two.

    // only screen coordinates can be averaged (data coords could be log scale).
    context.initialPinchCenter = {
      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),
      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),

      // TODO(danvk): remove
      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),
      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)
    };

    // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.
    var initialAngle = 180 / Math.PI * Math.atan2(context.initialPinchCenter.pageY - touches[0].pageY, touches[0].pageX - context.initialPinchCenter.pageX);

    // use symmetry to get it into the first quadrant.
    initialAngle = Math.abs(initialAngle);
    if (initialAngle > 90) initialAngle = 90 - initialAngle;

    context.touchDirections = {
      x: initialAngle < 90 - 45 / 2,
      y: initialAngle > 45 / 2
    };
  }

  // save the full x & y ranges.
  context.initialRange = {
    x: g.xAxisRange(),
    y: g.yAxisRange()
  };
};

/**
 * @private
 */
DygraphInteraction.moveTouch = function (event, g, context) {
  // If the tap moves, then it's definitely not part of a double-tap.
  context.startTimeForDoubleTapMs = null;

  var i,
      touches = [];
  for (i = 0; i < event.touches.length; i++) {
    var t = event.touches[i];
    touches.push({
      pageX: t.pageX,
      pageY: t.pageY
    });
  }
  var initialTouches = context.initialTouches;

  var c_now;

  // old and new centers.
  var c_init = context.initialPinchCenter;
  if (touches.length == 1) {
    c_now = touches[0];
  } else {
    c_now = {
      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),
      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)
    };
  }

  // this is the "swipe" component
  // we toss it out for now, but could use it in the future.
  var swipe = {
    pageX: c_now.pageX - c_init.pageX,
    pageY: c_now.pageY - c_init.pageY
  };
  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];
  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];
  swipe.dataX = swipe.pageX / g.plotter_.area.w * dataWidth;
  swipe.dataY = swipe.pageY / g.plotter_.area.h * dataHeight;
  var xScale, yScale;

  // The residual bits are usually split into scale & rotate bits, but we split
  // them into x-scale and y-scale bits.
  if (touches.length == 1) {
    xScale = 1.0;
    yScale = 1.0;
  } else if (touches.length >= 2) {
    var initHalfWidth = initialTouches[1].pageX - c_init.pageX;
    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;

    var initHalfHeight = initialTouches[1].pageY - c_init.pageY;
    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;
  }

  // Clip scaling to [1/8, 8] to prevent too much blowup.
  xScale = Math.min(8, Math.max(0.125, xScale));
  yScale = Math.min(8, Math.max(0.125, yScale));

  var didZoom = false;
  if (context.touchDirections.x) {
    g.dateWindow_ = [c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale, c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale];
    didZoom = true;
  }

  if (context.touchDirections.y) {
    for (i = 0; i < 1 /*g.axes_.length*/; i++) {
      var axis = g.axes_[i];
      var logscale = g.attributes_.getForAxis("logscale", i);
      if (logscale) {
        // TODO(danvk): implement
      } else {
          axis.valueRange = [c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale, c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale];
          didZoom = true;
        }
    }
  }

  g.drawGraph_(false);

  // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.
  if (didZoom && touches.length > 1 && g.getFunctionOption('zoomCallback')) {
    var viewWindow = g.xAxisRange();
    g.getFunctionOption("zoomCallback").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());
  }
};

/**
 * @private
 */
DygraphInteraction.endTouch = function (event, g, context) {
  if (event.touches.length !== 0) {
    // this is effectively a "reset"
    DygraphInteraction.startTouch(event, g, context);
  } else if (event.changedTouches.length == 1) {
    // Could be part of a "double tap"
    // The heuristic here is that it's a double-tap if the two touchend events
    // occur within 500ms and within a 50x50 pixel box.
    var now = new Date().getTime();
    var t = event.changedTouches[0];
    if (context.startTimeForDoubleTapMs && now - context.startTimeForDoubleTapMs < 500 && context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 && context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {
      g.resetZoom();
    } else {
      context.startTimeForDoubleTapMs = now;
      context.doubleTapX = t.screenX;
      context.doubleTapY = t.screenY;
    }
  }
};

// Determine the distance from x to [left, right].
var distanceFromInterval = function distanceFromInterval(x, left, right) {
  if (x < left) {
    return left - x;
  } else if (x > right) {
    return x - right;
  } else {
    return 0;
  }
};

/**
 * Returns the number of pixels by which the event happens from the nearest
 * edge of the chart. For events in the interior of the chart, this returns zero.
 */
var distanceFromChart = function distanceFromChart(event, g) {
  var chartPos = utils.findPos(g.canvas_);
  var box = {
    left: chartPos.x,
    right: chartPos.x + g.canvas_.offsetWidth,
    top: chartPos.y,
    bottom: chartPos.y + g.canvas_.offsetHeight
  };

  var pt = {
    x: utils.pageX(event),
    y: utils.pageY(event)
  };

  var dx = distanceFromInterval(pt.x, box.left, box.right),
      dy = distanceFromInterval(pt.y, box.top, box.bottom);
  return Math.max(dx, dy);
};

/**
 * Default interation model for dygraphs. You can refer to specific elements of
 * this when constructing your own interaction model, e.g.:
 * g.updateOptions( {
 *   interactionModel: {
 *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown
 *   }
 * } );
 */
DygraphInteraction.defaultModel = {
  // Track the beginning of drag events
  mousedown: function mousedown(event, g, context) {
    // Right-click should not initiate a zoom.
    if (event.button && event.button == 2) return;

    context.initializeMouseDown(event, g, context);

    if (event.altKey || event.shiftKey) {
      DygraphInteraction.startPan(event, g, context);
    } else {
      DygraphInteraction.startZoom(event, g, context);
    }

    // Note: we register mousemove/mouseup on document to allow some leeway for
    // events to move outside of the chart. Interaction model events get
    // registered on the canvas, which is too small to allow this.
    var mousemove = function mousemove(event) {
      if (context.isZooming) {
        // When the mouse moves >200px from the chart edge, cancel the zoom.
        var d = distanceFromChart(event, g);
        if (d < DRAG_EDGE_MARGIN) {
          DygraphInteraction.moveZoom(event, g, context);
        } else {
          if (context.dragEndX !== null) {
            context.dragEndX = null;
            context.dragEndY = null;
            g.clearZoomRect_();
          }
        }
      } else if (context.isPanning) {
        DygraphInteraction.movePan(event, g, context);
      }
    };
    var mouseup = function mouseup(event) {
      if (context.isZooming) {
        if (context.dragEndX !== null) {
          DygraphInteraction.endZoom(event, g, context);
        } else {
          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);
        }
      } else if (context.isPanning) {
        DygraphInteraction.endPan(event, g, context);
      }

      utils.removeEvent(document, 'mousemove', mousemove);
      utils.removeEvent(document, 'mouseup', mouseup);
      context.destroy();
    };

    g.addAndTrackEvent(document, 'mousemove', mousemove);
    g.addAndTrackEvent(document, 'mouseup', mouseup);
  },
  willDestroyContextMyself: true,

  touchstart: function touchstart(event, g, context) {
    DygraphInteraction.startTouch(event, g, context);
  },
  touchmove: function touchmove(event, g, context) {
    DygraphInteraction.moveTouch(event, g, context);
  },
  touchend: function touchend(event, g, context) {
    DygraphInteraction.endTouch(event, g, context);
  },

  // Disable zooming out if panning.
  dblclick: function dblclick(event, g, context) {
    if (context.cancelNextDblclick) {
      context.cancelNextDblclick = false;
      return;
    }

    // Give plugins a chance to grab this event.
    var e = {
      canvasx: context.dragEndX,
      canvasy: context.dragEndY,
      cancelable: true
    };
    if (g.cascadeEvents_('dblclick', e)) {
      return;
    }

    if (event.altKey || event.shiftKey) {
      return;
    }
    g.resetZoom();
  }
};

/*
Dygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;

// old ways of accessing these methods/properties
Dygraph.defaultInteractionModel = DygraphInteraction.defaultModel;
Dygraph.endZoom = DygraphInteraction.endZoom;
Dygraph.moveZoom = DygraphInteraction.moveZoom;
Dygraph.startZoom = DygraphInteraction.startZoom;
Dygraph.endPan = DygraphInteraction.endPan;
Dygraph.movePan = DygraphInteraction.movePan;
Dygraph.startPan = DygraphInteraction.startPan;
*/

DygraphInteraction.nonInteractiveModel_ = {
  mousedown: function mousedown(event, g, context) {
    context.initializeMouseDown(event, g, context);
  },
  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick
};

// Default interaction model when using the range selector.
DygraphInteraction.dragIsPanInteractionModel = {
  mousedown: function mousedown(event, g, context) {
    context.initializeMouseDown(event, g, context);
    DygraphInteraction.startPan(event, g, context);
  },
  mousemove: function mousemove(event, g, context) {
    if (context.isPanning) {
      DygraphInteraction.movePan(event, g, context);
    }
  },
  mouseup: function mouseup(event, g, context) {
    if (context.isPanning) {
      DygraphInteraction.endPan(event, g, context);
    }
  }
};

exports["default"] = DygraphInteraction;
module.exports = exports["default"];

},{"./dygraph-utils":17}],13:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview Based on PlotKitLayout, but modified to meet the needs of
 * dygraphs.
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * Creates a new DygraphLayout object.
 *
 * This class contains all the data to be charted.
 * It uses data coordinates, but also records the chart range (in data
 * coordinates) and hence is able to calculate percentage positions ('In this
 * view, Point A lies 25% down the x-axis.')
 *
 * Two things that it does not do are:
 * 1. Record pixel coordinates for anything.
 * 2. (oddly) determine anything about the layout of chart elements.
 *
 * The naming is a vestige of Dygraph's original PlotKit roots.
 *
 * @constructor
 */
var DygraphLayout = function DygraphLayout(dygraph) {
  this.dygraph_ = dygraph;
  /**
   * Array of points for each series.
   *
   * [series index][row index in series] = |Point| structure,
   * where series index refers to visible series only, and the
   * point index is for the reduced set of points for the current
   * zoom region (including one point just outside the window).
   * All points in the same row index share the same X value.
   *
   * @type {Array.<Array.<Dygraph.PointType>>}
   */
  this.points = [];
  this.setNames = [];
  this.annotations = [];
  this.yAxes_ = null;

  // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and
  // yticks are outputs. Clean this up.
  this.xTicks_ = null;
  this.yTicks_ = null;
};

/**
 * Add points for a single series.
 *
 * @param {string} setname Name of the series.
 * @param {Array.<Dygraph.PointType>} set_xy Points for the series.
 */
DygraphLayout.prototype.addDataset = function (setname, set_xy) {
  this.points.push(set_xy);
  this.setNames.push(setname);
};

/**
 * Returns the box which the chart should be drawn in. This is the canvas's
 * box, less space needed for the axis and chart labels.
 *
 * @return {{x: number, y: number, w: number, h: number}}
 */
DygraphLayout.prototype.getPlotArea = function () {
  return this.area_;
};

// Compute the box which the chart should be drawn in. This is the canvas's
// box, less space needed for axis, chart labels, and other plug-ins.
// NOTE: This should only be called by Dygraph.predraw_().
DygraphLayout.prototype.computePlotArea = function () {
  var area = {
    // TODO(danvk): per-axis setting.
    x: 0,
    y: 0
  };

  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');
  area.h = this.dygraph_.height_;

  // Let plugins reserve space.
  var e = {
    chart_div: this.dygraph_.graphDiv,
    reserveSpaceLeft: function reserveSpaceLeft(px) {
      var r = {
        x: area.x,
        y: area.y,
        w: px,
        h: area.h
      };
      area.x += px;
      area.w -= px;
      return r;
    },
    reserveSpaceRight: function reserveSpaceRight(px) {
      var r = {
        x: area.x + area.w - px,
        y: area.y,
        w: px,
        h: area.h
      };
      area.w -= px;
      return r;
    },
    reserveSpaceTop: function reserveSpaceTop(px) {
      var r = {
        x: area.x,
        y: area.y,
        w: area.w,
        h: px
      };
      area.y += px;
      area.h -= px;
      return r;
    },
    reserveSpaceBottom: function reserveSpaceBottom(px) {
      var r = {
        x: area.x,
        y: area.y + area.h - px,
        w: area.w,
        h: px
      };
      area.h -= px;
      return r;
    },
    chartRect: function chartRect() {
      return { x: area.x, y: area.y, w: area.w, h: area.h };
    }
  };
  this.dygraph_.cascadeEvents_('layout', e);

  this.area_ = area;
};

DygraphLayout.prototype.setAnnotations = function (ann) {
  // The Dygraph object's annotations aren't parsed. We parse them here and
  // save a copy. If there is no parser, then the user must be using raw format.
  this.annotations = [];
  var parse = this.dygraph_.getOption('xValueParser') || function (x) {
    return x;
  };
  for (var i = 0; i < ann.length; i++) {
    var a = {};
    if (!ann[i].xval && ann[i].x === undefined) {
      console.error("Annotations must have an 'x' property");
      return;
    }
    if (ann[i].icon && !(ann[i].hasOwnProperty('width') && ann[i].hasOwnProperty('height'))) {
      console.error("Must set width and height when setting " + "annotation.icon property");
      return;
    }
    utils.update(a, ann[i]);
    if (!a.xval) a.xval = parse(a.x);
    this.annotations.push(a);
  }
};

DygraphLayout.prototype.setXTicks = function (xTicks) {
  this.xTicks_ = xTicks;
};

// TODO(danvk): add this to the Dygraph object's API or move it into Layout.
DygraphLayout.prototype.setYAxes = function (yAxes) {
  this.yAxes_ = yAxes;
};

DygraphLayout.prototype.evaluate = function () {
  this._xAxis = {};
  this._evaluateLimits();
  this._evaluateLineCharts();
  this._evaluateLineTicks();
  this._evaluateAnnotations();
};

DygraphLayout.prototype._evaluateLimits = function () {
  var xlimits = this.dygraph_.xAxisRange();
  this._xAxis.minval = xlimits[0];
  this._xAxis.maxval = xlimits[1];
  var xrange = xlimits[1] - xlimits[0];
  this._xAxis.scale = xrange !== 0 ? 1 / xrange : 1.0;

  if (this.dygraph_.getOptionForAxis("logscale", 'x')) {
    this._xAxis.xlogrange = utils.log10(this._xAxis.maxval) - utils.log10(this._xAxis.minval);
    this._xAxis.xlogscale = this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0;
  }
  for (var i = 0; i < this.yAxes_.length; i++) {
    var axis = this.yAxes_[i];
    axis.minyval = axis.computedValueRange[0];
    axis.maxyval = axis.computedValueRange[1];
    axis.yrange = axis.maxyval - axis.minyval;
    axis.yscale = axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0;

    if (this.dygraph_.getOption("logscale")) {
      axis.ylogrange = utils.log10(axis.maxyval) - utils.log10(axis.minyval);
      axis.ylogscale = axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0;
      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {
        console.error('axis ' + i + ' of graph at ' + axis.g + ' can\\'t be displayed in log scale for range [' + axis.minyval + ' - ' + axis.maxyval + ']');
      }
    }
  }
};

DygraphLayout.calcXNormal_ = function (value, xAxis, logscale) {
  if (logscale) {
    return (utils.log10(value) - utils.log10(xAxis.minval)) * xAxis.xlogscale;
  } else {
    return (value - xAxis.minval) * xAxis.scale;
  }
};

/**
 * @param {DygraphAxisType} axis
 * @param {number} value
 * @param {boolean} logscale
 * @return {number}
 */
DygraphLayout.calcYNormal_ = function (axis, value, logscale) {
  if (logscale) {
    var x = 1.0 - (utils.log10(value) - utils.log10(axis.minyval)) * axis.ylogscale;
    return isFinite(x) ? x : NaN; // shim for v8 issue; see pull request 276
  } else {
      return 1.0 - (value - axis.minyval) * axis.yscale;
    }
};

DygraphLayout.prototype._evaluateLineCharts = function () {
  var isStacked = this.dygraph_.getOption("stackedGraph");
  var isLogscaleForX = this.dygraph_.getOptionForAxis("logscale", 'x');

  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {
    var points = this.points[setIdx];
    var setName = this.setNames[setIdx];
    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);
    var axis = this.dygraph_.axisPropertiesForSeries(setName);
    // TODO (konigsberg): use optionsForAxis instead.
    var logscale = this.dygraph_.attributes_.getForSeries("logscale", setName);

    for (var j = 0; j < points.length; j++) {
      var point = points[j];

      // Range from 0-1 where 0 represents left and 1 represents right.
      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX);
      // Range from 0-1 where 0 represents top and 1 represents bottom
      var yval = point.yval;
      if (isStacked) {
        point.y_stacked = DygraphLayout.calcYNormal_(axis, point.yval_stacked, logscale);
        if (yval !== null && !isNaN(yval)) {
          yval = point.yval_stacked;
        }
      }
      if (yval === null) {
        yval = NaN;
        if (!connectSeparated) {
          point.yval = NaN;
        }
      }
      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);
    }

    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);
  }
};

DygraphLayout.prototype._evaluateLineTicks = function () {
  var i, tick, label, pos, v, has_tick;
  this.xticks = [];
  for (i = 0; i < this.xTicks_.length; i++) {
    tick = this.xTicks_[i];
    label = tick.label;
    has_tick = !('label_v' in tick);
    v = has_tick ? tick.v : tick.label_v;
    pos = this.dygraph_.toPercentXCoord(v);
    if (pos >= 0.0 && pos < 1.0) {
      this.xticks.push({ pos: pos, label: label, has_tick: has_tick });
    }
  }

  this.yticks = [];
  for (i = 0; i < this.yAxes_.length; i++) {
    var axis = this.yAxes_[i];
    for (var j = 0; j < axis.ticks.length; j++) {
      tick = axis.ticks[j];
      label = tick.label;
      has_tick = !('label_v' in tick);
      v = has_tick ? tick.v : tick.label_v;
      pos = this.dygraph_.toPercentYCoord(v, i);
      if (pos > 0.0 && pos <= 1.0) {
        this.yticks.push({ axis: i, pos: pos, label: label, has_tick: has_tick });
      }
    }
  }
};

DygraphLayout.prototype._evaluateAnnotations = function () {
  // Add the annotations to the point to which they belong.
  // Make a map from (setName, xval) to annotation for quick lookups.
  var i;
  var annotations = {};
  for (i = 0; i < this.annotations.length; i++) {
    var a = this.annotations[i];
    annotations[a.xval + "," + a.series] = a;
  }

  this.annotated_points = [];

  // Exit the function early if there are no annotations.
  if (!this.annotations || !this.annotations.length) {
    return;
  }

  // TODO(antrob): loop through annotations not points.
  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {
    var points = this.points[setIdx];
    for (i = 0; i < points.length; i++) {
      var p = points[i];
      var k = p.xval + "," + p.name;
      if (k in annotations) {
        p.annotation = annotations[k];
        this.annotated_points.push(p);
      }
    }
  }
};

/**
 * Convenience function to remove all the data sets from a graph
 */
DygraphLayout.prototype.removeAllDatasets = function () {
  delete this.points;
  delete this.setNames;
  delete this.setPointsLengths;
  delete this.setPointsOffsets;
  this.points = [];
  this.setNames = [];
  this.setPointsLengths = [];
  this.setPointsOffsets = [];
};

exports['default'] = DygraphLayout;
module.exports = exports['default'];

},{"./dygraph-utils":17}],14:[function(require,module,exports){
(function (process){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});
var OPTIONS_REFERENCE = null;

// For "production" code, this gets removed by uglifyjs.
if (typeof process !== 'undefined') {
  if ("development" != 'production') {

    // NOTE: in addition to parsing as JS, this snippet is expected to be valid
    // JSON. This assumption cannot be checked in JS, but it will be checked when
    // documentation is generated by the generate-documentation.py script. For the
    // most part, this just means that you should always use double quotes.
    OPTIONS_REFERENCE = // <JSON>
    {
      "xValueParser": {
        "default": "parseFloat() or Date.parse()*",
        "labels": ["CSV parsing"],
        "type": "function(str) -> number",
        "description": "A function which parses x-values (i.e. the dependent series). Must return a number, even when the values are dates. In this case, millis since epoch are used. This is used primarily for parsing CSV data. *=Dygraphs is slightly more accepting in the dates which it will parse. See code for details."
      },
      "stackedGraph": {
        "default": "false",
        "labels": ["Data Line display"],
        "type": "boolean",
        "description": "If set, stack series on top of one another rather than drawing them independently. The first series specified in the input data will wind up on top of the chart and the last will be on bottom. NaN values are drawn as white areas without a line on top, see stackedGraphNaNFill for details."
      },
      "stackedGraphNaNFill": {
        "default": "all",
        "labels": ["Data Line display"],
        "type": "string",
        "description": "Controls handling of NaN values inside a stacked graph. NaN values are interpolated/extended for stacking purposes, but the actual point value remains NaN in the legend display. Valid option values are \\"all\\" (interpolate internally, repeat leftmost and rightmost value as needed), \\"inside\\" (interpolate internally only, use zero outside leftmost and rightmost value), and \\"none\\" (treat NaN as zero everywhere)."
      },
      "pointSize": {
        "default": "1",
        "labels": ["Data Line display"],
        "type": "integer",
        "description": "The size of the dot to draw on each point in pixels (see drawPoints). A dot is always drawn when a point is \\"isolated\\", i.e. there is a missing point on either side of it. This also controls the size of those dots."
      },
      "drawPoints": {
        "default": "false",
        "labels": ["Data Line display"],
        "type": "boolean",
        "description": "Draw a small dot at each point, in addition to a line going through the point. This makes the individual data points easier to see, but can increase visual clutter in the chart. The small dot can be replaced with a custom rendering by supplying a <a href='#drawPointCallback'>drawPointCallback</a>."
      },
      "drawGapEdgePoints": {
        "default": "false",
        "labels": ["Data Line display"],
        "type": "boolean",
        "description": "Draw points at the edges of gaps in the data. This improves visibility of small data segments or other data irregularities."
      },
      "drawPointCallback": {
        "default": "null",
        "labels": ["Data Line display"],
        "type": "function(g, seriesName, canvasContext, cx, cy, color, pointSize)",
        "parameters": [["g", "the reference graph"], ["seriesName", "the name of the series"], ["canvasContext", "the canvas to draw on"], ["cx", "center x coordinate"], ["cy", "center y coordinate"], ["color", "series color"], ["pointSize", "the radius of the image."], ["idx", "the row-index of the point in the data."]],
        "description": "Draw a custom item when drawPoints is enabled. Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy).  Also see <a href='#drawHighlightPointCallback'>drawHighlightPointCallback</a>"
      },
      "height": {
        "default": "320",
        "labels": ["Overall display"],
        "type": "integer",
        "description": "Height, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored."
      },
      "zoomCallback": {
        "default": "null",
        "labels": ["Callbacks"],
        "type": "function(minDate, maxDate, yRanges)",
        "parameters": [["minDate", "milliseconds since epoch"], ["maxDate", "milliseconds since epoch."], ["yRanges", "is an array of [bottom, top] pairs, one for each y-axis."]],
        "description": "A function to call when the zoom window is changed (either by zooming in or out). When animatedZooms is set, zoomCallback is called once at the end of the transition (it will not be called for intermediate frames)."
      },
      "pointClickCallback": {
        "snippet": "function(e, point){<br>&nbsp;&nbsp;alert(point);<br>}",
        "default": "null",
        "labels": ["Callbacks", "Interactive Elements"],
        "type": "function(e, point)",
        "parameters": [["e", "the event object for the click"], ["point", "the point that was clicked See <a href='#point_properties'>Point properties</a> for details"]],
        "description": "A function to call when a data point is clicked. and the point that was clicked."
      },
      "color": {
        "default": "(see description)",
        "labels": ["Data Series Colors"],
        "type": "string",
        "example": "red",
        "description": "A per-series color definition. Used in conjunction with, and overrides, the colors option."
      },
      "colors": {
        "default": "(see description)",
        "labels": ["Data Series Colors"],
        "type": "array<string>",
        "example": "['red', '#00FF00']",
        "description": "List of colors for the data series. These can be of the form \\"#AABBCC\\" or \\"rgb(255,100,200)\\" or \\"yellow\\", etc. If not specified, equally-spaced points around a color wheel are used. Overridden by the 'color' option."
      },
      "connectSeparatedPoints": {
        "default": "false",
        "labels": ["Data Line display"],
        "type": "boolean",
        "description": "Usually, when Dygraphs encounters a missing value in a data series, it interprets this as a gap and draws it as such. If, instead, the missing values represents an x-value for which only a different series has data, then you'll want to connect the dots by setting this to true. To explicitly include a gap with this option set, use a value of NaN."
      },
      "highlightCallback": {
        "default": "null",
        "labels": ["Callbacks"],
        "type": "function(event, x, points, row, seriesName)",
        "description": "When set, this callback gets called every time a new point is highlighted.",
        "parameters": [["event", "the JavaScript mousemove event"], ["x", "the x-coordinate of the highlighted points"], ["points", "an array of highlighted points: <code>[ {name: 'series', yval: y-value}, &hellip; ]</code>"], ["row", "integer index of the highlighted row in the data table, starting from 0"], ["seriesName", "name of the highlighted series, only present if highlightSeriesOpts is set."]]
      },
      "drawHighlightPointCallback": {
        "default": "null",
        "labels": ["Data Line display"],
        "type": "function(g, seriesName, canvasContext, cx, cy, color, pointSize)",
        "parameters": [["g", "the reference graph"], ["seriesName", "the name of the series"], ["canvasContext", "the canvas to draw on"], ["cx", "center x coordinate"], ["cy", "center y coordinate"], ["color", "series color"], ["pointSize", "the radius of the image."], ["idx", "the row-index of the point in the data."]],
        "description": "Draw a custom item when a point is highlighted.  Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy) Also see <a href='#drawPointCallback'>drawPointCallback</a>"
      },
      "highlightSeriesOpts": {
        "default": "null",
        "labels": ["Interactive Elements"],
        "type": "Object",
        "description": "When set, the options from this object are applied to the timeseries closest to the mouse pointer for interactive highlighting. See also 'highlightCallback'. Example: highlightSeriesOpts: { strokeWidth: 3 }."
      },
      "highlightSeriesBackgroundAlpha": {
        "default": "0.5",
        "labels": ["Interactive Elements"],
        "type": "float",
        "description": "Fade the background while highlighting series. 1=fully visible background (disable fading), 0=hiddden background (show highlighted series only)."
      },
      "highlightSeriesBackgroundColor": {
        "default": "rgb(255, 255, 255)",
        "labels": ["Interactive Elements"],
        "type": "string",
        "description": "Sets the background color used to fade out the series in conjunction with 'highlightSeriesBackgroundAlpha'."
      },
      "includeZero": {
        "default": "false",
        "labels": ["Axis display"],
        "type": "boolean",
        "description": "Usually, dygraphs will use the range of the data plus some padding to set the range of the y-axis. If this option is set, the y-axis will always include zero, typically as the lowest value. This can be used to avoid exaggerating the variance in the data"
      },
      "rollPeriod": {
        "default": "1",
        "labels": ["Error Bars", "Rolling Averages"],
        "type": "integer &gt;= 1",
        "description": "Number of days over which to average data. Discussed extensively above."
      },
      "unhighlightCallback": {
        "default": "null",
        "labels": ["Callbacks"],
        "type": "function(event)",
        "parameters": [["event", "the mouse event"]],
        "description": "When set, this callback gets called every time the user stops highlighting any point by mousing out of the graph."
      },
      "axisTickSize": {
        "default": "3.0",
        "labels": ["Axis display"],
        "type": "number",
        "description": "The size of the line to display next to each tick mark on x- or y-axes."
      },
      "labelsSeparateLines": {
        "default": "false",
        "labels": ["Legend"],
        "type": "boolean",
        "description": "Put <code>&lt;br/&gt;</code> between lines in the label string. Often used in conjunction with <strong>labelsDiv</strong>."
      },
      "valueFormatter": {
        "default": "Depends on the type of your data.",
        "labels": ["Legend", "Value display/formatting"],
        "type": "function(num or millis, opts, seriesName, dygraph, row, col)",
        "description": "Function to provide a custom display format for the values displayed on mouseover. This does not affect the values that appear on tick marks next to the axes. To format those, see axisLabelFormatter. This is usually set on a <a href='per-axis.html'>per-axis</a> basis. .",
        "parameters": [["num_or_millis", "The value to be formatted. This is always a number. For date axes, it's millis since epoch. You can call new Date(millis) to get a Date object."], ["opts", "This is a function you can call to access various options (e.g. opts('labelsKMB')). It returns per-axis values for the option when available."], ["seriesName", "The name of the series from which the point came, e.g. 'X', 'Y', 'A', etc."], ["dygraph", "The dygraph object for which the formatting is being done"], ["row", "The row of the data from which this point comes. g.getValue(row, 0) will return the x-value for this point."], ["col", "The column of the data from which this point comes. g.getValue(row, col) will return the original y-value for this point. This can be used to get the full confidence interval for the point, or access un-rolled values for the point."]]
      },
      "annotationMouseOverHandler": {
        "default": "null",
        "labels": ["Annotations"],
        "type": "function(annotation, point, dygraph, event)",
        "description": "If provided, this function is called whenever the user mouses over an annotation."
      },
      "annotationMouseOutHandler": {
        "default": "null",
        "labels": ["Annotations"],
        "type": "function(annotation, point, dygraph, event)",
        "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
        "description": "If provided, this function is called whenever the user mouses out of an annotation."
      },
      "annotationClickHandler": {
        "default": "null",
        "labels": ["Annotations"],
        "type": "function(annotation, point, dygraph, event)",
        "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
        "description": "If provided, this function is called whenever the user clicks on an annotation."
      },
      "annotationDblClickHandler": {
        "default": "null",
        "labels": ["Annotations"],
        "type": "function(annotation, point, dygraph, event)",
        "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
        "description": "If provided, this function is called whenever the user double-clicks on an annotation."
      },
      "drawCallback": {
        "default": "null",
        "labels": ["Callbacks"],
        "type": "function(dygraph, is_initial)",
        "parameters": [["dygraph", "The graph being drawn"], ["is_initial", "True if this is the initial draw, false for subsequent draws."]],
        "description": "When set, this callback gets called every time the dygraph is drawn. This includes the initial draw, after zooming and repeatedly while panning."
      },
      "labelsKMG2": {
        "default": "false",
        "labels": ["Value display/formatting"],
        "type": "boolean",
        "description": "Show k/M/G for kilo/Mega/Giga on y-axis. This is different than <code>labelsKMB</code> in that it uses base 2, not 10."
      },
      "delimiter": {
        "default": ",",
        "labels": ["CSV parsing"],
        "type": "string",
        "description": "The delimiter to look for when separating fields of a CSV file. Setting this to a tab is not usually necessary, since tab-delimited data is auto-detected."
      },
      "axisLabelFontSize": {
        "default": "14",
        "labels": ["Axis display"],
        "type": "integer",
        "description": "Size of the font (in pixels) to use in the axis labels, both x- and y-axis."
      },
      "underlayCallback": {
        "default": "null",
        "labels": ["Callbacks"],
        "type": "function(context, area, dygraph)",
        "parameters": [["context", "the canvas drawing context on which to draw"], ["area", "An object with {x,y,w,h} properties describing the drawing area."], ["dygraph", "the reference graph"]],
        "description": "When set, this callback gets called before the chart is drawn. It details on how to use this."
      },
      "width": {
        "default": "480",
        "labels": ["Overall display"],
        "type": "integer",
        "description": "Width, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored."
      },
      "pixelRatio": {
        "default": "(devicePixelRatio / context.backingStoreRatio)",
        "labels": ["Overall display"],
        "type": "float",
        "description": "Overrides the pixel ratio scaling factor for the canvas's 2d context. Ordinarily, this is set to the devicePixelRatio / (context.backingStoreRatio || 1), so on mobile devices, where the devicePixelRatio can be somewhere around 3, performance can be improved by overriding this value to something less precise, like 1, at the expense of resolution."
      },
      "interactionModel": {
        "default": "...",
        "labels": ["Interactive Elements"],
        "type": "Object",
        "description": "TODO(konigsberg): document this"
      },
      "ticker": {
        "default": "Dygraph.dateTicker or Dygraph.numericTicks",
        "labels": ["Axis display"],
        "type": "function(min, max, pixels, opts, dygraph, vals) -> [{v: ..., label: ...}, ...]",
        "parameters": [["min", ""], ["max", ""], ["pixels", ""], ["opts", ""], ["dygraph", "the reference graph"], ["vals", ""]],
        "description": "This lets you specify an arbitrary function to generate tick marks on an axis. The tick marks are an array of (value, label) pairs. The built-in functions go to great lengths to choose good tick marks so, if you set this option, you'll most likely want to call one of them and modify the result. See dygraph-tickers.js for an extensive discussion. This is set on a <a href='per-axis.html'>per-axis</a> basis."
      },
      "xAxisHeight": {
        "default": "(null)",
        "labels": ["Axis display"],
        "type": "integer",
        "description": "Height, in pixels, of the x-axis. If not set explicitly, this is computed based on axisLabelFontSize and axisTickSize."
      },
      "showLabelsOnHighlight": {
        "default": "true",
        "labels": ["Interactive Elements", "Legend"],
        "type": "boolean",
        "description": "Whether to show the legend upon mouseover."
      },
      "axis": {
        "default": "(none)",
        "labels": ["Axis display"],
        "type": "string",
        "description": "Set to either 'y1' or 'y2' to assign a series to a y-axis (primary or secondary). Must be set per-series."
      },
      "pixelsPerLabel": {
        "default": "70 (x-axis) or 30 (y-axes)",
        "labels": ["Axis display", "Grid"],
        "type": "integer",
        "description": "Number of pixels to require between each x- and y-label. Larger values will yield a sparser axis with fewer ticks. This is set on a <a href='per-axis.html'>per-axis</a> basis."
      },
      "labelsDiv": {
        "default": "null",
        "labels": ["Legend"],
        "type": "DOM element or string",
        "example": "<code style='font-size: small'>document.getElementById('foo')</code>or<code>'foo'",
        "description": "Show data labels in an external div, rather than on the graph.  This value can either be a div element or a div id."
      },
      "fractions": {
        "default": "false",
        "labels": ["CSV parsing", "Error Bars"],
        "type": "boolean",
        "description": "When set, attempt to parse each cell in the CSV file as \\"a/b\\", where a and b are integers. The ratio will be plotted. This allows computation of Wilson confidence intervals (see below)."
      },
      "logscale": {
        "default": "false",
        "labels": ["Axis display"],
        "type": "boolean",
        "description": "When set for the y-axis or x-axis, the graph shows that axis in log scale. Any values less than or equal to zero are not displayed. Showing log scale with ranges that go below zero will result in an unviewable graph.\\n\\n Not compatible with showZero. connectSeparatedPoints is ignored. This is ignored for date-based x-axes."
      },
      "strokeWidth": {
        "default": "1.0",
        "labels": ["Data Line display"],
        "type": "float",
        "example": "0.5, 2.0",
        "description": "The width of the lines connecting data points. This can be used to increase the contrast or some graphs."
      },
      "strokePattern": {
        "default": "null",
        "labels": ["Data Line display"],
        "type": "array<integer>",
        "example": "[10, 2, 5, 2]",
        "description": "A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed lines."
      },
      "strokeBorderWidth": {
        "default": "null",
        "labels": ["Data Line display"],
        "type": "float",
        "example": "1.0",
        "description": "Draw a border around graph lines to make crossing lines more easily distinguishable. Useful for graphs with many lines."
      },
      "strokeBorderColor": {
        "default": "white",
        "labels": ["Data Line display"],
        "type": "string",
        "example": "red, #ccffdd",
        "description": "Color for the line border used if strokeBorderWidth is set."
      },
      "wilsonInterval": {
        "default": "true",
        "labels": ["Error Bars"],
        "type": "boolean",
        "description": "Use in conjunction with the \\"fractions\\" option. Instead of plotting +/- N standard deviations, dygraphs will compute a Wilson confidence interval and plot that. This has more reasonable behavior for ratios close to 0 or 1."
      },
      "fillGraph": {
        "default": "false",
        "labels": ["Data Line display"],
        "type": "boolean",
        "description": "Should the area underneath the graph be filled? This option is not compatible with error bars. This may be set on a <a href='per-axis.html'>per-series</a> basis."
      },
      "highlightCircleSize": {
        "default": "3",
        "labels": ["Interactive Elements"],
        "type": "integer",
        "description": "The size in pixels of the dot drawn over highlighted points."
      },
      "gridLineColor": {
        "default": "rgb(128,128,128)",
        "labels": ["Grid"],
        "type": "red, blue",
        "description": "The color of the gridlines. This may be set on a per-axis basis to define each axis' grid separately."
      },
      "gridLinePattern": {
        "default": "null",
        "labels": ["Grid"],
        "type": "array<integer>",
        "example": "[10, 2, 5, 2]",
        "description": "A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed gridlines."
      },
      "visibility": {
        "default": "[true, true, ...]",
        "labels": ["Data Line display"],
        "type": "Array of booleans",
        "description": "Which series should initially be visible? Once the Dygraph has been constructed, you can access and modify the visibility of each series using the <code>visibility</code> and <code>setVisibility</code> methods."
      },
      "valueRange": {
        "default": "Full range of the input is shown",
        "labels": ["Axis display"],
        "type": "Array of two numbers",
        "example": "[10, 110]",
        "description": "Explicitly set the vertical range of the graph to [low, high]. This may be set on a per-axis basis to define each y-axis separately. If either limit is unspecified, it will be calculated automatically (e.g. [null, 30] to automatically calculate just the lower bound)"
      },
      "colorSaturation": {
        "default": "1.0",
        "labels": ["Data Series Colors"],
        "type": "float (0.0 - 1.0)",
        "description": "If <strong>colors</strong> is not specified, saturation of the automatically-generated data series colors."
      },
      "hideOverlayOnMouseOut": {
        "default": "true",
        "labels": ["Interactive Elements", "Legend"],
        "type": "boolean",
        "description": "Whether to hide the legend when the mouse leaves the chart area."
      },
      "legend": {
        "default": "onmouseover",
        "labels": ["Legend"],
        "type": "string",
        "description": "When to display the legend. By default, it only appears when a user mouses over the chart. Set it to \\"always\\" to always display a legend of some sort. When set to \\"follow\\", legend follows highlighted points."
      },
      "legendFormatter": {
        "default": "null",
        "labels": ["Legend"],
        "type": "function(data): string",
        "params": [["data", "An object containing information about the selection (or lack of a selection). This includes formatted values and series information. See <a href=\\"https://github.com/danvk/dygraphs/pull/683\\">here</a> for sample values."]],
        "description": "Set this to supply a custom formatter for the legend. See <a href=\\"https://github.com/danvk/dygraphs/pull/683\\">this comment</a> and the <a href=\\"tests/legend-formatter.html\\">legendFormatter demo</a> for usage."
      },
      "labelsShowZeroValues": {
        "default": "true",
        "labels": ["Legend"],
        "type": "boolean",
        "description": "Show zero value labels in the labelsDiv."
      },
      "stepPlot": {
        "default": "false",
        "labels": ["Data Line display"],
        "type": "boolean",
        "description": "When set, display the graph as a step plot instead of a line plot. This option may either be set for the whole graph or for single series."
      },
      "labelsUTC": {
        "default": "false",
        "labels": ["Value display/formatting", "Axis display"],
        "type": "boolean",
        "description": "Show date/time labels according to UTC (instead of local time)."
      },
      "labelsKMB": {
        "default": "false",
        "labels": ["Value display/formatting"],
        "type": "boolean",
        "description": "Show K/M/B for thousands/millions/billions on y-axis."
      },
      "rightGap": {
        "default": "5",
        "labels": ["Overall display"],
        "type": "integer",
        "description": "Number of pixels to leave blank at the right edge of the Dygraph. This makes it easier to highlight the right-most data point."
      },
      "drawAxesAtZero": {
        "default": "false",
        "labels": ["Axis display"],
        "type": "boolean",
        "description": "When set, draw the X axis at the Y=0 position and the Y axis at the X=0 position if those positions are inside the graph's visible area. Otherwise, draw the axes at the bottom or left graph edge as usual."
      },
      "xRangePad": {
        "default": "0",
        "labels": ["Axis display"],
        "type": "float",
        "description": "Add the specified amount of extra space (in pixels) around the X-axis value range to ensure points at the edges remain visible."
      },
      "yRangePad": {
        "default": "null",
        "labels": ["Axis display"],
        "type": "float",
        "description": "If set, add the specified amount of extra space (in pixels) around the Y-axis value range to ensure points at the edges remain visible. If unset, use the traditional Y padding algorithm."
      },
      "axisLabelFormatter": {
        "default": "Depends on the data type",
        "labels": ["Axis display"],
        "type": "function(number or Date, granularity, opts, dygraph)",
        "parameters": [["number or date", "Either a number (for a numeric axis) or a Date object (for a date axis)"], ["granularity", "specifies how fine-grained the axis is. For date axes, this is a reference to the time granularity enumeration, defined in dygraph-tickers.js, e.g. Dygraph.WEEKLY."], ["opts", "a function which provides access to various options on the dygraph, e.g. opts('labelsKMB')."], ["dygraph", "the referenced graph"]],
        "description": "Function to call to format the tick values that appear along an axis. This is usually set on a <a href='per-axis.html'>per-axis</a> basis."
      },
      "clickCallback": {
        "snippet": "function(e, date_millis){<br>&nbsp;&nbsp;alert(new Date(date_millis));<br>}",
        "default": "null",
        "labels": ["Callbacks"],
        "type": "function(e, x, points)",
        "parameters": [["e", "The event object for the click"], ["x", "The x value that was clicked (for dates, this is milliseconds since epoch)"], ["points", "The closest points along that date. See <a href='#point_properties'>Point properties</a> for details."]],
        "description": "A function to call when the canvas is clicked."
      },
      "labels": {
        "default": "[\\"X\\", \\"Y1\\", \\"Y2\\", ...]*",
        "labels": ["Legend"],
        "type": "array<string>",
        "description": "A name for each data series, including the independent (X) series. For CSV files and DataTable objections, this is determined by context. For raw data, this must be specified. If it is not, default values are supplied and a warning is logged."
      },
      "dateWindow": {
        "default": "Full range of the input is shown",
        "labels": ["Axis display"],
        "type": "Array of two numbers",
        "example": "[<br>&nbsp;&nbsp;Date.parse('2006-01-01'),<br>&nbsp;&nbsp;(new Date()).valueOf()<br>]",
        "description": "Initially zoom in on a section of the graph. Is of the form [earliest, latest], where earliest/latest are milliseconds since epoch. If the data for the x-axis is numeric, the values in dateWindow must also be numbers."
      },
      "showRoller": {
        "default": "false",
        "labels": ["Interactive Elements", "Rolling Averages"],
        "type": "boolean",
        "description": "If the rolling average period text box should be shown."
      },
      "sigma": {
        "default": "2.0",
        "labels": ["Error Bars"],
        "type": "float",
        "description": "When errorBars is set, shade this many standard deviations above/below each point."
      },
      "customBars": {
        "default": "false",
        "labels": ["CSV parsing", "Error Bars"],
        "type": "boolean",
        "description": "When set, parse each CSV cell as \\"low;middle;high\\". Error bars will be drawn for each point between low and high, with the series itself going through middle."
      },
      "colorValue": {
        "default": "1.0",
        "labels": ["Data Series Colors"],
        "type": "float (0.0 - 1.0)",
        "description": "If colors is not specified, value of the data series colors, as in hue/saturation/value. (0.0-1.0, default 0.5)"
      },
      "errorBars": {
        "default": "false",
        "labels": ["CSV parsing", "Error Bars"],
        "type": "boolean",
        "description": "Does the data contain standard deviations? Setting this to true alters the input format (see above)."
      },
      "displayAnnotations": {
        "default": "false",
        "labels": ["Annotations"],
        "type": "boolean",
        "description": "Only applies when Dygraphs is used as a GViz chart. Causes string columns following a data series to be interpreted as annotations on points in that series. This is the same format used by Google's AnnotatedTimeLine chart."
      },
      "panEdgeFraction": {
        "default": "null",
        "labels": ["Axis display", "Interactive Elements"],
        "type": "float",
        "description": "A value representing the farthest a graph may be panned, in percent of the display. For example, a value of 0.1 means that the graph can only be panned 10% passed the edges of the displayed values. null means no bounds."
      },
      "title": {
        "labels": ["Chart labels"],
        "type": "string",
        "default": "null",
        "description": "Text to display above the chart. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-title' classes."
      },
      "titleHeight": {
        "default": "18",
        "labels": ["Chart labels"],
        "type": "integer",
        "description": "Height of the chart title, in pixels. This also controls the default font size of the title. If you style the title on your own, this controls how much space is set aside above the chart for the title's div."
      },
      "xlabel": {
        "labels": ["Chart labels"],
        "type": "string",
        "default": "null",
        "description": "Text to display below the chart's x-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-xlabel' classes."
      },
      "xLabelHeight": {
        "labels": ["Chart labels"],
        "type": "integer",
        "default": "18",
        "description": "Height of the x-axis label, in pixels. This also controls the default font size of the x-axis label. If you style the label on your own, this controls how much space is set aside below the chart for the x-axis label's div."
      },
      "ylabel": {
        "labels": ["Chart labels"],
        "type": "string",
        "default": "null",
        "description": "Text to display to the left of the chart's y-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-ylabel' classes. The text will be rotated 90 degrees by default, so CSS rules may behave in unintuitive ways. No additional space is set aside for a y-axis label. If you need more space, increase the width of the y-axis tick labels using the yAxisLabelWidth option. If you need a wider div for the y-axis label, either style it that way with CSS (but remember that it's rotated, so width is controlled by the 'height' property) or set the yLabelWidth option."
      },
      "y2label": {
        "labels": ["Chart labels"],
        "type": "string",
        "default": "null",
        "description": "Text to display to the right of the chart's secondary y-axis. This label is only displayed if a secondary y-axis is present. See <a href='http://dygraphs.com/tests/two-axes.html'>this test</a> for an example of how to do this. The comments for the 'ylabel' option generally apply here as well. This label gets a 'dygraph-y2label' instead of a 'dygraph-ylabel' class."
      },
      "yLabelWidth": {
        "labels": ["Chart labels"],
        "type": "integer",
        "default": "18",
        "description": "Width of the div which contains the y-axis label. Since the y-axis label appears rotated 90 degrees, this actually affects the height of its div."
      },
      "drawGrid": {
        "default": "true for x and y, false for y2",
        "labels": ["Grid"],
        "type": "boolean",
        "description": "Whether to display gridlines in the chart. This may be set on a per-axis basis to define the visibility of each axis' grid separately."
      },
      "independentTicks": {
        "default": "true for y, false for y2",
        "labels": ["Axis display", "Grid"],
        "type": "boolean",
        "description": "Only valid for y and y2, has no effect on x: This option defines whether the y axes should align their ticks or if they should be independent. Possible combinations: 1.) y=true, y2=false (default): y is the primary axis and the y2 ticks are aligned to the the ones of y. (only 1 grid) 2.) y=false, y2=true: y2 is the primary axis and the y ticks are aligned to the the ones of y2. (only 1 grid) 3.) y=true, y2=true: Both axis are independent and have their own ticks. (2 grids) 4.) y=false, y2=false: Invalid configuration causes an error."
      },
      "drawAxis": {
        "default": "true for x and y, false for y2",
        "labels": ["Axis display"],
        "type": "boolean",
        "description": "Whether to draw the specified axis. This may be set on a per-axis basis to define the visibility of each axis separately. Setting this to false also prevents axis ticks from being drawn and reclaims the space for the chart grid/lines."
      },
      "gridLineWidth": {
        "default": "0.3",
        "labels": ["Grid"],
        "type": "float",
        "description": "Thickness (in pixels) of the gridlines drawn under the chart. The vertical/horizontal gridlines can be turned off entirely by using the drawGrid option. This may be set on a per-axis basis to define each axis' grid separately."
      },
      "axisLineWidth": {
        "default": "0.3",
        "labels": ["Axis display"],
        "type": "float",
        "description": "Thickness (in pixels) of the x- and y-axis lines."
      },
      "axisLineColor": {
        "default": "black",
        "labels": ["Axis display"],
        "type": "string",
        "description": "Color of the x- and y-axis lines. Accepts any value which the HTML canvas strokeStyle attribute understands, e.g. 'black' or 'rgb(0, 100, 255)'."
      },
      "fillAlpha": {
        "default": "0.15",
        "labels": ["Error Bars", "Data Series Colors"],
        "type": "float (0.0 - 1.0)",
        "description": "Error bars (or custom bars) for each series are drawn in the same color as the series, but with partial transparency. This sets the transparency. A value of 0.0 means that the error bars will not be drawn, whereas a value of 1.0 means that the error bars will be as dark as the line for the series itself. This can be used to produce chart lines whose thickness varies at each point."
      },
      "axisLabelWidth": {
        "default": "50 (y-axis), 60 (x-axis)",
        "labels": ["Axis display", "Chart labels"],
        "type": "integer",
        "description": "Width (in pixels) of the containing divs for x- and y-axis labels. For the y-axis, this also controls the width of the y-axis. Note that for the x-axis, this is independent from pixelsPerLabel, which controls the spacing between labels."
      },
      "sigFigs": {
        "default": "null",
        "labels": ["Value display/formatting"],
        "type": "integer",
        "description": "By default, dygraphs displays numbers with a fixed number of digits after the decimal point. If you'd prefer to have a fixed number of significant figures, set this option to that number of sig figs. A value of 2, for instance, would cause 1 to be display as 1.0 and 1234 to be displayed as 1.23e+3."
      },
      "digitsAfterDecimal": {
        "default": "2",
        "labels": ["Value display/formatting"],
        "type": "integer",
        "description": "Unless it's run in scientific mode (see the <code>sigFigs</code> option), dygraphs displays numbers with <code>digitsAfterDecimal</code> digits after the decimal point. Trailing zeros are not displayed, so with a value of 2 you'll get '0', '0.1', '0.12', '123.45' but not '123.456' (it will be rounded to '123.46'). Numbers with absolute value less than 0.1^digitsAfterDecimal (i.e. those which would show up as '0.00') will be displayed in scientific notation."
      },
      "maxNumberWidth": {
        "default": "6",
        "labels": ["Value display/formatting"],
        "type": "integer",
        "description": "When displaying numbers in normal (not scientific) mode, large numbers will be displayed with many trailing zeros (e.g. 100000000 instead of 1e9). This can lead to unwieldy y-axis labels. If there are more than <code>maxNumberWidth</code> digits to the left of the decimal in a number, dygraphs will switch to scientific notation, even when not operating in scientific mode. If you'd like to see all those digits, set this to something large, like 20 or 30."
      },
      "file": {
        "default": "(set when constructed)",
        "labels": ["Data"],
        "type": "string (URL of CSV or CSV), GViz DataTable or 2D Array",
        "description": "Sets the data being displayed in the chart. This can only be set when calling updateOptions; it cannot be set from the constructor. For a full description of valid data formats, see the <a href='http://dygraphs.com/data.html'>Data Formats</a> page."
      },
      "timingName": {
        "default": "null",
        "labels": ["Debugging", "Deprecated"],
        "type": "string",
        "description": "Set this option to log timing information. The value of the option will be logged along with the timimg, so that you can distinguish multiple dygraphs on the same page."
      },
      "showRangeSelector": {
        "default": "false",
        "labels": ["Range Selector"],
        "type": "boolean",
        "description": "Show or hide the range selector widget."
      },
      "rangeSelectorHeight": {
        "default": "40",
        "labels": ["Range Selector"],
        "type": "integer",
        "description": "Height, in pixels, of the range selector widget. This option can only be specified at Dygraph creation time."
      },
      "rangeSelectorPlotStrokeColor": {
        "default": "#808FAB",
        "labels": ["Range Selector"],
        "type": "string",
        "description": "The range selector mini plot stroke color. This can be of the form \\"#AABBCC\\" or \\"rgb(255,100,200)\\" or \\"yellow\\". You can also specify null or \\"\\" to turn off stroke."
      },
      "rangeSelectorPlotFillColor": {
        "default": "#A7B1C4",
        "labels": ["Range Selector"],
        "type": "string",
        "description": "The range selector mini plot fill color. This can be of the form \\"#AABBCC\\" or \\"rgb(255,100,200)\\" or \\"yellow\\". You can also specify null or \\"\\" to turn off fill."
      },
      "rangeSelectorPlotFillGradientColor": {
        "default": "white",
        "labels": ["Range Selector"],
        "type": "string",
        "description": "The top color for the range selector mini plot fill color gradient. This can be of the form \\"#AABBCC\\" or \\"rgb(255,100,200)\\" or \\"rgba(255,100,200,42)\\" or \\"yellow\\". You can also specify null or \\"\\" to disable the gradient and fill with one single color."
      },
      "rangeSelectorBackgroundStrokeColor": {
        "default": "gray",
        "labels": ["Range Selector"],
        "type": "string",
        "description": "The color of the lines below and on both sides of the range selector mini plot. This can be of the form \\"#AABBCC\\" or \\"rgb(255,100,200)\\" or \\"yellow\\"."
      },
      "rangeSelectorBackgroundLineWidth": {
        "default": "1",
        "labels": ["Range Selector"],
        "type": "float",
        "description": "The width of the lines below and on both sides of the range selector mini plot."
      },
      "rangeSelectorPlotLineWidth": {
        "default": "1.5",
        "labels": ["Range Selector"],
        "type": "float",
        "description": "The width of the range selector mini plot line."
      },
      "rangeSelectorForegroundStrokeColor": {
        "default": "black",
        "labels": ["Range Selector"],
        "type": "string",
        "description": "The color of the lines in the interactive layer of the range selector. This can be of the form \\"#AABBCC\\" or \\"rgb(255,100,200)\\" or \\"yellow\\"."
      },
      "rangeSelectorForegroundLineWidth": {
        "default": "1",
        "labels": ["Range Selector"],
        "type": "float",
        "description": "The width the lines in the interactive layer of the range selector."
      },
      "rangeSelectorAlpha": {
        "default": "0.6",
        "labels": ["Range Selector"],
        "type": "float (0.0 - 1.0)",
        "description": "The transparency of the veil that is drawn over the unselected portions of the range selector mini plot. A value of 0 represents full transparency and the unselected portions of the mini plot will appear as normal. A value of 1 represents full opacity and the unselected portions of the mini plot will be hidden."
      },
      "showInRangeSelector": {
        "default": "null",
        "labels": ["Range Selector"],
        "type": "boolean",
        "description": "Mark this series for inclusion in the range selector. The mini plot curve will be an average of all such series. If this is not specified for any series, the default behavior is to average all the visible series. Setting it for one series will result in that series being charted alone in the range selector. Once it's set for a single series, it needs to be set for all series which should be included (regardless of visibility)."
      },
      "animatedZooms": {
        "default": "false",
        "labels": ["Interactive Elements"],
        "type": "boolean",
        "description": "Set this option to animate the transition between zoom windows. Applies to programmatic and interactive zooms. Note that if you also set a drawCallback, it will be called several times on each zoom. If you set a zoomCallback, it will only be called after the animation is complete."
      },
      "plotter": {
        "default": "[DygraphCanvasRenderer.Plotters.fillPlotter, DygraphCanvasRenderer.Plotters.errorPlotter, DygraphCanvasRenderer.Plotters.linePlotter]",
        "labels": ["Data Line display"],
        "type": "array or function",
        "description": "A function (or array of functions) which plot each data series on the chart. TODO(danvk): more details! May be set per-series."
      },
      "axes": {
        "default": "null",
        "labels": ["Configuration"],
        "type": "Object",
        "description": "Defines per-axis options. Valid keys are 'x', 'y' and 'y2'. Only some options may be set on a per-axis basis. If an option may be set in this way, it will be noted on this page. See also documentation on <a href='http://dygraphs.com/per-axis.html'>per-series and per-axis options</a>."
      },
      "series": {
        "default": "null",
        "labels": ["Series"],
        "type": "Object",
        "description": "Defines per-series options. Its keys match the y-axis label names, and the values are dictionaries themselves that contain options specific to that series."
      },
      "plugins": {
        "default": "[]",
        "labels": ["Configuration"],
        "type": "Array<plugin>",
        "description": "Defines per-graph plugins. Useful for per-graph customization"
      },
      "dataHandler": {
        "default": "(depends on data)",
        "labels": ["Data"],
        "type": "Dygraph.DataHandler",
        "description": "Custom DataHandler. This is an advanced customization. See http://bit.ly/151E7Aq."
      }
    }; // </JSON>
    // NOTE: in addition to parsing as JS, this snippet is expected to be valid
    // JSON. This assumption cannot be checked in JS, but it will be checked when
    // documentation is generated by the generate-documentation.py script. For the
    // most part, this just means that you should always use double quotes.

    // Do a quick sanity check on the options reference.
    var warn = function warn(msg) {
      if (window.console) window.console.warn(msg);
    };
    var flds = ['type', 'default', 'description'];
    var valid_cats = ['Annotations', 'Axis display', 'Chart labels', 'CSV parsing', 'Callbacks', 'Data', 'Data Line display', 'Data Series Colors', 'Error Bars', 'Grid', 'Interactive Elements', 'Range Selector', 'Legend', 'Overall display', 'Rolling Averages', 'Series', 'Value display/formatting', 'Zooming', 'Debugging', 'Configuration', 'Deprecated'];
    var i;
    var cats = {};
    for (i = 0; i < valid_cats.length; i++) cats[valid_cats[i]] = true;

    for (var k in OPTIONS_REFERENCE) {
      if (!OPTIONS_REFERENCE.hasOwnProperty(k)) continue;
      var op = OPTIONS_REFERENCE[k];
      for (i = 0; i < flds.length; i++) {
        if (!op.hasOwnProperty(flds[i])) {
          warn('Option ' + k + ' missing "' + flds[i] + '" property');
        } else if (typeof op[flds[i]] != 'string') {
          warn(k + '.' + flds[i] + ' must be of type string');
        }
      }
      var labels = op.labels;
      if (typeof labels !== 'object') {
        warn('Option "' + k + '" is missing a "labels": [...] option');
      } else {
        for (i = 0; i < labels.length; i++) {
          if (!cats.hasOwnProperty(labels[i])) {
            warn('Option "' + k + '" has label "' + labels[i] + '", which is invalid.');
          }
        }
      }
    }
  }
}

exports['default'] = OPTIONS_REFERENCE;
module.exports = exports['default'];

}).call(this,require('_process'))

},{"_process":1}],15:[function(require,module,exports){
(function (process){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DygraphOptions is responsible for parsing and returning
 * information about options.
 */

// TODO: remove this jshint directive & fix the warnings.
/*jshint sub:true */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

var _dygraphDefaultAttrs = require('./dygraph-default-attrs');

var _dygraphDefaultAttrs2 = _interopRequireDefault(_dygraphDefaultAttrs);

var _dygraphOptionsReference = require('./dygraph-options-reference');

var _dygraphOptionsReference2 = _interopRequireDefault(_dygraphOptionsReference);

/*
 * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)
 * global_ - global attributes (common among all graphs, AIUI)
 * user - attributes set by the user
 * series_ - { seriesName -> { idx, yAxis, options }}
 */

/**
 * This parses attributes into an object that can be easily queried.
 *
 * It doesn't necessarily mean that all options are available, specifically
 * if labels are not yet available, since those drive details of the per-series
 * and per-axis options.
 *
 * @param {Dygraph} dygraph The chart to which these options belong.
 * @constructor
 */
var DygraphOptions = function DygraphOptions(dygraph) {
  /**
   * The dygraph.
   * @type {!Dygraph}
   */
  this.dygraph_ = dygraph;

  /**
   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }
   * @type {Array.<{series : Array.<string>, options : Object}>} @private
   */
  this.yAxes_ = [];

  /**
   * Contains x-axis specific options, which are stored in the options key.
   * This matches the yAxes_ object structure (by being a dictionary with an
   * options element) allowing for shared code.
   * @type {options: Object} @private
   */
  this.xAxis_ = {};
  this.series_ = {};

  // Once these two objects are initialized, you can call get();
  this.global_ = this.dygraph_.attrs_;
  this.user_ = this.dygraph_.user_attrs_ || {};

  /**
   * A list of series in columnar order.
   * @type {Array.<string>}
   */
  this.labels_ = [];

  this.highlightSeries_ = this.get("highlightSeriesOpts") || {};
  this.reparseSeries();
};

/**
 * Not optimal, but does the trick when you're only using two axes.
 * If we move to more axes, this can just become a function.
 *
 * @type {Object.<number>}
 * @private
 */
DygraphOptions.AXIS_STRING_MAPPINGS_ = {
  'y': 0,
  'Y': 0,
  'y1': 0,
  'Y1': 0,
  'y2': 1,
  'Y2': 1
};

/**
 * @param {string|number} axis
 * @private
 */
DygraphOptions.axisToIndex_ = function (axis) {
  if (typeof axis == "string") {
    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {
      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];
    }
    throw "Unknown axis : " + axis;
  }
  if (typeof axis == "number") {
    if (axis === 0 || axis === 1) {
      return axis;
    }
    throw "Dygraphs only supports two y-axes, indexed from 0-1.";
  }
  if (axis) {
    throw "Unknown axis : " + axis;
  }
  // No axis specification means axis 0.
  return 0;
};

/**
 * Reparses options that are all related to series. This typically occurs when
 * options are either updated, or source data has been made available.
 *
 * TODO(konigsberg): The method name is kind of weak; fix.
 */
DygraphOptions.prototype.reparseSeries = function () {
  var labels = this.get("labels");
  if (!labels) {
    return; // -- can't do more for now, will parse after getting the labels.
  }

  this.labels_ = labels.slice(1);

  this.yAxes_ = [{ series: [], options: {} }]; // Always one axis at least.
  this.xAxis_ = { options: {} };
  this.series_ = {};

  // Series are specified in the series element:
  //
  // {
  //   labels: [ "X", "foo", "bar" ],
  //   pointSize: 3,
  //   series : {
  //     foo : {}, // options for foo
  //     bar : {} // options for bar
  //   }
  // }
  //
  // So, if series is found, it's expected to contain per-series data, otherwise set a
  // default.
  var seriesDict = this.user_.series || {};
  for (var idx = 0; idx < this.labels_.length; idx++) {
    var seriesName = this.labels_[idx];
    var optionsForSeries = seriesDict[seriesName] || {};
    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries["axis"]);

    this.series_[seriesName] = {
      idx: idx,
      yAxis: yAxis,
      options: optionsForSeries };

    if (!this.yAxes_[yAxis]) {
      this.yAxes_[yAxis] = { series: [seriesName], options: {} };
    } else {
      this.yAxes_[yAxis].series.push(seriesName);
    }
  }

  var axis_opts = this.user_["axes"] || {};
  utils.update(this.yAxes_[0].options, axis_opts["y"] || {});
  if (this.yAxes_.length > 1) {
    utils.update(this.yAxes_[1].options, axis_opts["y2"] || {});
  }
  utils.update(this.xAxis_.options, axis_opts["x"] || {});

  // For "production" code, this gets removed by uglifyjs.
  if (typeof process !== 'undefined') {
    if ("development" != 'production') {
      this.validateOptions_();
    }
  }
};

/**
 * Get a global value.
 *
 * @param {string} name the name of the option.
 */
DygraphOptions.prototype.get = function (name) {
  var result = this.getGlobalUser_(name);
  if (result !== null) {
    return result;
  }
  return this.getGlobalDefault_(name);
};

DygraphOptions.prototype.getGlobalUser_ = function (name) {
  if (this.user_.hasOwnProperty(name)) {
    return this.user_[name];
  }
  return null;
};

DygraphOptions.prototype.getGlobalDefault_ = function (name) {
  if (this.global_.hasOwnProperty(name)) {
    return this.global_[name];
  }
  if (_dygraphDefaultAttrs2['default'].hasOwnProperty(name)) {
    return _dygraphDefaultAttrs2['default'][name];
  }
  return null;
};

/**
 * Get a value for a specific axis. If there is no specific value for the axis,
 * the global value is returned.
 *
 * @param {string} name the name of the option.
 * @param {string|number} axis the axis to search. Can be the string representation
 * ("y", "y2") or the axis number (0, 1).
 */
DygraphOptions.prototype.getForAxis = function (name, axis) {
  var axisIdx;
  var axisString;

  // Since axis can be a number or a string, straighten everything out here.
  if (typeof axis == 'number') {
    axisIdx = axis;
    axisString = axisIdx === 0 ? "y" : "y2";
  } else {
    if (axis == "y1") {
      axis = "y";
    } // Standardize on 'y'. Is this bad? I think so.
    if (axis == "y") {
      axisIdx = 0;
    } else if (axis == "y2") {
      axisIdx = 1;
    } else if (axis == "x") {
      axisIdx = -1; // simply a placeholder for below.
    } else {
        throw "Unknown axis " + axis;
      }
    axisString = axis;
  }

  var userAxis = axisIdx == -1 ? this.xAxis_ : this.yAxes_[axisIdx];

  // Search the user-specified axis option first.
  if (userAxis) {
    // This condition could be removed if we always set up this.yAxes_ for y2.
    var axisOptions = userAxis.options;
    if (axisOptions.hasOwnProperty(name)) {
      return axisOptions[name];
    }
  }

  // User-specified global options second.
  // But, hack, ignore globally-specified 'logscale' for 'x' axis declaration.
  if (!(axis === 'x' && name === 'logscale')) {
    var result = this.getGlobalUser_(name);
    if (result !== null) {
      return result;
    }
  }
  // Default axis options third.
  var defaultAxisOptions = _dygraphDefaultAttrs2['default'].axes[axisString];
  if (defaultAxisOptions.hasOwnProperty(name)) {
    return defaultAxisOptions[name];
  }

  // Default global options last.
  return this.getGlobalDefault_(name);
};

/**
 * Get a value for a specific series. If there is no specific value for the series,
 * the value for the axis is returned (and afterwards, the global value.)
 *
 * @param {string} name the name of the option.
 * @param {string} series the series to search.
 */
DygraphOptions.prototype.getForSeries = function (name, series) {
  // Honors indexes as series.
  if (series === this.dygraph_.getHighlightSeries()) {
    if (this.highlightSeries_.hasOwnProperty(name)) {
      return this.highlightSeries_[name];
    }
  }

  if (!this.series_.hasOwnProperty(series)) {
    throw "Unknown series: " + series;
  }

  var seriesObj = this.series_[series];
  var seriesOptions = seriesObj["options"];
  if (seriesOptions.hasOwnProperty(name)) {
    return seriesOptions[name];
  }

  return this.getForAxis(name, seriesObj["yAxis"]);
};

/**
 * Returns the number of y-axes on the chart.
 * @return {number} the number of axes.
 */
DygraphOptions.prototype.numAxes = function () {
  return this.yAxes_.length;
};

/**
 * Return the y-axis for a given series, specified by name.
 */
DygraphOptions.prototype.axisForSeries = function (series) {
  return this.series_[series].yAxis;
};

/**
 * Returns the options for the specified axis.
 */
// TODO(konigsberg): this is y-axis specific. Support the x axis.
DygraphOptions.prototype.axisOptions = function (yAxis) {
  return this.yAxes_[yAxis].options;
};

/**
 * Return the series associated with an axis.
 */
DygraphOptions.prototype.seriesForAxis = function (yAxis) {
  return this.yAxes_[yAxis].series;
};

/**
 * Return the list of all series, in their columnar order.
 */
DygraphOptions.prototype.seriesNames = function () {
  return this.labels_;
};

// For "production" code, this gets removed by uglifyjs.
if (typeof process !== 'undefined') {
  if ("development" != 'production') {

    /**
     * Validate all options.
     * This requires OPTIONS_REFERENCE, which is only available in debug builds.
     * @private
     */
    DygraphOptions.prototype.validateOptions_ = function () {
      if (typeof _dygraphOptionsReference2['default'] === 'undefined') {
        throw 'Called validateOptions_ in prod build.';
      }

      var that = this;
      var validateOption = function validateOption(optionName) {
        if (!_dygraphOptionsReference2['default'][optionName]) {
          that.warnInvalidOption_(optionName);
        }
      };

      var optionsDicts = [this.xAxis_.options, this.yAxes_[0].options, this.yAxes_[1] && this.yAxes_[1].options, this.global_, this.user_, this.highlightSeries_];
      var names = this.seriesNames();
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (this.series_.hasOwnProperty(name)) {
          optionsDicts.push(this.series_[name].options);
        }
      }
      for (var i = 0; i < optionsDicts.length; i++) {
        var dict = optionsDicts[i];
        if (!dict) continue;
        for (var optionName in dict) {
          if (dict.hasOwnProperty(optionName)) {
            validateOption(optionName);
          }
        }
      }
    };

    var WARNINGS = {}; // Only show any particular warning once.

    /**
     * Logs a warning about invalid options.
     * TODO: make this throw for testing
     * @private
     */
    DygraphOptions.prototype.warnInvalidOption_ = function (optionName) {
      if (!WARNINGS[optionName]) {
        WARNINGS[optionName] = true;
        var isSeries = this.labels_.indexOf(optionName) >= 0;
        if (isSeries) {
          console.warn('Use new-style per-series options (saw ' + optionName + ' as top-level options key). See http://bit.ly/1tceaJs');
        } else {
          console.warn('Unknown option ' + optionName + ' (full list of options at dygraphs.com/options.html');
        }
        throw "invalid option " + optionName;
      }
    };

    // Reset list of previously-shown warnings. Used for testing.
    DygraphOptions.resetWarnings_ = function () {
      WARNINGS = {};
    };
  }
}

exports['default'] = DygraphOptions;
module.exports = exports['default'];

}).call(this,require('_process'))

},{"./dygraph-default-attrs":10,"./dygraph-options-reference":14,"./dygraph-utils":17,"_process":1}],16:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview Description of this file.
 * @author danvk@google.com (Dan Vanderkam)
 *
 * A ticker is a function with the following interface:
 *
 * function(a, b, pixels, options_view, dygraph, forced_values);
 * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },
 *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },
 *      ...
 *    ]
 *
 * The returned value is called a "tick list".
 *
 * Arguments
 * ---------
 *
 * [a, b] is the range of the axis for which ticks are being generated. For a
 * numeric axis, these will simply be numbers. For a date axis, these will be
 * millis since epoch (convertable to Date objects using "new Date(a)" and "new
 * Date(b)").
 *
 * opts provides access to chart- and axis-specific options. It can be used to
 * access number/date formatting code/options, check for a log scale, etc.
 *
 * pixels is the length of the axis in pixels. opts('pixelsPerLabel') is the
 * minimum amount of space to be allotted to each label. For instance, if
 * pixels=400 and opts('pixelsPerLabel')=40 then the ticker should return
 * between zero and ten (400/40) ticks.
 *
 * dygraph is the Dygraph object for which an axis is being constructed.
 *
 * forced_values is used for secondary y-axes. The tick positions are typically
 * set by the primary y-axis, so the secondary y-axis has no choice in where to
 * put these. It simply has to generate labels for these data values.
 *
 * Tick lists
 * ----------
 * Typically a tick will have both a grid/tick line and a label at one end of
 * that line (at the bottom for an x-axis, at left or right for the y-axis).
 *
 * A tick may be missing one of these two components:
 * - If "label_v" is specified instead of "v", then there will be no tick or
 *   gridline, just a label.
 * - Similarly, if "label" is not specified, then there will be a gridline
 *   without a label.
 *
 * This flexibility is useful in a few situations:
 * - For log scales, some of the tick lines may be too close to all have labels.
 * - For date scales where years are being displayed, it is desirable to display
 *   tick marks at the beginnings of years but labels (e.g. "2006") in the
 *   middle of the years.
 */

/*jshint sub:true */
/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */
var TickList = undefined; // the ' = undefined' keeps jshint happy.

/** @typedef {function(
 *    number,
 *    number,
 *    number,
 *    function(string):*,
 *    Dygraph=,
 *    Array.<number>=
 *  ): TickList}
 */
var Ticker = undefined; // the ' = undefined' keeps jshint happy.

/** @type {Ticker} */
var numericLinearTicks = function numericLinearTicks(a, b, pixels, opts, dygraph, vals) {
  var nonLogscaleOpts = function nonLogscaleOpts(opt) {
    if (opt === 'logscale') return false;
    return opts(opt);
  };
  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);
};

exports.numericLinearTicks = numericLinearTicks;
/** @type {Ticker} */
var numericTicks = function numericTicks(a, b, pixels, opts, dygraph, vals) {
  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');
  var ticks = [];
  var i, j, tickV, nTicks;
  if (vals) {
    for (i = 0; i < vals.length; i++) {
      ticks.push({ v: vals[i] });
    }
  } else {
    // TODO(danvk): factor this log-scale block out into a separate function.
    if (opts("logscale")) {
      nTicks = Math.floor(pixels / pixels_per_tick);
      var minIdx = utils.binarySearch(a, PREFERRED_LOG_TICK_VALUES, 1);
      var maxIdx = utils.binarySearch(b, PREFERRED_LOG_TICK_VALUES, -1);
      if (minIdx == -1) {
        minIdx = 0;
      }
      if (maxIdx == -1) {
        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;
      }
      // Count the number of tick values would appear, if we can get at least
      // nTicks / 4 accept them.
      var lastDisplayed = null;
      if (maxIdx - minIdx >= nTicks / 4) {
        for (var idx = maxIdx; idx >= minIdx; idx--) {
          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];
          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;
          var tick = { v: tickValue };
          if (lastDisplayed === null) {
            lastDisplayed = {
              tickValue: tickValue,
              pixel_coord: pixel_coord
            };
          } else {
            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {
              lastDisplayed = {
                tickValue: tickValue,
                pixel_coord: pixel_coord
              };
            } else {
              tick.label = "";
            }
          }
          ticks.push(tick);
        }
        // Since we went in backwards order.
        ticks.reverse();
      }
    }

    // ticks.length won't be 0 if the log scale function finds values to insert.
    if (ticks.length === 0) {
      // Basic idea:
      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.
      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).
      // The first spacing greater than pixelsPerYLabel is what we use.
      // TODO(danvk): version that works on a log scale.
      var kmg2 = opts("labelsKMG2");
      var mults, base;
      if (kmg2) {
        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];
        base = 16;
      } else {
        mults = [1, 2, 5, 10, 20, 50, 100];
        base = 10;
      }

      // Get the maximum number of permitted ticks based on the
      // graph's pixel size and pixels_per_tick setting.
      var max_ticks = Math.ceil(pixels / pixels_per_tick);

      // Now calculate the data unit equivalent of this tick spacing.
      // Use abs() since graphs may have a reversed Y axis.
      var units_per_tick = Math.abs(b - a) / max_ticks;

      // Based on this, get a starting scale which is the largest
      // integer power of the chosen base (10 or 16) that still remains
      // below the requested pixels_per_tick spacing.
      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));
      var base_scale = Math.pow(base, base_power);

      // Now try multiples of the starting scale until we find one
      // that results in tick marks spaced sufficiently far apart.
      // The "mults" array should cover the range 1 .. base^2 to
      // adjust for rounding and edge effects.
      var scale, low_val, high_val, spacing;
      for (j = 0; j < mults.length; j++) {
        scale = base_scale * mults[j];
        low_val = Math.floor(a / scale) * scale;
        high_val = Math.ceil(b / scale) * scale;
        nTicks = Math.abs(high_val - low_val) / scale;
        spacing = pixels / nTicks;
        if (spacing > pixels_per_tick) break;
      }

      // Construct the set of ticks.
      // Allow reverse y-axis if it's explicitly requested.
      if (low_val > high_val) scale *= -1;
      for (i = 0; i <= nTicks; i++) {
        tickV = low_val + i * scale;
        ticks.push({ v: tickV });
      }
    }
  }

  var formatter = /**@type{AxisLabelFormatter}*/opts('axisLabelFormatter');

  // Add labels to the ticks.
  for (i = 0; i < ticks.length; i++) {
    if (ticks[i].label !== undefined) continue; // Use current label.
    // TODO(danvk): set granularity to something appropriate here.
    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);
  }

  return ticks;
};

exports.numericTicks = numericTicks;
/** @type {Ticker} */
var dateTicker = function dateTicker(a, b, pixels, opts, dygraph, vals) {
  var chosen = pickDateTickGranularity(a, b, pixels, opts);

  if (chosen >= 0) {
    return getDateAxis(a, b, chosen, opts, dygraph);
  } else {
    // this can happen if self.width_ is zero.
    return [];
  }
};

exports.dateTicker = dateTicker;
// Time granularity enumeration
var Granularity = {
  MILLISECONDLY: 0,
  TWO_MILLISECONDLY: 1,
  FIVE_MILLISECONDLY: 2,
  TEN_MILLISECONDLY: 3,
  FIFTY_MILLISECONDLY: 4,
  HUNDRED_MILLISECONDLY: 5,
  FIVE_HUNDRED_MILLISECONDLY: 6,
  SECONDLY: 7,
  TWO_SECONDLY: 8,
  FIVE_SECONDLY: 9,
  TEN_SECONDLY: 10,
  THIRTY_SECONDLY: 11,
  MINUTELY: 12,
  TWO_MINUTELY: 13,
  FIVE_MINUTELY: 14,
  TEN_MINUTELY: 15,
  THIRTY_MINUTELY: 16,
  HOURLY: 17,
  TWO_HOURLY: 18,
  SIX_HOURLY: 19,
  DAILY: 20,
  TWO_DAILY: 21,
  WEEKLY: 22,
  MONTHLY: 23,
  QUARTERLY: 24,
  BIANNUAL: 25,
  ANNUAL: 26,
  DECADAL: 27,
  CENTENNIAL: 28,
  NUM_GRANULARITIES: 29
};

exports.Granularity = Granularity;
// Date components enumeration (in the order of the arguments in Date)
// TODO: make this an @enum
var DateField = {
  DATEFIELD_Y: 0,
  DATEFIELD_M: 1,
  DATEFIELD_D: 2,
  DATEFIELD_HH: 3,
  DATEFIELD_MM: 4,
  DATEFIELD_SS: 5,
  DATEFIELD_MS: 6,
  NUM_DATEFIELDS: 7
};

/**
 * The value of datefield will start at an even multiple of "step", i.e.
 *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.
 *
 * For granularities <= HOURLY, ticks are generated every `spacing` ms.
 *
 * At coarser granularities, ticks are generated by incrementing `datefield` by
 *   `step`. In this case, the `spacing` value is only used to estimate the
 *   number of ticks. It should roughly correspond to the spacing between
 *   adjacent ticks.
 *
 * @type {Array.<{datefield:number, step:number, spacing:number}>}
 */
var TICK_PLACEMENT = [];
TICK_PLACEMENT[Granularity.MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 1, spacing: 1 };
TICK_PLACEMENT[Granularity.TWO_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 2, spacing: 2 };
TICK_PLACEMENT[Granularity.FIVE_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 5, spacing: 5 };
TICK_PLACEMENT[Granularity.TEN_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 10, spacing: 10 };
TICK_PLACEMENT[Granularity.FIFTY_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 50, spacing: 50 };
TICK_PLACEMENT[Granularity.HUNDRED_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 100, spacing: 100 };
TICK_PLACEMENT[Granularity.FIVE_HUNDRED_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 500, spacing: 500 };
TICK_PLACEMENT[Granularity.SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 1, spacing: 1000 * 1 };
TICK_PLACEMENT[Granularity.TWO_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 2, spacing: 1000 * 2 };
TICK_PLACEMENT[Granularity.FIVE_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 5, spacing: 1000 * 5 };
TICK_PLACEMENT[Granularity.TEN_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 10, spacing: 1000 * 10 };
TICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 30, spacing: 1000 * 30 };
TICK_PLACEMENT[Granularity.MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 1, spacing: 1000 * 60 };
TICK_PLACEMENT[Granularity.TWO_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 2, spacing: 1000 * 60 * 2 };
TICK_PLACEMENT[Granularity.FIVE_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 5, spacing: 1000 * 60 * 5 };
TICK_PLACEMENT[Granularity.TEN_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 10, spacing: 1000 * 60 * 10 };
TICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 30, spacing: 1000 * 60 * 30 };
TICK_PLACEMENT[Granularity.HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 1, spacing: 1000 * 3600 };
TICK_PLACEMENT[Granularity.TWO_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 2, spacing: 1000 * 3600 * 2 };
TICK_PLACEMENT[Granularity.SIX_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 6, spacing: 1000 * 3600 * 6 };
TICK_PLACEMENT[Granularity.DAILY] = { datefield: DateField.DATEFIELD_D, step: 1, spacing: 1000 * 86400 };
TICK_PLACEMENT[Granularity.TWO_DAILY] = { datefield: DateField.DATEFIELD_D, step: 2, spacing: 1000 * 86400 * 2 };
TICK_PLACEMENT[Granularity.WEEKLY] = { datefield: DateField.DATEFIELD_D, step: 7, spacing: 1000 * 604800 };
TICK_PLACEMENT[Granularity.MONTHLY] = { datefield: DateField.DATEFIELD_M, step: 1, spacing: 1000 * 7200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 12
TICK_PLACEMENT[Granularity.QUARTERLY] = { datefield: DateField.DATEFIELD_M, step: 3, spacing: 1000 * 21600 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 4
TICK_PLACEMENT[Granularity.BIANNUAL] = { datefield: DateField.DATEFIELD_M, step: 6, spacing: 1000 * 43200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 2
TICK_PLACEMENT[Granularity.ANNUAL] = { datefield: DateField.DATEFIELD_Y, step: 1, spacing: 1000 * 86400 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 1
TICK_PLACEMENT[Granularity.DECADAL] = { datefield: DateField.DATEFIELD_Y, step: 10, spacing: 1000 * 864000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 10
TICK_PLACEMENT[Granularity.CENTENNIAL] = { datefield: DateField.DATEFIELD_Y, step: 100, spacing: 1000 * 8640000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 100

/**
 * This is a list of human-friendly values at which to show tick marks on a log
 * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:
 * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...
 * NOTE: this assumes that utils.LOG_SCALE = 10.
 * @type {Array.<number>}
 */
var PREFERRED_LOG_TICK_VALUES = (function () {
  var vals = [];
  for (var power = -39; power <= 39; power++) {
    var range = Math.pow(10, power);
    for (var mult = 1; mult <= 9; mult++) {
      var val = range * mult;
      vals.push(val);
    }
  }
  return vals;
})();

/**
 * Determine the correct granularity of ticks on a date axis.
 *
 * @param {number} a Left edge of the chart (ms)
 * @param {number} b Right edge of the chart (ms)
 * @param {number} pixels Size of the chart in the relevant dimension (width).
 * @param {function(string):*} opts Function mapping from option name -&gt; value.
 * @return {number} The appropriate axis granularity for this chart. See the
 *     enumeration of possible values in dygraph-tickers.js.
 */
var pickDateTickGranularity = function pickDateTickGranularity(a, b, pixels, opts) {
  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');
  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {
    var num_ticks = numDateTicks(a, b, i);
    if (pixels / num_ticks >= pixels_per_tick) {
      return i;
    }
  }
  return -1;
};

/**
 * Compute the number of ticks on a date axis for a given granularity.
 * @param {number} start_time
 * @param {number} end_time
 * @param {number} granularity (one of the granularities enumerated above)
 * @return {number} (Approximate) number of ticks that would result.
 */
var numDateTicks = function numDateTicks(start_time, end_time, granularity) {
  var spacing = TICK_PLACEMENT[granularity].spacing;
  return Math.round(1.0 * (end_time - start_time) / spacing);
};

/**
 * Compute the positions and labels of ticks on a date axis for a given granularity.
 * @param {number} start_time
 * @param {number} end_time
 * @param {number} granularity (one of the granularities enumerated above)
 * @param {function(string):*} opts Function mapping from option name -&gt; value.
 * @param {Dygraph=} dg
 * @return {!TickList}
 */
var getDateAxis = function getDateAxis(start_time, end_time, granularity, opts, dg) {
  var formatter = /** @type{AxisLabelFormatter} */opts("axisLabelFormatter");
  var utc = opts("labelsUTC");
  var accessors = utc ? utils.DateAccessorsUTC : utils.DateAccessorsLocal;

  var datefield = TICK_PLACEMENT[granularity].datefield;
  var step = TICK_PLACEMENT[granularity].step;
  var spacing = TICK_PLACEMENT[granularity].spacing;

  // Choose a nice tick position before the initial instant.
  // Currently, this code deals properly with the existent daily granularities:
  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).
  // Other daily granularities (say TWO_DAILY) should also be handled specially
  // by setting the start_date_offset to 0.
  var start_date = new Date(start_time);
  var date_array = [];
  date_array[DateField.DATEFIELD_Y] = accessors.getFullYear(start_date);
  date_array[DateField.DATEFIELD_M] = accessors.getMonth(start_date);
  date_array[DateField.DATEFIELD_D] = accessors.getDate(start_date);
  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);
  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);
  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);
  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);

  var start_date_offset = date_array[datefield] % step;
  if (granularity == Granularity.WEEKLY) {
    // This will put the ticks on Sundays.
    start_date_offset = accessors.getDay(start_date);
  }

  date_array[datefield] -= start_date_offset;
  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {
    // The minimum value is 1 for the day of month, and 0 for all other fields.
    date_array[df] = df === DateField.DATEFIELD_D ? 1 : 0;
  }

  // Generate the ticks.
  // For granularities not coarser than HOURLY we use the fact that:
  //   the number of milliseconds between ticks is constant
  //   and equal to the defined spacing.
  // Otherwise we rely on the 'roll over' property of the Date functions:
  //   when some date field is set to a value outside of its logical range,
  //   the excess 'rolls over' the next (more significant) field.
  // However, when using local time with DST transitions,
  // there are dates that do not represent any time value at all
  // (those in the hour skipped at the 'spring forward'),
  // and the JavaScript engines usually return an equivalent value.
  // Hence we have to check that the date is properly increased at each step,
  // returning a date at a nice tick position.
  var ticks = [];
  var tick_date = accessors.makeDate.apply(null, date_array);
  var tick_time = tick_date.getTime();
  if (granularity <= Granularity.HOURLY) {
    if (tick_time < start_time) {
      tick_time += spacing;
      tick_date = new Date(tick_time);
    }
    while (tick_time <= end_time) {
      ticks.push({ v: tick_time,
        label: formatter.call(dg, tick_date, granularity, opts, dg)
      });
      tick_time += spacing;
      tick_date = new Date(tick_time);
    }
  } else {
    if (tick_time < start_time) {
      date_array[datefield] += step;
      tick_date = accessors.makeDate.apply(null, date_array);
      tick_time = tick_date.getTime();
    }
    while (tick_time <= end_time) {
      if (granularity >= Granularity.DAILY || accessors.getHours(tick_date) % step === 0) {
        ticks.push({ v: tick_time,
          label: formatter.call(dg, tick_date, granularity, opts, dg)
        });
      }
      date_array[datefield] += step;
      tick_date = accessors.makeDate.apply(null, date_array);
      tick_time = tick_date.getTime();
    }
  }
  return ticks;
};
exports.getDateAxis = getDateAxis;

},{"./dygraph-utils":17}],17:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview This file contains utility functions used by dygraphs. These
 * are typically static (i.e. not related to any particular dygraph). Examples
 * include date/time formatting functions, basic algorithms (e.g. binary
 * search) and generic DOM-manipulation functions.
 */

/*global Dygraph:false, Node:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeEvent = removeEvent;
exports.cancelEvent = cancelEvent;
exports.hsvToRGB = hsvToRGB;
exports.findPos = findPos;
exports.pageX = pageX;
exports.pageY = pageY;
exports.dragGetX_ = dragGetX_;
exports.dragGetY_ = dragGetY_;
exports.isOK = isOK;
exports.isValidPoint = isValidPoint;
exports.floatFormat = floatFormat;
exports.zeropad = zeropad;
exports.hmsString_ = hmsString_;
exports.dateString_ = dateString_;
exports.round_ = round_;
exports.binarySearch = binarySearch;
exports.dateParser = dateParser;
exports.dateStrToMillis = dateStrToMillis;
exports.update = update;
exports.updateDeep = updateDeep;
exports.isArrayLike = isArrayLike;
exports.isDateLike = isDateLike;
exports.clone = clone;
exports.createCanvas = createCanvas;
exports.getContextPixelRatio = getContextPixelRatio;
exports.Iterator = Iterator;
exports.createIterator = createIterator;
exports.repeatAndCleanup = repeatAndCleanup;
exports.isPixelChangingOptionList = isPixelChangingOptionList;
exports.detectLineDelimiter = detectLineDelimiter;
exports.isNodeContainedBy = isNodeContainedBy;
exports.pow = pow;
exports.toRGB_ = toRGB_;
exports.isCanvasSupported = isCanvasSupported;
exports.parseFloat_ = parseFloat_;
exports.numberValueFormatter = numberValueFormatter;
exports.numberAxisLabelFormatter = numberAxisLabelFormatter;
exports.dateAxisLabelFormatter = dateAxisLabelFormatter;
exports.dateValueFormatter = dateValueFormatter;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphTickers = require('./dygraph-tickers');

var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

var LOG_SCALE = 10;
exports.LOG_SCALE = LOG_SCALE;
var LN_TEN = Math.log(LOG_SCALE);

exports.LN_TEN = LN_TEN;
/**
 * @private
 * @param {number} x
 * @return {number}
 */
var log10 = function log10(x) {
  return Math.log(x) / LN_TEN;
};

exports.log10 = log10;
/**
 * @private
 * @param {number} r0
 * @param {number} r1
 * @param {number} pct
 * @return {number}
 */
var logRangeFraction = function logRangeFraction(r0, r1, pct) {
  // Computing the inverse of toPercentXCoord. The function was arrived at with
  // the following steps:
  //
  // Original calcuation:
  // pct = (log(x) - log(xRange[0])) / (log(xRange[1]) - log(xRange[0])));
  //
  // Multiply both sides by the right-side denominator.
  // pct * (log(xRange[1] - log(xRange[0]))) = log(x) - log(xRange[0])
  //
  // add log(xRange[0]) to both sides
  // log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])) = log(x);
  //
  // Swap both sides of the equation,
  // log(x) = log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0]))
  //
  // Use both sides as the exponent in 10^exp and we're done.
  // x = 10 ^ (log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])))

  var logr0 = log10(r0);
  var logr1 = log10(r1);
  var exponent = logr0 + pct * (logr1 - logr0);
  var value = Math.pow(LOG_SCALE, exponent);
  return value;
};

exports.logRangeFraction = logRangeFraction;
/** A dotted line stroke pattern. */
var DOTTED_LINE = [2, 2];
exports.DOTTED_LINE = DOTTED_LINE;
/** A dashed line stroke pattern. */
var DASHED_LINE = [7, 3];
exports.DASHED_LINE = DASHED_LINE;
/** A dot dash stroke pattern. */
var DOT_DASH_LINE = [7, 2, 2, 2];

exports.DOT_DASH_LINE = DOT_DASH_LINE;
// Directions for panning and zooming. Use bit operations when combined
// values are possible.
var HORIZONTAL = 1;
exports.HORIZONTAL = HORIZONTAL;
var VERTICAL = 2;

exports.VERTICAL = VERTICAL;
/**
 * Return the 2d context for a dygraph canvas.
 *
 * This method is only exposed for the sake of replacing the function in
 * automated tests.
 *
 * @param {!HTMLCanvasElement} canvas
 * @return {!CanvasRenderingContext2D}
 * @private
 */
var getContext = function getContext(canvas) {
  return (/** @type{!CanvasRenderingContext2D}*/canvas.getContext("2d")
  );
};

exports.getContext = getContext;
/**
 * Add an event handler.
 * @param {!Node} elem The element to add the event to.
 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
 * @param {function(Event):(boolean|undefined)} fn The function to call
 *     on the event. The function takes one parameter: the event object.
 * @private
 */
var addEvent = function addEvent(elem, type, fn) {
  elem.addEventListener(type, fn, false);
};

exports.addEvent = addEvent;
/**
 * Remove an event handler.
 * @param {!Node} elem The element to remove the event from.
 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
 * @param {function(Event):(boolean|undefined)} fn The function to call
 *     on the event. The function takes one parameter: the event object.
 */

function removeEvent(elem, type, fn) {
  elem.removeEventListener(type, fn, false);
}

;

/**
 * Cancels further processing of an event. This is useful to prevent default
 * browser actions, e.g. highlighting text on a double-click.
 * Based on the article at
 * http://www.switchonthecode.com/tutorials/javascript-tutorial-the-scroll-wheel
 * @param {!Event} e The event whose normal behavior should be canceled.
 * @private
 */

function cancelEvent(e) {
  e = e ? e : window.event;
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
  e.cancelBubble = true;
  e.cancel = true;
  e.returnValue = false;
  return false;
}

;

/**
 * Convert hsv values to an rgb(r,g,b) string. Taken from MochiKit.Color. This
 * is used to generate default series colors which are evenly spaced on the
 * color wheel.
 * @param { number } hue Range is 0.0-1.0.
 * @param { number } saturation Range is 0.0-1.0.
 * @param { number } value Range is 0.0-1.0.
 * @return { string } "rgb(r,g,b)" where r, g and b range from 0-255.
 * @private
 */

function hsvToRGB(hue, saturation, value) {
  var red;
  var green;
  var blue;
  if (saturation === 0) {
    red = value;
    green = value;
    blue = value;
  } else {
    var i = Math.floor(hue * 6);
    var f = hue * 6 - i;
    var p = value * (1 - saturation);
    var q = value * (1 - saturation * f);
    var t = value * (1 - saturation * (1 - f));
    switch (i) {
      case 1:
        red = q;green = value;blue = p;break;
      case 2:
        red = p;green = value;blue = t;break;
      case 3:
        red = p;green = q;blue = value;break;
      case 4:
        red = t;green = p;blue = value;break;
      case 5:
        red = value;green = p;blue = q;break;
      case 6: // fall through
      case 0:
        red = value;green = t;blue = p;break;
    }
  }
  red = Math.floor(255 * red + 0.5);
  green = Math.floor(255 * green + 0.5);
  blue = Math.floor(255 * blue + 0.5);
  return 'rgb(' + red + ',' + green + ',' + blue + ')';
}

;

/**
 * Find the coordinates of an object relative to the top left of the page.
 *
 * @param {Node} obj
 * @return {{x:number,y:number}}
 * @private
 */

function findPos(obj) {
  var p = obj.getBoundingClientRect(),
      w = window,
      d = document.documentElement;

  return {
    x: p.left + (w.pageXOffset || d.scrollLeft),
    y: p.top + (w.pageYOffset || d.scrollTop)
  };
}

;

/**
 * Returns the x-coordinate of the event in a coordinate system where the
 * top-left corner of the page (not the window) is (0,0).
 * Taken from MochiKit.Signal
 * @param {!Event} e
 * @return {number}
 * @private
 */

function pageX(e) {
  return !e.pageX || e.pageX < 0 ? 0 : e.pageX;
}

;

/**
 * Returns the y-coordinate of the event in a coordinate system where the
 * top-left corner of the page (not the window) is (0,0).
 * Taken from MochiKit.Signal
 * @param {!Event} e
 * @return {number}
 * @private
 */

function pageY(e) {
  return !e.pageY || e.pageY < 0 ? 0 : e.pageY;
}

;

/**
 * Converts page the x-coordinate of the event to pixel x-coordinates on the
 * canvas (i.e. DOM Coords).
 * @param {!Event} e Drag event.
 * @param {!DygraphInteractionContext} context Interaction context object.
 * @return {number} The amount by which the drag has moved to the right.
 */

function dragGetX_(e, context) {
  return pageX(e) - context.px;
}

;

/**
 * Converts page the y-coordinate of the event to pixel y-coordinates on the
 * canvas (i.e. DOM Coords).
 * @param {!Event} e Drag event.
 * @param {!DygraphInteractionContext} context Interaction context object.
 * @return {number} The amount by which the drag has moved down.
 */

function dragGetY_(e, context) {
  return pageY(e) - context.py;
}

;

/**
 * This returns true unless the parameter is 0, null, undefined or NaN.
 * TODO(danvk): rename this function to something like 'isNonZeroNan'.
 *
 * @param {number} x The number to consider.
 * @return {boolean} Whether the number is zero or NaN.
 * @private
 */

function isOK(x) {
  return !!x && !isNaN(x);
}

;

/**
 * @param {{x:?number,y:?number,yval:?number}} p The point to consider, valid
 *     points are {x, y} objects
 * @param {boolean=} opt_allowNaNY Treat point with y=NaN as valid
 * @return {boolean} Whether the point has numeric x and y.
 * @private
 */

function isValidPoint(p, opt_allowNaNY) {
  if (!p) return false; // null or undefined object
  if (p.yval === null) return false; // missing point
  if (p.x === null || p.x === undefined) return false;
  if (p.y === null || p.y === undefined) return false;
  if (isNaN(p.x) || !opt_allowNaNY && isNaN(p.y)) return false;
  return true;
}

;

/**
 * Number formatting function which mimics the behavior of %g in printf, i.e.
 * either exponential or fixed format (without trailing 0s) is used depending on
 * the length of the generated string.  The advantage of this format is that
 * there is a predictable upper bound on the resulting string length,
 * significant figures are not dropped, and normal numbers are not displayed in
 * exponential notation.
 *
 * NOTE: JavaScript's native toPrecision() is NOT a drop-in replacement for %g.
 * It creates strings which are too long for absolute values between 10^-4 and
 * 10^-6, e.g. '0.00001' instead of '1e-5'. See tests/number-format.html for
 * output examples.
 *
 * @param {number} x The number to format
 * @param {number=} opt_precision The precision to use, default 2.
 * @return {string} A string formatted like %g in printf.  The max generated
 *                  string length should be precision + 6 (e.g 1.123e+300).
 */

function floatFormat(x, opt_precision) {
  // Avoid invalid precision values; [1, 21] is the valid range.
  var p = Math.min(Math.max(1, opt_precision || 2), 21);

  // This is deceptively simple.  The actual algorithm comes from:
  //
  // Max allowed length = p + 4
  // where 4 comes from 'e+n' and '.'.
  //
  // Length of fixed format = 2 + y + p
  // where 2 comes from '0.' and y = # of leading zeroes.
  //
  // Equating the two and solving for y yields y = 2, or 0.00xxxx which is
  // 1.0e-3.
  //
  // Since the behavior of toPrecision() is identical for larger numbers, we
  // don't have to worry about the other bound.
  //
  // Finally, the argument for toExponential() is the number of trailing digits,
  // so we take off 1 for the value before the '.'.
  return Math.abs(x) < 1.0e-3 && x !== 0.0 ? x.toExponential(p - 1) : x.toPrecision(p);
}

;

/**
 * Converts '9' to '09' (useful for dates)
 * @param {number} x
 * @return {string}
 * @private
 */

function zeropad(x) {
  if (x < 10) return "0" + x;else return "" + x;
}

;

/**
 * Date accessors to get the parts of a calendar date (year, month,
 * day, hour, minute, second and millisecond) according to local time,
 * and factory method to call the Date constructor with an array of arguments.
 */
var DateAccessorsLocal = {
  getFullYear: function getFullYear(d) {
    return d.getFullYear();
  },
  getMonth: function getMonth(d) {
    return d.getMonth();
  },
  getDate: function getDate(d) {
    return d.getDate();
  },
  getHours: function getHours(d) {
    return d.getHours();
  },
  getMinutes: function getMinutes(d) {
    return d.getMinutes();
  },
  getSeconds: function getSeconds(d) {
    return d.getSeconds();
  },
  getMilliseconds: function getMilliseconds(d) {
    return d.getMilliseconds();
  },
  getDay: function getDay(d) {
    return d.getDay();
  },
  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {
    return new Date(y, m, d, hh, mm, ss, ms);
  }
};

exports.DateAccessorsLocal = DateAccessorsLocal;
/**
 * Date accessors to get the parts of a calendar date (year, month,
 * day of month, hour, minute, second and millisecond) according to UTC time,
 * and factory method to call the Date constructor with an array of arguments.
 */
var DateAccessorsUTC = {
  getFullYear: function getFullYear(d) {
    return d.getUTCFullYear();
  },
  getMonth: function getMonth(d) {
    return d.getUTCMonth();
  },
  getDate: function getDate(d) {
    return d.getUTCDate();
  },
  getHours: function getHours(d) {
    return d.getUTCHours();
  },
  getMinutes: function getMinutes(d) {
    return d.getUTCMinutes();
  },
  getSeconds: function getSeconds(d) {
    return d.getUTCSeconds();
  },
  getMilliseconds: function getMilliseconds(d) {
    return d.getUTCMilliseconds();
  },
  getDay: function getDay(d) {
    return d.getUTCDay();
  },
  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {
    return new Date(Date.UTC(y, m, d, hh, mm, ss, ms));
  }
};

exports.DateAccessorsUTC = DateAccessorsUTC;
/**
 * Return a string version of the hours, minutes and seconds portion of a date.
 * @param {number} hh The hours (from 0-23)
 * @param {number} mm The minutes (from 0-59)
 * @param {number} ss The seconds (from 0-59)
 * @return {string} A time of the form "HH:MM" or "HH:MM:SS"
 * @private
 */

function hmsString_(hh, mm, ss, ms) {
  var ret = zeropad(hh) + ":" + zeropad(mm);
  if (ss) {
    ret += ":" + zeropad(ss);
    if (ms) {
      var str = "" + ms;
      ret += "." + ('000' + str).substring(str.length);
    }
  }
  return ret;
}

;

/**
 * Convert a JS date (millis since epoch) to a formatted string.
 * @param {number} time The JavaScript time value (ms since epoch)
 * @param {boolean} utc Whether output UTC or local time
 * @return {string} A date of one of these forms:
 *     "YYYY/MM/DD", "YYYY/MM/DD HH:MM" or "YYYY/MM/DD HH:MM:SS"
 * @private
 */

function dateString_(time, utc) {
  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;
  var date = new Date(time);
  var y = accessors.getFullYear(date);
  var m = accessors.getMonth(date);
  var d = accessors.getDate(date);
  var hh = accessors.getHours(date);
  var mm = accessors.getMinutes(date);
  var ss = accessors.getSeconds(date);
  var ms = accessors.getMilliseconds(date);
  // Get a year string:
  var year = "" + y;
  // Get a 0 padded month string
  var month = zeropad(m + 1); //months are 0-offset, sigh
  // Get a 0 padded day string
  var day = zeropad(d);
  var frac = hh * 3600 + mm * 60 + ss + 1e-3 * ms;
  var ret = year + "/" + month + "/" + day;
  if (frac) {
    ret += " " + hmsString_(hh, mm, ss, ms);
  }
  return ret;
}

;

/**
 * Round a number to the specified number of digits past the decimal point.
 * @param {number} num The number to round
 * @param {number} places The number of decimals to which to round
 * @return {number} The rounded number
 * @private
 */

function round_(num, places) {
  var shift = Math.pow(10, places);
  return Math.round(num * shift) / shift;
}

;

/**
 * Implementation of binary search over an array.
 * Currently does not work when val is outside the range of arry's values.
 * @param {number} val the value to search for
 * @param {Array.<number>} arry is the value over which to search
 * @param {number} abs If abs > 0, find the lowest entry greater than val
 *     If abs < 0, find the highest entry less than val.
 *     If abs == 0, find the entry that equals val.
 * @param {number=} low The first index in arry to consider (optional)
 * @param {number=} high The last index in arry to consider (optional)
 * @return {number} Index of the element, or -1 if it isn't found.
 * @private
 */

function binarySearch(_x, _x2, _x3, _x4, _x5) {
  var _again = true;

  _function: while (_again) {
    var val = _x,
        arry = _x2,
        abs = _x3,
        low = _x4,
        high = _x5;
    _again = false;

    if (low === null || low === undefined || high === null || high === undefined) {
      low = 0;
      high = arry.length - 1;
    }
    if (low > high) {
      return -1;
    }
    if (abs === null || abs === undefined) {
      abs = 0;
    }
    var validIndex = function validIndex(idx) {
      return idx >= 0 && idx < arry.length;
    };
    var mid = parseInt((low + high) / 2, 10);
    var element = arry[mid];
    var idx;
    if (element == val) {
      return mid;
    } else if (element > val) {
      if (abs > 0) {
        // Accept if element > val, but also if prior element < val.
        idx = mid - 1;
        if (validIndex(idx) && arry[idx] < val) {
          return mid;
        }
      }
      _x = val;
      _x2 = arry;
      _x3 = abs;
      _x4 = low;
      _x5 = mid - 1;
      _again = true;
      validIndex = mid = element = idx = undefined;
      continue _function;
    } else if (element < val) {
      if (abs < 0) {
        // Accept if element < val, but also if prior element > val.
        idx = mid + 1;
        if (validIndex(idx) && arry[idx] > val) {
          return mid;
        }
      }
      _x = val;
      _x2 = arry;
      _x3 = abs;
      _x4 = mid + 1;
      _x5 = high;
      _again = true;
      validIndex = mid = element = idx = undefined;
      continue _function;
    }
    return -1; // can't actually happen, but makes closure compiler happy
  }
}

;

/**
 * Parses a date, returning the number of milliseconds since epoch. This can be
 * passed in as an xValueParser in the Dygraph constructor.
 * TODO(danvk): enumerate formats that this understands.
 *
 * @param {string} dateStr A date in a variety of possible string formats.
 * @return {number} Milliseconds since epoch.
 * @private
 */

function dateParser(dateStr) {
  var dateStrSlashed;
  var d;

  // Let the system try the format first, with one caveat:
  // YYYY-MM-DD[ HH:MM:SS] is interpreted as UTC by a variety of browsers.
  // dygraphs displays dates in local time, so this will result in surprising
  // inconsistencies. But if you specify "T" or "Z" (i.e. YYYY-MM-DDTHH:MM:SS),
  // then you probably know what you're doing, so we'll let you go ahead.
  // Issue: http://code.google.com/p/dygraphs/issues/detail?id=255
  if (dateStr.search("-") == -1 || dateStr.search("T") != -1 || dateStr.search("Z") != -1) {
    d = dateStrToMillis(dateStr);
    if (d && !isNaN(d)) return d;
  }

  if (dateStr.search("-") != -1) {
    // e.g. '2009-7-12' or '2009-07-12'
    dateStrSlashed = dateStr.replace("-", "/", "g");
    while (dateStrSlashed.search("-") != -1) {
      dateStrSlashed = dateStrSlashed.replace("-", "/");
    }
    d = dateStrToMillis(dateStrSlashed);
  } else if (dateStr.length == 8) {
    // e.g. '20090712'
    // TODO(danvk): remove support for this format. It's confusing.
    dateStrSlashed = dateStr.substr(0, 4) + "/" + dateStr.substr(4, 2) + "/" + dateStr.substr(6, 2);
    d = dateStrToMillis(dateStrSlashed);
  } else {
    // Any format that Date.parse will accept, e.g. "2009/07/12" or
    // "2009/07/12 12:34:56"
    d = dateStrToMillis(dateStr);
  }

  if (!d || isNaN(d)) {
    console.error("Couldn't parse " + dateStr + " as a date");
  }
  return d;
}

;

/**
 * This is identical to JavaScript's built-in Date.parse() method, except that
 * it doesn't get replaced with an incompatible method by aggressive JS
 * libraries like MooTools or Joomla.
 * @param {string} str The date string, e.g. "2011/05/06"
 * @return {number} millis since epoch
 * @private
 */

function dateStrToMillis(str) {
  return new Date(str).getTime();
}

;

// These functions are all based on MochiKit.
/**
 * Copies all the properties from o to self.
 *
 * @param {!Object} self
 * @param {!Object} o
 * @return {!Object}
 */

function update(self, o) {
  if (typeof o != 'undefined' && o !== null) {
    for (var k in o) {
      if (o.hasOwnProperty(k)) {
        self[k] = o[k];
      }
    }
  }
  return self;
}

;

/**
 * Copies all the properties from o to self.
 *
 * @param {!Object} self
 * @param {!Object} o
 * @return {!Object}
 * @private
 */

function updateDeep(self, o) {
  // Taken from http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
  function isNode(o) {
    return typeof Node === "object" ? o instanceof Node : typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
  }

  if (typeof o != 'undefined' && o !== null) {
    for (var k in o) {
      if (o.hasOwnProperty(k)) {
        if (o[k] === null) {
          self[k] = null;
        } else if (isArrayLike(o[k])) {
          self[k] = o[k].slice();
        } else if (isNode(o[k])) {
          // DOM objects are shallowly-copied.
          self[k] = o[k];
        } else if (typeof o[k] == 'object') {
          if (typeof self[k] != 'object' || self[k] === null) {
            self[k] = {};
          }
          updateDeep(self[k], o[k]);
        } else {
          self[k] = o[k];
        }
      }
    }
  }
  return self;
}

;

/**
 * @param {*} o
 * @return {boolean}
 * @private
 */

function isArrayLike(o) {
  var typ = typeof o;
  if (typ != 'object' && !(typ == 'function' && typeof o.item == 'function') || o === null || typeof o.length != 'number' || o.nodeType === 3) {
    return false;
  }
  return true;
}

;

/**
 * @param {Object} o
 * @return {boolean}
 * @private
 */

function isDateLike(o) {
  if (typeof o != "object" || o === null || typeof o.getTime != 'function') {
    return false;
  }
  return true;
}

;

/**
 * Note: this only seems to work for arrays.
 * @param {!Array} o
 * @return {!Array}
 * @private
 */

function clone(o) {
  // TODO(danvk): figure out how MochiKit's version works
  var r = [];
  for (var i = 0; i < o.length; i++) {
    if (isArrayLike(o[i])) {
      r.push(clone(o[i]));
    } else {
      r.push(o[i]);
    }
  }
  return r;
}

;

/**
 * Create a new canvas element.
 *
 * @return {!HTMLCanvasElement}
 * @private
 */

function createCanvas() {
  return document.createElement('canvas');
}

;

/**
 * Returns the context's pixel ratio, which is the ratio between the device
 * pixel ratio and the backing store ratio. Typically this is 1 for conventional
 * displays, and > 1 for HiDPI displays (such as the Retina MBP).
 * See http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for more details.
 *
 * @param {!CanvasRenderingContext2D} context The canvas's 2d context.
 * @return {number} The ratio of the device pixel ratio and the backing store
 * ratio for the specified context.
 */

function getContextPixelRatio(context) {
  try {
    var devicePixelRatio = window.devicePixelRatio;
    var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    if (devicePixelRatio !== undefined) {
      return devicePixelRatio / backingStoreRatio;
    } else {
      // At least devicePixelRatio must be defined for this ratio to make sense.
      // We default backingStoreRatio to 1: this does not exist on some browsers
      // (i.e. desktop Chrome).
      return 1;
    }
  } catch (e) {
    return 1;
  }
}

;

/**
 * TODO(danvk): use @template here when it's better supported for classes.
 * @param {!Array} array
 * @param {number} start
 * @param {number} length
 * @param {function(!Array,?):boolean=} predicate
 * @constructor
 */

function Iterator(array, start, length, predicate) {
  start = start || 0;
  length = length || array.length;
  this.hasNext = true; // Use to identify if there's another element.
  this.peek = null; // Use for look-ahead
  this.start_ = start;
  this.array_ = array;
  this.predicate_ = predicate;
  this.end_ = Math.min(array.length, start + length);
  this.nextIdx_ = start - 1; // use -1 so initial advance works.
  this.next(); // ignoring result.
}

;

/**
 * @return {Object}
 */
Iterator.prototype.next = function () {
  if (!this.hasNext) {
    return null;
  }
  var obj = this.peek;

  var nextIdx = this.nextIdx_ + 1;
  var found = false;
  while (nextIdx < this.end_) {
    if (!this.predicate_ || this.predicate_(this.array_, nextIdx)) {
      this.peek = this.array_[nextIdx];
      found = true;
      break;
    }
    nextIdx++;
  }
  this.nextIdx_ = nextIdx;
  if (!found) {
    this.hasNext = false;
    this.peek = null;
  }
  return obj;
};

/**
 * Returns a new iterator over array, between indexes start and
 * start + length, and only returns entries that pass the accept function
 *
 * @param {!Array} array the array to iterate over.
 * @param {number} start the first index to iterate over, 0 if absent.
 * @param {number} length the number of elements in the array to iterate over.
 *     This, along with start, defines a slice of the array, and so length
 *     doesn't imply the number of elements in the iterator when accept doesn't
 *     always accept all values. array.length when absent.
 * @param {function(?):boolean=} opt_predicate a function that takes
 *     parameters array and idx, which returns true when the element should be
 *     returned.  If omitted, all elements are accepted.
 * @private
 */

function createIterator(array, start, length, opt_predicate) {
  return new Iterator(array, start, length, opt_predicate);
}

;

// Shim layer with setTimeout fallback.
// From: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// Should be called with the window context:
//   Dygraph.requestAnimFrame.call(window, function() {})
var requestAnimFrame = (function () {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
})();

exports.requestAnimFrame = requestAnimFrame;
/**
 * Call a function at most maxFrames times at an attempted interval of
 * framePeriodInMillis, then call a cleanup function once. repeatFn is called
 * once immediately, then at most (maxFrames - 1) times asynchronously. If
 * maxFrames==1, then cleanup_fn() is also called synchronously.  This function
 * is used to sequence animation.
 * @param {function(number)} repeatFn Called repeatedly -- takes the frame
 *     number (from 0 to maxFrames-1) as an argument.
 * @param {number} maxFrames The max number of times to call repeatFn
 * @param {number} framePeriodInMillis Max requested time between frames.
 * @param {function()} cleanupFn A function to call after all repeatFn calls.
 * @private
 */

function repeatAndCleanup(repeatFn, maxFrames, framePeriodInMillis, cleanupFn) {
  var frameNumber = 0;
  var previousFrameNumber;
  var startTime = new Date().getTime();
  repeatFn(frameNumber);
  if (maxFrames == 1) {
    cleanupFn();
    return;
  }
  var maxFrameArg = maxFrames - 1;

  (function loop() {
    if (frameNumber >= maxFrames) return;
    requestAnimFrame.call(window, function () {
      // Determine which frame to draw based on the delay so far.  Will skip
      // frames if necessary.
      var currentTime = new Date().getTime();
      var delayInMillis = currentTime - startTime;
      previousFrameNumber = frameNumber;
      frameNumber = Math.floor(delayInMillis / framePeriodInMillis);
      var frameDelta = frameNumber - previousFrameNumber;
      // If we predict that the subsequent repeatFn call will overshoot our
      // total frame target, so our last call will cause a stutter, then jump to
      // the last call immediately.  If we're going to cause a stutter, better
      // to do it faster than slower.
      var predictOvershootStutter = frameNumber + frameDelta > maxFrameArg;
      if (predictOvershootStutter || frameNumber >= maxFrameArg) {
        repeatFn(maxFrameArg); // Ensure final call with maxFrameArg.
        cleanupFn();
      } else {
        if (frameDelta !== 0) {
          // Don't call repeatFn with duplicate frames.
          repeatFn(frameNumber);
        }
        loop();
      }
    });
  })();
}

;

// A whitelist of options that do not change pixel positions.
var pixelSafeOptions = {
  'annotationClickHandler': true,
  'annotationDblClickHandler': true,
  'annotationMouseOutHandler': true,
  'annotationMouseOverHandler': true,
  'axisLineColor': true,
  'axisLineWidth': true,
  'clickCallback': true,
  'drawCallback': true,
  'drawHighlightPointCallback': true,
  'drawPoints': true,
  'drawPointCallback': true,
  'drawGrid': true,
  'fillAlpha': true,
  'gridLineColor': true,
  'gridLineWidth': true,
  'hideOverlayOnMouseOut': true,
  'highlightCallback': true,
  'highlightCircleSize': true,
  'interactionModel': true,
  'labelsDiv': true,
  'labelsKMB': true,
  'labelsKMG2': true,
  'labelsSeparateLines': true,
  'labelsShowZeroValues': true,
  'legend': true,
  'panEdgeFraction': true,
  'pixelsPerYLabel': true,
  'pointClickCallback': true,
  'pointSize': true,
  'rangeSelectorPlotFillColor': true,
  'rangeSelectorPlotFillGradientColor': true,
  'rangeSelectorPlotStrokeColor': true,
  'rangeSelectorBackgroundStrokeColor': true,
  'rangeSelectorBackgroundLineWidth': true,
  'rangeSelectorPlotLineWidth': true,
  'rangeSelectorForegroundStrokeColor': true,
  'rangeSelectorForegroundLineWidth': true,
  'rangeSelectorAlpha': true,
  'showLabelsOnHighlight': true,
  'showRoller': true,
  'strokeWidth': true,
  'underlayCallback': true,
  'unhighlightCallback': true,
  'zoomCallback': true
};

/**
 * This function will scan the option list and determine if they
 * require us to recalculate the pixel positions of each point.
 * TODO: move this into dygraph-options.js
 * @param {!Array.<string>} labels a list of options to check.
 * @param {!Object} attrs
 * @return {boolean} true if the graph needs new points else false.
 * @private
 */

function isPixelChangingOptionList(labels, attrs) {
  // Assume that we do not require new points.
  // This will change to true if we actually do need new points.

  // Create a dictionary of series names for faster lookup.
  // If there are no labels, then the dictionary stays empty.
  var seriesNamesDictionary = {};
  if (labels) {
    for (var i = 1; i < labels.length; i++) {
      seriesNamesDictionary[labels[i]] = true;
    }
  }

  // Scan through a flat (i.e. non-nested) object of options.
  // Returns true/false depending on whether new points are needed.
  var scanFlatOptions = function scanFlatOptions(options) {
    for (var property in options) {
      if (options.hasOwnProperty(property) && !pixelSafeOptions[property]) {
        return true;
      }
    }
    return false;
  };

  // Iterate through the list of updated options.
  for (var property in attrs) {
    if (!attrs.hasOwnProperty(property)) continue;

    // Find out of this field is actually a series specific options list.
    if (property == 'highlightSeriesOpts' || seriesNamesDictionary[property] && !attrs.series) {
      // This property value is a list of options for this series.
      if (scanFlatOptions(attrs[property])) return true;
    } else if (property == 'series' || property == 'axes') {
      // This is twice-nested options list.
      var perSeries = attrs[property];
      for (var series in perSeries) {
        if (perSeries.hasOwnProperty(series) && scanFlatOptions(perSeries[series])) {
          return true;
        }
      }
    } else {
      // If this was not a series specific option list, check if it's a pixel
      // changing property.
      if (!pixelSafeOptions[property]) return true;
    }
  }

  return false;
}

;

var Circles = {
  DEFAULT: function DEFAULT(g, name, ctx, canvasx, canvasy, color, radius) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(canvasx, canvasy, radius, 0, 2 * Math.PI, false);
    ctx.fill();
  }
  // For more shapes, include extras/shapes.js
};

exports.Circles = Circles;
/**
 * Determine whether |data| is delimited by CR, CRLF, LF, LFCR.
 * @param {string} data
 * @return {?string} the delimiter that was detected (or null on failure).
 */

function detectLineDelimiter(data) {
  for (var i = 0; i < data.length; i++) {
    var code = data.charAt(i);
    if (code === '\\r') {
      // Might actually be "\\r\\n".
      if (i + 1 < data.length && data.charAt(i + 1) === '\\n') {
        return '\\r\\n';
      }
      return code;
    }
    if (code === '\\n') {
      // Might actually be "\\n\\r".
      if (i + 1 < data.length && data.charAt(i + 1) === '\\r') {
        return '\\n\\r';
      }
      return code;
    }
  }

  return null;
}

;

/**
 * Is one node contained by another?
 * @param {Node} containee The contained node.
 * @param {Node} container The container node.
 * @return {boolean} Whether containee is inside (or equal to) container.
 * @private
 */

function isNodeContainedBy(containee, container) {
  if (container === null || containee === null) {
    return false;
  }
  var containeeNode = /** @type {Node} */containee;
  while (containeeNode && containeeNode !== container) {
    containeeNode = containeeNode.parentNode;
  }
  return containeeNode === container;
}

;

// This masks some numeric issues in older versions of Firefox,
// where 1.0/Math.pow(10,2) != Math.pow(10,-2).
/** @type {function(number,number):number} */

function pow(base, exp) {
  if (exp < 0) {
    return 1.0 / Math.pow(base, -exp);
  }
  return Math.pow(base, exp);
}

;

var RGBA_RE = /^rgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(?:,\s*([01](?:\.\d+)?))?\)$/;

/**
 * Helper for toRGB_ which parses strings of the form:
 * rgb(123, 45, 67)
 * rgba(123, 45, 67, 0.5)
 * @return parsed {r,g,b,a?} tuple or null.
 */
function parseRGBA(rgbStr) {
  var bits = RGBA_RE.exec(rgbStr);
  if (!bits) return null;
  var r = parseInt(bits[1], 10),
      g = parseInt(bits[2], 10),
      b = parseInt(bits[3], 10);
  if (bits[4]) {
    return { r: r, g: g, b: b, a: parseFloat(bits[4]) };
  } else {
    return { r: r, g: g, b: b };
  }
}

/**
 * Converts any valid CSS color (hex, rgb(), named color) to an RGB tuple.
 *
 * @param {!string} colorStr Any valid CSS color string.
 * @return {{r:number,g:number,b:number,a:number?}} Parsed RGB tuple.
 * @private
 */

function toRGB_(colorStr) {
  // Strategy: First try to parse colorStr directly. This is fast & avoids DOM
  // manipulation.  If that fails (e.g. for named colors like 'red'), then
  // create a hidden DOM element and parse its computed color.
  var rgb = parseRGBA(colorStr);
  if (rgb) return rgb;

  var div = document.createElement('div');
  div.style.backgroundColor = colorStr;
  div.style.visibility = 'hidden';
  document.body.appendChild(div);
  var rgbStr = window.getComputedStyle(div, null).backgroundColor;
  document.body.removeChild(div);
  return parseRGBA(rgbStr);
}

;

/**
 * Checks whether the browser supports the &lt;canvas&gt; tag.
 * @param {HTMLCanvasElement=} opt_canvasElement Pass a canvas element as an
 *     optimization if you have one.
 * @return {boolean} Whether the browser supports canvas.
 */

function isCanvasSupported(opt_canvasElement) {
  try {
    var canvas = opt_canvasElement || document.createElement("canvas");
    canvas.getContext("2d");
  } catch (e) {
    return false;
  }
  return true;
}

;

/**
 * Parses the value as a floating point number. This is like the parseFloat()
 * built-in, but with a few differences:
 * - the empty string is parsed as null, rather than NaN.
 * - if the string cannot be parsed at all, an error is logged.
 * If the string can't be parsed, this method returns null.
 * @param {string} x The string to be parsed
 * @param {number=} opt_line_no The line number from which the string comes.
 * @param {string=} opt_line The text of the line from which the string comes.
 */

function parseFloat_(x, opt_line_no, opt_line) {
  var val = parseFloat(x);
  if (!isNaN(val)) return val;

  // Try to figure out what happeend.
  // If the value is the empty string, parse it as null.
  if (/^ *$/.test(x)) return null;

  // If it was actually "NaN", return it as NaN.
  if (/^ *nan *$/i.test(x)) return NaN;

  // Looks like a parsing error.
  var msg = "Unable to parse '" + x + "' as a number";
  if (opt_line !== undefined && opt_line_no !== undefined) {
    msg += " on line " + (1 + (opt_line_no || 0)) + " ('" + opt_line + "') of CSV.";
  }
  console.error(msg);

  return null;
}

;

// Label constants for the labelsKMB and labelsKMG2 options.
// (i.e. '100000' -> '100K')
var KMB_LABELS = ['K', 'M', 'B', 'T', 'Q'];
var KMG2_BIG_LABELS = ['k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
var KMG2_SMALL_LABELS = ['m', 'u', 'n', 'p', 'f', 'a', 'z', 'y'];

/**
 * @private
 * Return a string version of a number. This respects the digitsAfterDecimal
 * and maxNumberWidth options.
 * @param {number} x The number to be formatted
 * @param {Dygraph} opts An options view
 */

function numberValueFormatter(x, opts) {
  var sigFigs = opts('sigFigs');

  if (sigFigs !== null) {
    // User has opted for a fixed number of significant figures.
    return floatFormat(x, sigFigs);
  }

  var digits = opts('digitsAfterDecimal');
  var maxNumberWidth = opts('maxNumberWidth');

  var kmb = opts('labelsKMB');
  var kmg2 = opts('labelsKMG2');

  var label;

  // switch to scientific notation if we underflow or overflow fixed display.
  if (x !== 0.0 && (Math.abs(x) >= Math.pow(10, maxNumberWidth) || Math.abs(x) < Math.pow(10, -digits))) {
    label = x.toExponential(digits);
  } else {
    label = '' + round_(x, digits);
  }

  if (kmb || kmg2) {
    var k;
    var k_labels = [];
    var m_labels = [];
    if (kmb) {
      k = 1000;
      k_labels = KMB_LABELS;
    }
    if (kmg2) {
      if (kmb) console.warn("Setting both labelsKMB and labelsKMG2. Pick one!");
      k = 1024;
      k_labels = KMG2_BIG_LABELS;
      m_labels = KMG2_SMALL_LABELS;
    }

    var absx = Math.abs(x);
    var n = pow(k, k_labels.length);
    for (var j = k_labels.length - 1; j >= 0; j--, n /= k) {
      if (absx >= n) {
        label = round_(x / n, digits) + k_labels[j];
        break;
      }
    }
    if (kmg2) {
      // TODO(danvk): clean up this logic. Why so different than kmb?
      var x_parts = String(x.toExponential()).split('e-');
      if (x_parts.length === 2 && x_parts[1] >= 3 && x_parts[1] <= 24) {
        if (x_parts[1] % 3 > 0) {
          label = round_(x_parts[0] / pow(10, x_parts[1] % 3), digits);
        } else {
          label = Number(x_parts[0]).toFixed(2);
        }
        label += m_labels[Math.floor(x_parts[1] / 3) - 1];
      }
    }
  }

  return label;
}

;

/**
 * variant for use as an axisLabelFormatter.
 * @private
 */

function numberAxisLabelFormatter(x, granularity, opts) {
  return numberValueFormatter.call(this, x, opts);
}

;

/**
 * @type {!Array.<string>}
 * @private
 * @constant
 */
var SHORT_MONTH_NAMES_ = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

/**
 * Convert a JS date to a string appropriate to display on an axis that
 * is displaying values at the stated granularity. This respects the
 * labelsUTC option.
 * @param {Date} date The date to format
 * @param {number} granularity One of the Dygraph granularity constants
 * @param {Dygraph} opts An options view
 * @return {string} The date formatted as local time
 * @private
 */

function dateAxisLabelFormatter(date, granularity, opts) {
  var utc = opts('labelsUTC');
  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;

  var year = accessors.getFullYear(date),
      month = accessors.getMonth(date),
      day = accessors.getDate(date),
      hours = accessors.getHours(date),
      mins = accessors.getMinutes(date),
      secs = accessors.getSeconds(date),
      millis = accessors.getMilliseconds(date);

  if (granularity >= DygraphTickers.Granularity.DECADAL) {
    return '' + year;
  } else if (granularity >= DygraphTickers.Granularity.MONTHLY) {
    return SHORT_MONTH_NAMES_[month] + '&#160;' + year;
  } else {
    var frac = hours * 3600 + mins * 60 + secs + 1e-3 * millis;
    if (frac === 0 || granularity >= DygraphTickers.Granularity.DAILY) {
      // e.g. '21 Jan' (%d%b)
      return zeropad(day) + '&#160;' + SHORT_MONTH_NAMES_[month];
    } else if (granularity < DygraphTickers.Granularity.SECONDLY) {
      // e.g. 40.310 (meaning 40 seconds and 310 milliseconds)
      var str = "" + millis;
      return zeropad(secs) + "." + ('000' + str).substring(str.length);
    } else if (granularity > DygraphTickers.Granularity.MINUTELY) {
      return hmsString_(hours, mins, secs, 0);
    } else {
      return hmsString_(hours, mins, secs, millis);
    }
  }
}

;
// alias in case anyone is referencing the old method.
// Dygraph.dateAxisFormatter = Dygraph.dateAxisLabelFormatter;

/**
 * Return a string version of a JS date for a value label. This respects the
 * labelsUTC option.
 * @param {Date} date The date to be formatted
 * @param {Dygraph} opts An options view
 * @private
 */

function dateValueFormatter(d, opts) {
  return dateString_(d, opts('labelsUTC'));
}

;

},{"./dygraph-tickers":16}],18:[function(require,module,exports){
(function (process){
/**
 * @license
 * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */ /**
 * @fileoverview Creates an interactive, zoomable graph based on a CSV file or
 * string. Dygraph can handle multiple series with or without error bars. The
 * date/value ranges will be automatically set. Dygraph uses the
 * &lt;canvas&gt; tag, so it only works in FF1.5+.
 * @author danvdk@gmail.com (Dan Vanderkam)

  Usage:
   <div id="graphdiv" style="width:800px; height:500px;"></div>
   script type="text/javascript">
     new Dygraph(document.getElementById("graphdiv"),
                 "datafile.csv",  // CSV file with headers
                 { }); // options
   /script>

 The CSV file is of the form

   Date,SeriesA,SeriesB,SeriesC
   YYYYMMDD,A1,B1,C1
   YYYYMMDD,A2,B2,C2

 If the 'errorBars' option is set in the constructor, the input should be of
 the form
   Date,SeriesA,SeriesB,...
   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...
   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...

 If the 'fractions' option is set, the input should be of the form:

   Date,SeriesA,SeriesB,...
   YYYYMMDD,A1/B1,A2/B2,...
   YYYYMMDD,A1/B1,A2/B2,...

 And error bars will be calculated automatically using a binomial distribution.

 For further documentation and examples, see http://dygraphs.com/
 */'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _slicedToArray=(function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n = (_s = _i.next()).done);_n = true) {_arr.push(_s.value);if(i && _arr.length === i)break;}}catch(err) {_d = true;_e = err;}finally {try{if(!_n && _i['return'])_i['return']();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError('Invalid attempt to destructure non-iterable instance');}};})();function _interopRequireWildcard(obj){if(obj && obj.__esModule){return obj;}else {var newObj={};if(obj != null){for(var key in obj) {if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key] = obj[key];}}newObj['default'] = obj;return newObj;}}function _interopRequireDefault(obj){return obj && obj.__esModule?obj:{'default':obj};}var _dygraphLayout=require('./dygraph-layout');var _dygraphLayout2=_interopRequireDefault(_dygraphLayout);var _dygraphCanvas=require('./dygraph-canvas');var _dygraphCanvas2=_interopRequireDefault(_dygraphCanvas);var _dygraphOptions=require('./dygraph-options');var _dygraphOptions2=_interopRequireDefault(_dygraphOptions);var _dygraphInteractionModel=require('./dygraph-interaction-model');var _dygraphInteractionModel2=_interopRequireDefault(_dygraphInteractionModel);var _dygraphTickers=require('./dygraph-tickers');var DygraphTickers=_interopRequireWildcard(_dygraphTickers);var _dygraphUtils=require('./dygraph-utils');var utils=_interopRequireWildcard(_dygraphUtils);var _dygraphDefaultAttrs=require('./dygraph-default-attrs');var _dygraphDefaultAttrs2=_interopRequireDefault(_dygraphDefaultAttrs);var _dygraphOptionsReference=require('./dygraph-options-reference');var _dygraphOptionsReference2=_interopRequireDefault(_dygraphOptionsReference);var _iframeTarp=require('./iframe-tarp');var _iframeTarp2=_interopRequireDefault(_iframeTarp);var _datahandlerDefault=require('./datahandler/default');var _datahandlerDefault2=_interopRequireDefault(_datahandlerDefault);var _datahandlerBarsError=require('./datahandler/bars-error');var _datahandlerBarsError2=_interopRequireDefault(_datahandlerBarsError);var _datahandlerBarsCustom=require('./datahandler/bars-custom');var _datahandlerBarsCustom2=_interopRequireDefault(_datahandlerBarsCustom);var _datahandlerDefaultFractions=require('./datahandler/default-fractions');var _datahandlerDefaultFractions2=_interopRequireDefault(_datahandlerDefaultFractions);var _datahandlerBarsFractions=require('./datahandler/bars-fractions');var _datahandlerBarsFractions2=_interopRequireDefault(_datahandlerBarsFractions);var _datahandlerBars=require('./datahandler/bars');var _datahandlerBars2=_interopRequireDefault(_datahandlerBars);var _pluginsAnnotations=require('./plugins/annotations');var _pluginsAnnotations2=_interopRequireDefault(_pluginsAnnotations);var _pluginsAxes=require('./plugins/axes');var _pluginsAxes2=_interopRequireDefault(_pluginsAxes);var _pluginsChartLabels=require('./plugins/chart-labels');var _pluginsChartLabels2=_interopRequireDefault(_pluginsChartLabels);var _pluginsGrid=require('./plugins/grid');var _pluginsGrid2=_interopRequireDefault(_pluginsGrid);var _pluginsLegend=require('./plugins/legend');var _pluginsLegend2=_interopRequireDefault(_pluginsLegend);var _pluginsRangeSelector=require('./plugins/range-selector');var _pluginsRangeSelector2=_interopRequireDefault(_pluginsRangeSelector);var _dygraphGviz=require('./dygraph-gviz');var _dygraphGviz2=_interopRequireDefault(_dygraphGviz);"use strict"; /**
 * Creates an interactive, zoomable chart.
 *
 * @constructor
 * @param {div | String} div A div or the id of a div into which to construct
 * the chart.
 * @param {String | Function} file A file containing CSV data or a function
 * that returns this data. The most basic expected format for each line is
 * "YYYY/MM/DD,val1,val2,...". For more information, see
 * http://dygraphs.com/data.html.
 * @param {Object} attrs Various other attributes, e.g. errorBars determines
 * whether the input data contains error ranges. For a complete list of
 * options, see http://dygraphs.com/options.html.
 */var Dygraph=function Dygraph(div,data,opts){this.__init__(div,data,opts);};Dygraph.NAME = "Dygraph";Dygraph.VERSION = "2.0.0"; // Various default values
Dygraph.DEFAULT_ROLL_PERIOD = 1;Dygraph.DEFAULT_WIDTH = 480;Dygraph.DEFAULT_HEIGHT = 320; // For max 60 Hz. animation:
Dygraph.ANIMATION_STEPS = 12;Dygraph.ANIMATION_DURATION = 200; /**
 * Standard plotters. These may be used by clients.
 * Available plotters are:
 * - Dygraph.Plotters.linePlotter: draws central lines (most common)
 * - Dygraph.Plotters.errorPlotter: draws error bars
 * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)
 *
 * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].
 * This causes all the lines to be drawn over all the fills/error bars.
 */Dygraph.Plotters = _dygraphCanvas2['default']._Plotters; // Used for initializing annotation CSS rules only once.
Dygraph.addedAnnotationCSS = false; /**
 * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit
 * and context &lt;canvas&gt; inside of it. See the constructor for details.
 * on the parameters.
 * @param {Element} div the Element to render the graph into.
 * @param {string | Function} file Source data
 * @param {Object} attrs Miscellaneous other options
 * @private
 */Dygraph.prototype.__init__ = function(div,file,attrs){this.is_initial_draw_ = true;this.readyFns_ = []; // Support two-argument constructor
if(attrs === null || attrs === undefined){attrs = {};}attrs = Dygraph.copyUserAttrs_(attrs);if(typeof div == 'string'){div = document.getElementById(div);}if(!div){throw new Error('Constructing dygraph with a non-existent div!');} // Copy the important bits into the object
// TODO(danvk): most of these should just stay in the attrs_ dictionary.
this.maindiv_ = div;this.file_ = file;this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;this.previousVerticalX_ = -1;this.fractions_ = attrs.fractions || false;this.dateWindow_ = attrs.dateWindow || null;this.annotations_ = []; // Clear the div. This ensure that, if multiple dygraphs are passed the same
// div, then only one will be drawn.
div.innerHTML = ""; // For historical reasons, the 'width' and 'height' options trump all CSS
// rules _except_ for an explicit 'width' or 'height' on the div.
// As an added convenience, if the div has zero height (like <div></div> does
// without any styles), then we use a default height/width.
if(div.style.width === '' && attrs.width){div.style.width = attrs.width + "px";}if(div.style.height === '' && attrs.height){div.style.height = attrs.height + "px";}if(div.style.height === '' && div.clientHeight === 0){div.style.height = Dygraph.DEFAULT_HEIGHT + "px";if(div.style.width === ''){div.style.width = Dygraph.DEFAULT_WIDTH + "px";}} // These will be zero if the dygraph's div is hidden. In that case,
// use the user-specified attributes if present. If not, use zero
// and assume the user will call resize to fix things later.
this.width_ = div.clientWidth || attrs.width || 0;this.height_ = div.clientHeight || attrs.height || 0; // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.
if(attrs.stackedGraph){attrs.fillGraph = true; // TODO(nikhilk): Add any other stackedGraph checks here.
} // DEPRECATION WARNING: All option processing should be moved from
// attrs_ and user_attrs_ to options_, which holds all this information.
//
// Dygraphs has many options, some of which interact with one another.
// To keep track of everything, we maintain two sets of options:
//
//  this.user_attrs_   only options explicitly set by the user.
//  this.attrs_        defaults, options derived from user_attrs_, data.
//
// Options are then accessed this.attr_('attr'), which first looks at
// user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent
// defaults without overriding behavior that the user specifically asks for.
this.user_attrs_ = {};utils.update(this.user_attrs_,attrs); // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.
this.attrs_ = {};utils.updateDeep(this.attrs_,_dygraphDefaultAttrs2['default']);this.boundaryIds_ = [];this.setIndexByName_ = {};this.datasetIndex_ = [];this.registeredEvents_ = [];this.eventListeners_ = {};this.attributes_ = new _dygraphOptions2['default'](this); // Create the containing DIV and other interactive elements
this.createInterface_(); // Activate plugins.
this.plugins_ = [];var plugins=Dygraph.PLUGINS.concat(this.getOption('plugins'));for(var i=0;i < plugins.length;i++) { // the plugins option may contain either plugin classes or instances.
// Plugin instances contain an activate method.
var Plugin=plugins[i]; // either a constructor or an instance.
var pluginInstance;if(typeof Plugin.activate !== 'undefined'){pluginInstance = Plugin;}else {pluginInstance = new Plugin();}var pluginDict={plugin:pluginInstance,events:{},options:{},pluginOptions:{}};var handlers=pluginInstance.activate(this);for(var eventName in handlers) {if(!handlers.hasOwnProperty(eventName))continue; // TODO(danvk): validate eventName.
pluginDict.events[eventName] = handlers[eventName];}this.plugins_.push(pluginDict);} // At this point, plugins can no longer register event handlers.
// Construct a map from event -> ordered list of [callback, plugin].
for(var i=0;i < this.plugins_.length;i++) {var plugin_dict=this.plugins_[i];for(var eventName in plugin_dict.events) {if(!plugin_dict.events.hasOwnProperty(eventName))continue;var callback=plugin_dict.events[eventName];var pair=[plugin_dict.plugin,callback];if(!(eventName in this.eventListeners_)){this.eventListeners_[eventName] = [pair];}else {this.eventListeners_[eventName].push(pair);}}}this.createDragInterface_();this.start_();}; /**
 * Triggers a cascade of events to the various plugins which are interested in them.
 * Returns true if the "default behavior" should be prevented, i.e. if one
 * of the event listeners called event.preventDefault().
 * @private
 */Dygraph.prototype.cascadeEvents_ = function(name,extra_props){if(!(name in this.eventListeners_))return false; // QUESTION: can we use objects & prototypes to speed this up?
var e={dygraph:this,cancelable:false,defaultPrevented:false,preventDefault:function preventDefault(){if(!e.cancelable)throw "Cannot call preventDefault on non-cancelable event.";e.defaultPrevented = true;},propagationStopped:false,stopPropagation:function stopPropagation(){e.propagationStopped = true;}};utils.update(e,extra_props);var callback_plugin_pairs=this.eventListeners_[name];if(callback_plugin_pairs){for(var i=callback_plugin_pairs.length - 1;i >= 0;i--) {var plugin=callback_plugin_pairs[i][0];var callback=callback_plugin_pairs[i][1];callback.call(plugin,e);if(e.propagationStopped)break;}}return e.defaultPrevented;}; /**
 * Fetch a plugin instance of a particular class. Only for testing.
 * @private
 * @param {!Class} type The type of the plugin.
 * @return {Object} Instance of the plugin, or null if there is none.
 */Dygraph.prototype.getPluginInstance_ = function(type){for(var i=0;i < this.plugins_.length;i++) {var p=this.plugins_[i];if(p.plugin instanceof type){return p.plugin;}}return null;}; /**
 * Returns the zoomed status of the chart for one or both axes.
 *
 * Axis is an optional parameter. Can be set to 'x' or 'y'.
 *
 * The zoomed status for an axis is set whenever a user zooms using the mouse
 * or when the dateWindow or valueRange are updated. Double-clicking or calling
 * resetZoom() resets the zoom status for the chart.
 */Dygraph.prototype.isZoomed = function(axis){var isZoomedX=!!this.dateWindow_;if(axis === 'x')return isZoomedX;var isZoomedY=this.axes_.map(function(axis){return !!axis.valueRange;}).indexOf(true) >= 0;if(axis === null || axis === undefined){return isZoomedX || isZoomedY;}if(axis === 'y')return isZoomedY;throw new Error('axis parameter is [' + axis + '] must be null, \\'x\\' or \\'y\\'.');}; /**
 * Returns information about the Dygraph object, including its containing ID.
 */Dygraph.prototype.toString = function(){var maindiv=this.maindiv_;var id=maindiv && maindiv.id?maindiv.id:maindiv;return "[Dygraph " + id + "]";}; /**
 * @private
 * Returns the value of an option. This may be set by the user (either in the
 * constructor or by calling updateOptions) or by dygraphs, and may be set to a
 * per-series value.
 * @param {string} name The name of the option, e.g. 'rollPeriod'.
 * @param {string} [seriesName] The name of the series to which the option
 * will be applied. If no per-series value of this option is available, then
 * the global value is returned. This is optional.
 * @return { ... } The value of the option.
 */Dygraph.prototype.attr_ = function(name,seriesName){ // For "production" code, this gets removed by uglifyjs.
if(typeof process !== 'undefined'){if("development" != 'production'){if(typeof _dygraphOptionsReference2['default'] === 'undefined'){console.error('Must include options reference JS for testing');}else if(!_dygraphOptionsReference2['default'].hasOwnProperty(name)){console.error('Dygraphs is using property ' + name + ', which has no ' + 'entry in the Dygraphs.OPTIONS_REFERENCE listing.'); // Only log this error once.
_dygraphOptionsReference2['default'][name] = true;}}}return seriesName?this.attributes_.getForSeries(name,seriesName):this.attributes_.get(name);}; /**
 * Returns the current value for an option, as set in the constructor or via
 * updateOptions. You may pass in an (optional) series name to get per-series
 * values for the option.
 *
 * All values returned by this method should be considered immutable. If you
 * modify them, there is no guarantee that the changes will be honored or that
 * dygraphs will remain in a consistent state. If you want to modify an option,
 * use updateOptions() instead.
 *
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {*} The value of the option.
 */Dygraph.prototype.getOption = function(name,opt_seriesName){return this.attr_(name,opt_seriesName);}; /**
 * Like getOption(), but specifically returns a number.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {number} The value of the option.
 * @private
 */Dygraph.prototype.getNumericOption = function(name,opt_seriesName){return  (/** @type{number} */this.getOption(name,opt_seriesName));}; /**
 * Like getOption(), but specifically returns a string.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {string} The value of the option.
 * @private
 */Dygraph.prototype.getStringOption = function(name,opt_seriesName){return  (/** @type{string} */this.getOption(name,opt_seriesName));}; /**
 * Like getOption(), but specifically returns a boolean.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {boolean} The value of the option.
 * @private
 */Dygraph.prototype.getBooleanOption = function(name,opt_seriesName){return  (/** @type{boolean} */this.getOption(name,opt_seriesName));}; /**
 * Like getOption(), but specifically returns a function.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {function(...)} The value of the option.
 * @private
 */Dygraph.prototype.getFunctionOption = function(name,opt_seriesName){return  (/** @type{function(...)} */this.getOption(name,opt_seriesName));};Dygraph.prototype.getOptionForAxis = function(name,axis){return this.attributes_.getForAxis(name,axis);}; /**
 * @private
 * @param {string} axis The name of the axis (i.e. 'x', 'y' or 'y2')
 * @return { ... } A function mapping string -> option value
 */Dygraph.prototype.optionsViewForAxis_ = function(axis){var self=this;return function(opt){var axis_opts=self.user_attrs_.axes;if(axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)){return axis_opts[axis][opt];} // I don't like that this is in a second spot.
if(axis === 'x' && opt === 'logscale'){ // return the default value.
// TODO(konigsberg): pull the default from a global default.
return false;} // user-specified attributes always trump defaults, even if they're less
// specific.
if(typeof self.user_attrs_[opt] != 'undefined'){return self.user_attrs_[opt];}axis_opts = self.attrs_.axes;if(axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)){return axis_opts[axis][opt];} // check old-style axis options
// TODO(danvk): add a deprecation warning if either of these match.
if(axis == 'y' && self.axes_[0].hasOwnProperty(opt)){return self.axes_[0][opt];}else if(axis == 'y2' && self.axes_[1].hasOwnProperty(opt)){return self.axes_[1][opt];}return self.attr_(opt);};}; /**
 * Returns the current rolling period, as set by the user or an option.
 * @return {number} The number of points in the rolling window
 */Dygraph.prototype.rollPeriod = function(){return this.rollPeriod_;}; /**
 * Returns the currently-visible x-range. This can be affected by zooming,
 * panning or a call to updateOptions.
 * Returns a two-element array: [left, right].
 * If the Dygraph has dates on the x-axis, these will be millis since epoch.
 */Dygraph.prototype.xAxisRange = function(){return this.dateWindow_?this.dateWindow_:this.xAxisExtremes();}; /**
 * Returns the lower- and upper-bound x-axis values of the data set.
 */Dygraph.prototype.xAxisExtremes = function(){var pad=this.getNumericOption('xRangePad') / this.plotter_.area.w;if(this.numRows() === 0){return [0 - pad,1 + pad];}var left=this.rawData_[0][0];var right=this.rawData_[this.rawData_.length - 1][0];if(pad){ // Must keep this in sync with dygraph-layout _evaluateLimits()
var range=right - left;left -= range * pad;right += range * pad;}return [left,right];}; /**
 * Returns the lower- and upper-bound y-axis values for each axis. These are
 * the ranges you'll get if you double-click to zoom out or call resetZoom().
 * The return value is an array of [low, high] tuples, one for each y-axis.
 */Dygraph.prototype.yAxisExtremes = function(){ // TODO(danvk): this is pretty inefficient
var packed=this.gatherDatasets_(this.rolledSeries_,null);var extremes=packed.extremes;var saveAxes=this.axes_;this.computeYAxisRanges_(extremes);var newAxes=this.axes_;this.axes_ = saveAxes;return newAxes.map(function(axis){return axis.extremeRange;});}; /**
 * Returns the currently-visible y-range for an axis. This can be affected by
 * zooming, panning or a call to updateOptions. Axis indices are zero-based. If
 * called with no arguments, returns the range of the first axis.
 * Returns a two-element array: [bottom, top].
 */Dygraph.prototype.yAxisRange = function(idx){if(typeof idx == "undefined")idx = 0;if(idx < 0 || idx >= this.axes_.length){return null;}var axis=this.axes_[idx];return [axis.computedValueRange[0],axis.computedValueRange[1]];}; /**
 * Returns the currently-visible y-ranges for each axis. This can be affected by
 * zooming, panning, calls to updateOptions, etc.
 * Returns an array of [bottom, top] pairs, one for each y-axis.
 */Dygraph.prototype.yAxisRanges = function(){var ret=[];for(var i=0;i < this.axes_.length;i++) {ret.push(this.yAxisRange(i));}return ret;}; // TODO(danvk): use these functions throughout dygraphs.
/**
 * Convert from data coordinates to canvas/div X/Y coordinates.
 * If specified, do this conversion for the coordinate system of a particular
 * axis. Uses the first axis by default.
 * Returns a two-element array: [X, Y]
 *
 * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord
 * instead of toDomCoords(null, y, axis).
 */Dygraph.prototype.toDomCoords = function(x,y,axis){return [this.toDomXCoord(x),this.toDomYCoord(y,axis)];}; /**
 * Convert from data x coordinates to canvas/div X coordinate.
 * If specified, do this conversion for the coordinate system of a particular
 * axis.
 * Returns a single value or null if x is null.
 */Dygraph.prototype.toDomXCoord = function(x){if(x === null){return null;}var area=this.plotter_.area;var xRange=this.xAxisRange();return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;}; /**
 * Convert from data x coordinates to canvas/div Y coordinate and optional
 * axis. Uses the first axis by default.
 *
 * returns a single value or null if y is null.
 */Dygraph.prototype.toDomYCoord = function(y,axis){var pct=this.toPercentYCoord(y,axis);if(pct === null){return null;}var area=this.plotter_.area;return area.y + pct * area.h;}; /**
 * Convert from canvas/div coords to data coordinates.
 * If specified, do this conversion for the coordinate system of a particular
 * axis. Uses the first axis by default.
 * Returns a two-element array: [X, Y].
 *
 * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord
 * instead of toDataCoords(null, y, axis).
 */Dygraph.prototype.toDataCoords = function(x,y,axis){return [this.toDataXCoord(x),this.toDataYCoord(y,axis)];}; /**
 * Convert from canvas/div x coordinate to data coordinate.
 *
 * If x is null, this returns null.
 */Dygraph.prototype.toDataXCoord = function(x){if(x === null){return null;}var area=this.plotter_.area;var xRange=this.xAxisRange();if(!this.attributes_.getForAxis("logscale",'x')){return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);}else {var pct=(x - area.x) / area.w;return utils.logRangeFraction(xRange[0],xRange[1],pct);}}; /**
 * Convert from canvas/div y coord to value.
 *
 * If y is null, this returns null.
 * if axis is null, this uses the first axis.
 */Dygraph.prototype.toDataYCoord = function(y,axis){if(y === null){return null;}var area=this.plotter_.area;var yRange=this.yAxisRange(axis);if(typeof axis == "undefined")axis = 0;if(!this.attributes_.getForAxis("logscale",axis)){return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);}else { // Computing the inverse of toDomCoord.
var pct=(y - area.y) / area.h; // Note reversed yRange, y1 is on top with pct==0.
return utils.logRangeFraction(yRange[1],yRange[0],pct);}}; /**
 * Converts a y for an axis to a percentage from the top to the
 * bottom of the drawing area.
 *
 * If the coordinate represents a value visible on the canvas, then
 * the value will be between 0 and 1, where 0 is the top of the canvas.
 * However, this method will return values outside the range, as
 * values can fall outside the canvas.
 *
 * If y is null, this returns null.
 * if axis is null, this uses the first axis.
 *
 * @param {number} y The data y-coordinate.
 * @param {number} [axis] The axis number on which the data coordinate lives.
 * @return {number} A fraction in [0, 1] where 0 = the top edge.
 */Dygraph.prototype.toPercentYCoord = function(y,axis){if(y === null){return null;}if(typeof axis == "undefined")axis = 0;var yRange=this.yAxisRange(axis);var pct;var logscale=this.attributes_.getForAxis("logscale",axis);if(logscale){var logr0=utils.log10(yRange[0]);var logr1=utils.log10(yRange[1]);pct = (logr1 - utils.log10(y)) / (logr1 - logr0);}else { // yRange[1] - y is unit distance from the bottom.
// yRange[1] - yRange[0] is the scale of the range.
// (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.
pct = (yRange[1] - y) / (yRange[1] - yRange[0]);}return pct;}; /**
 * Converts an x value to a percentage from the left to the right of
 * the drawing area.
 *
 * If the coordinate represents a value visible on the canvas, then
 * the value will be between 0 and 1, where 0 is the left of the canvas.
 * However, this method will return values outside the range, as
 * values can fall outside the canvas.
 *
 * If x is null, this returns null.
 * @param {number} x The data x-coordinate.
 * @return {number} A fraction in [0, 1] where 0 = the left edge.
 */Dygraph.prototype.toPercentXCoord = function(x){if(x === null){return null;}var xRange=this.xAxisRange();var pct;var logscale=this.attributes_.getForAxis("logscale",'x');if(logscale === true){ // logscale can be null so we test for true explicitly.
var logr0=utils.log10(xRange[0]);var logr1=utils.log10(xRange[1]);pct = (utils.log10(x) - logr0) / (logr1 - logr0);}else { // x - xRange[0] is unit distance from the left.
// xRange[1] - xRange[0] is the scale of the range.
// The full expression below is the % from the left.
pct = (x - xRange[0]) / (xRange[1] - xRange[0]);}return pct;}; /**
 * Returns the number of columns (including the independent variable).
 * @return {number} The number of columns.
 */Dygraph.prototype.numColumns = function(){if(!this.rawData_)return 0;return this.rawData_[0]?this.rawData_[0].length:this.attr_("labels").length;}; /**
 * Returns the number of rows (excluding any header/label row).
 * @return {number} The number of rows, less any header.
 */Dygraph.prototype.numRows = function(){if(!this.rawData_)return 0;return this.rawData_.length;}; /**
 * Returns the value in the given row and column. If the row and column exceed
 * the bounds on the data, returns null. Also returns null if the value is
 * missing.
 * @param {number} row The row number of the data (0-based). Row 0 is the
 *     first row of data, not a header row.
 * @param {number} col The column number of the data (0-based)
 * @return {number} The value in the specified cell or null if the row/col
 *     were out of range.
 */Dygraph.prototype.getValue = function(row,col){if(row < 0 || row > this.rawData_.length)return null;if(col < 0 || col > this.rawData_[row].length)return null;return this.rawData_[row][col];}; /**
 * Generates interface elements for the Dygraph: a containing div, a div to
 * display the current point, and a textbox to adjust the rolling average
 * period. Also creates the Renderer/Layout elements.
 * @private
 */Dygraph.prototype.createInterface_ = function(){ // Create the all-enclosing graph div
var enclosing=this.maindiv_;this.graphDiv = document.createElement("div"); // TODO(danvk): any other styles that are useful to set here?
this.graphDiv.style.textAlign = 'left'; // This is a CSS "reset"
this.graphDiv.style.position = 'relative';enclosing.appendChild(this.graphDiv); // Create the canvas for interactive parts of the chart.
this.canvas_ = utils.createCanvas();this.canvas_.style.position = "absolute"; // ... and for static parts of the chart.
this.hidden_ = this.createPlotKitCanvas_(this.canvas_);this.canvas_ctx_ = utils.getContext(this.canvas_);this.hidden_ctx_ = utils.getContext(this.hidden_);this.resizeElements_(); // The interactive parts of the graph are drawn on top of the chart.
this.graphDiv.appendChild(this.hidden_);this.graphDiv.appendChild(this.canvas_);this.mouseEventElement_ = this.createMouseEventElement_(); // Create the grapher
this.layout_ = new _dygraphLayout2['default'](this);var dygraph=this;this.mouseMoveHandler_ = function(e){dygraph.mouseMove_(e);};this.mouseOutHandler_ = function(e){ // The mouse has left the chart if:
// 1. e.target is inside the chart
// 2. e.relatedTarget is outside the chart
var target=e.target || e.fromElement;var relatedTarget=e.relatedTarget || e.toElement;if(utils.isNodeContainedBy(target,dygraph.graphDiv) && !utils.isNodeContainedBy(relatedTarget,dygraph.graphDiv)){dygraph.mouseOut_(e);}};this.addAndTrackEvent(window,'mouseout',this.mouseOutHandler_);this.addAndTrackEvent(this.mouseEventElement_,'mousemove',this.mouseMoveHandler_); // Don't recreate and register the resize handler on subsequent calls.
// This happens when the graph is resized.
if(!this.resizeHandler_){this.resizeHandler_ = function(e){dygraph.resize();}; // Update when the window is resized.
// TODO(danvk): drop frames depending on complexity of the chart.
this.addAndTrackEvent(window,'resize',this.resizeHandler_);}};Dygraph.prototype.resizeElements_ = function(){this.graphDiv.style.width = this.width_ + "px";this.graphDiv.style.height = this.height_ + "px";var pixelRatioOption=this.getNumericOption('pixelRatio');var canvasScale=pixelRatioOption || utils.getContextPixelRatio(this.canvas_ctx_);this.canvas_.width = this.width_ * canvasScale;this.canvas_.height = this.height_ * canvasScale;this.canvas_.style.width = this.width_ + "px"; // for IE
this.canvas_.style.height = this.height_ + "px"; // for IE
if(canvasScale !== 1){this.canvas_ctx_.scale(canvasScale,canvasScale);}var hiddenScale=pixelRatioOption || utils.getContextPixelRatio(this.hidden_ctx_);this.hidden_.width = this.width_ * hiddenScale;this.hidden_.height = this.height_ * hiddenScale;this.hidden_.style.width = this.width_ + "px"; // for IE
this.hidden_.style.height = this.height_ + "px"; // for IE
if(hiddenScale !== 1){this.hidden_ctx_.scale(hiddenScale,hiddenScale);}}; /**
 * Detach DOM elements in the dygraph and null out all data references.
 * Calling this when you're done with a dygraph can dramatically reduce memory
 * usage. See, e.g., the tests/perf.html example.
 */Dygraph.prototype.destroy = function(){this.canvas_ctx_.restore();this.hidden_ctx_.restore(); // Destroy any plugins, in the reverse order that they were registered.
for(var i=this.plugins_.length - 1;i >= 0;i--) {var p=this.plugins_.pop();if(p.plugin.destroy)p.plugin.destroy();}var removeRecursive=function removeRecursive(node){while(node.hasChildNodes()) {removeRecursive(node.firstChild);node.removeChild(node.firstChild);}};this.removeTrackedEvents_(); // remove mouse event handlers (This may not be necessary anymore)
utils.removeEvent(window,'mouseout',this.mouseOutHandler_);utils.removeEvent(this.mouseEventElement_,'mousemove',this.mouseMoveHandler_); // remove window handlers
utils.removeEvent(window,'resize',this.resizeHandler_);this.resizeHandler_ = null;removeRecursive(this.maindiv_);var nullOut=function nullOut(obj){for(var n in obj) {if(typeof obj[n] === 'object'){obj[n] = null;}}}; // These may not all be necessary, but it can't hurt...
nullOut(this.layout_);nullOut(this.plotter_);nullOut(this);}; /**
 * Creates the canvas on which the chart will be drawn. Only the Renderer ever
 * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots
 * or the zoom rectangles) is done on this.canvas_.
 * @param {Object} canvas The Dygraph canvas over which to overlay the plot
 * @return {Object} The newly-created canvas
 * @private
 */Dygraph.prototype.createPlotKitCanvas_ = function(canvas){var h=utils.createCanvas();h.style.position = "absolute"; // TODO(danvk): h should be offset from canvas. canvas needs to include
// some extra area to make it easier to zoom in on the far left and far
// right. h needs to be precisely the plot area, so that clipping occurs.
h.style.top = canvas.style.top;h.style.left = canvas.style.left;h.width = this.width_;h.height = this.height_;h.style.width = this.width_ + "px"; // for IE
h.style.height = this.height_ + "px"; // for IE
return h;}; /**
 * Creates an overlay element used to handle mouse events.
 * @return {Object} The mouse event element.
 * @private
 */Dygraph.prototype.createMouseEventElement_ = function(){return this.canvas_;}; /**
 * Generate a set of distinct colors for the data series. This is done with a
 * color wheel. Saturation/Value are customizable, and the hue is
 * equally-spaced around the color wheel. If a custom set of colors is
 * specified, that is used instead.
 * @private
 */Dygraph.prototype.setColors_ = function(){var labels=this.getLabels();var num=labels.length - 1;this.colors_ = [];this.colorsMap_ = {}; // These are used for when no custom colors are specified.
var sat=this.getNumericOption('colorSaturation') || 1.0;var val=this.getNumericOption('colorValue') || 0.5;var half=Math.ceil(num / 2);var colors=this.getOption('colors');var visibility=this.visibility();for(var i=0;i < num;i++) {if(!visibility[i]){continue;}var label=labels[i + 1];var colorStr=this.attributes_.getForSeries('color',label);if(!colorStr){if(colors){colorStr = colors[i % colors.length];}else { // alternate colors for high contrast.
var idx=i % 2?half + (i + 1) / 2:Math.ceil((i + 1) / 2);var hue=1.0 * idx / (1 + num);colorStr = utils.hsvToRGB(hue,sat,val);}}this.colors_.push(colorStr);this.colorsMap_[label] = colorStr;}}; /**
 * Return the list of colors. This is either the list of colors passed in the
 * attributes or the autogenerated list of rgb(r,g,b) strings.
 * This does not return colors for invisible series.
 * @return {Array.<string>} The list of colors.
 */Dygraph.prototype.getColors = function(){return this.colors_;}; /**
 * Returns a few attributes of a series, i.e. its color, its visibility, which
 * axis it's assigned to, and its column in the original data.
 * Returns null if the series does not exist.
 * Otherwise, returns an object with column, visibility, color and axis properties.
 * The "axis" property will be set to 1 for y1 and 2 for y2.
 * The "column" property can be fed back into getValue(row, column) to get
 * values for this series.
 */Dygraph.prototype.getPropertiesForSeries = function(series_name){var idx=-1;var labels=this.getLabels();for(var i=1;i < labels.length;i++) {if(labels[i] == series_name){idx = i;break;}}if(idx == -1)return null;return {name:series_name,column:idx,visible:this.visibility()[idx - 1],color:this.colorsMap_[series_name],axis:1 + this.attributes_.axisForSeries(series_name)};}; /**
 * Create the text box to adjust the averaging period
 * @private
 */Dygraph.prototype.createRollInterface_ = function(){var _this=this; // Create a roller if one doesn't exist already.
var roller=this.roller_;if(!roller){this.roller_ = roller = document.createElement("input");roller.type = "text";roller.style.display = "none";roller.className = 'dygraph-roller';this.graphDiv.appendChild(roller);}var display=this.getBooleanOption('showRoller')?'block':'none';var area=this.getArea();var textAttr={"top":area.y + area.h - 25 + "px","left":area.x + 1 + "px","display":display};roller.size = "2";roller.value = this.rollPeriod_;utils.update(roller.style,textAttr);roller.onchange = function(){return _this.adjustRoll(roller.value);};}; /**
 * Set up all the mouse handlers needed to capture dragging behavior for zoom
 * events.
 * @private
 */Dygraph.prototype.createDragInterface_ = function(){var context={ // Tracks whether the mouse is down right now
isZooming:false,isPanning:false, // is this drag part of a pan?
is2DPan:false, // if so, is that pan 1- or 2-dimensional?
dragStartX:null, // pixel coordinates
dragStartY:null, // pixel coordinates
dragEndX:null, // pixel coordinates
dragEndY:null, // pixel coordinates
dragDirection:null,prevEndX:null, // pixel coordinates
prevEndY:null, // pixel coordinates
prevDragDirection:null,cancelNextDblclick:false, // see comment in dygraph-interaction-model.js
// The value on the left side of the graph when a pan operation starts.
initialLeftmostDate:null, // The number of units each pixel spans. (This won't be valid for log
// scales)
xUnitsPerPixel:null, // TODO(danvk): update this comment
// The range in second/value units that the viewport encompasses during a
// panning operation.
dateRange:null, // Top-left corner of the canvas, in DOM coords
// TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.
px:0,py:0, // Values for use with panEdgeFraction, which limit how far outside the
// graph's data boundaries it can be panned.
boundedDates:null, // [minDate, maxDate]
boundedValues:null, // [[minValue, maxValue] ...]
// We cover iframes during mouse interactions. See comments in
// dygraph-utils.js for more info on why this is a good idea.
tarp:new _iframeTarp2['default'](), // contextB is the same thing as this context object but renamed.
initializeMouseDown:function initializeMouseDown(event,g,contextB){ // prevents mouse drags from selecting page text.
if(event.preventDefault){event.preventDefault(); // Firefox, Chrome, etc.
}else {event.returnValue = false; // IE
event.cancelBubble = true;}var canvasPos=utils.findPos(g.canvas_);contextB.px = canvasPos.x;contextB.py = canvasPos.y;contextB.dragStartX = utils.dragGetX_(event,contextB);contextB.dragStartY = utils.dragGetY_(event,contextB);contextB.cancelNextDblclick = false;contextB.tarp.cover();},destroy:function destroy(){var context=this;if(context.isZooming || context.isPanning){context.isZooming = false;context.dragStartX = null;context.dragStartY = null;}if(context.isPanning){context.isPanning = false;context.draggingDate = null;context.dateRange = null;for(var i=0;i < self.axes_.length;i++) {delete self.axes_[i].draggingValue;delete self.axes_[i].dragValueRange;}}context.tarp.uncover();}};var interactionModel=this.getOption("interactionModel"); // Self is the graph.
var self=this; // Function that binds the graph and context to the handler.
var bindHandler=function bindHandler(handler){return function(event){handler(event,self,context);};};for(var eventName in interactionModel) {if(!interactionModel.hasOwnProperty(eventName))continue;this.addAndTrackEvent(this.mouseEventElement_,eventName,bindHandler(interactionModel[eventName]));} // If the user releases the mouse button during a drag, but not over the
// canvas, then it doesn't count as a zooming action.
if(!interactionModel.willDestroyContextMyself){var mouseUpHandler=function mouseUpHandler(event){context.destroy();};this.addAndTrackEvent(document,'mouseup',mouseUpHandler);}}; /**
 * Draw a gray zoom rectangle over the desired area of the canvas. Also clears
 * up any previous zoom rectangles that were drawn. This could be optimized to
 * avoid extra redrawing, but it's tricky to avoid interactions with the status
 * dots.
 *
 * @param {number} direction the direction of the zoom rectangle. Acceptable
 *     values are utils.HORIZONTAL and utils.VERTICAL.
 * @param {number} startX The X position where the drag started, in canvas
 *     coordinates.
 * @param {number} endX The current X position of the drag, in canvas coords.
 * @param {number} startY The Y position where the drag started, in canvas
 *     coordinates.
 * @param {number} endY The current Y position of the drag, in canvas coords.
 * @param {number} prevDirection the value of direction on the previous call to
 *     this function. Used to avoid excess redrawing
 * @param {number} prevEndX The value of endX on the previous call to this
 *     function. Used to avoid excess redrawing
 * @param {number} prevEndY The value of endY on the previous call to this
 *     function. Used to avoid excess redrawing
 * @private
 */Dygraph.prototype.drawZoomRect_ = function(direction,startX,endX,startY,endY,prevDirection,prevEndX,prevEndY){var ctx=this.canvas_ctx_; // Clean up from the previous rect if necessary
if(prevDirection == utils.HORIZONTAL){ctx.clearRect(Math.min(startX,prevEndX),this.layout_.getPlotArea().y,Math.abs(startX - prevEndX),this.layout_.getPlotArea().h);}else if(prevDirection == utils.VERTICAL){ctx.clearRect(this.layout_.getPlotArea().x,Math.min(startY,prevEndY),this.layout_.getPlotArea().w,Math.abs(startY - prevEndY));} // Draw a light-grey rectangle to show the new viewing area
if(direction == utils.HORIZONTAL){if(endX && startX){ctx.fillStyle = "rgba(128,128,128,0.33)";ctx.fillRect(Math.min(startX,endX),this.layout_.getPlotArea().y,Math.abs(endX - startX),this.layout_.getPlotArea().h);}}else if(direction == utils.VERTICAL){if(endY && startY){ctx.fillStyle = "rgba(128,128,128,0.33)";ctx.fillRect(this.layout_.getPlotArea().x,Math.min(startY,endY),this.layout_.getPlotArea().w,Math.abs(endY - startY));}}}; /**
 * Clear the zoom rectangle (and perform no zoom).
 * @private
 */Dygraph.prototype.clearZoomRect_ = function(){this.currentZoomRectArgs_ = null;this.canvas_ctx_.clearRect(0,0,this.width_,this.height_);}; /**
 * Zoom to something containing [lowX, highX]. These are pixel coordinates in
 * the canvas. The exact zoom window may be slightly larger if there are no data
 * points near lowX or highX. Don't confuse this function with doZoomXDates,
 * which accepts dates that match the raw data. This function redraws the graph.
 *
 * @param {number} lowX The leftmost pixel value that should be visible.
 * @param {number} highX The rightmost pixel value that should be visible.
 * @private
 */Dygraph.prototype.doZoomX_ = function(lowX,highX){this.currentZoomRectArgs_ = null; // Find the earliest and latest dates contained in this canvasx range.
// Convert the call to date ranges of the raw data.
var minDate=this.toDataXCoord(lowX);var maxDate=this.toDataXCoord(highX);this.doZoomXDates_(minDate,maxDate);}; /**
 * Zoom to something containing [minDate, maxDate] values. Don't confuse this
 * method with doZoomX which accepts pixel coordinates. This function redraws
 * the graph.
 *
 * @param {number} minDate The minimum date that should be visible.
 * @param {number} maxDate The maximum date that should be visible.
 * @private
 */Dygraph.prototype.doZoomXDates_ = function(minDate,maxDate){var _this2=this; // TODO(danvk): when xAxisRange is null (i.e. "fit to data", the animation
// can produce strange effects. Rather than the x-axis transitioning slowly
// between values, it can jerk around.)
var old_window=this.xAxisRange();var new_window=[minDate,maxDate];var zoomCallback=this.getFunctionOption('zoomCallback');this.doAnimatedZoom(old_window,new_window,null,null,function(){if(zoomCallback){zoomCallback.call(_this2,minDate,maxDate,_this2.yAxisRanges());}});}; /**
 * Zoom to something containing [lowY, highY]. These are pixel coordinates in
 * the canvas. This function redraws the graph.
 *
 * @param {number} lowY The topmost pixel value that should be visible.
 * @param {number} highY The lowest pixel value that should be visible.
 * @private
 */Dygraph.prototype.doZoomY_ = function(lowY,highY){var _this3=this;this.currentZoomRectArgs_ = null; // Find the highest and lowest values in pixel range for each axis.
// Note that lowY (in pixels) corresponds to the max Value (in data coords).
// This is because pixels increase as you go down on the screen, whereas data
// coordinates increase as you go up the screen.
var oldValueRanges=this.yAxisRanges();var newValueRanges=[];for(var i=0;i < this.axes_.length;i++) {var hi=this.toDataYCoord(lowY,i);var low=this.toDataYCoord(highY,i);newValueRanges.push([low,hi]);}var zoomCallback=this.getFunctionOption('zoomCallback');this.doAnimatedZoom(null,null,oldValueRanges,newValueRanges,function(){if(zoomCallback){var _xAxisRange=_this3.xAxisRange();var _xAxisRange2=_slicedToArray(_xAxisRange,2);var minX=_xAxisRange2[0];var maxX=_xAxisRange2[1];zoomCallback.call(_this3,minX,maxX,_this3.yAxisRanges());}});}; /**
 * Transition function to use in animations. Returns values between 0.0
 * (totally old values) and 1.0 (totally new values) for each frame.
 * @private
 */Dygraph.zoomAnimationFunction = function(frame,numFrames){var k=1.5;return (1.0 - Math.pow(k,-frame)) / (1.0 - Math.pow(k,-numFrames));}; /**
 * Reset the zoom to the original view coordinates. This is the same as
 * double-clicking on the graph.
 */Dygraph.prototype.resetZoom = function(){var _this4=this;var dirtyX=this.isZoomed('x');var dirtyY=this.isZoomed('y');var dirty=dirtyX || dirtyY; // Clear any selection, since it's likely to be drawn in the wrong place.
this.clearSelection();if(!dirty)return; // Calculate extremes to avoid lack of padding on reset.
var _xAxisExtremes=this.xAxisExtremes();var _xAxisExtremes2=_slicedToArray(_xAxisExtremes,2);var minDate=_xAxisExtremes2[0];var maxDate=_xAxisExtremes2[1];var animatedZooms=this.getBooleanOption('animatedZooms');var zoomCallback=this.getFunctionOption('zoomCallback'); // TODO(danvk): merge this block w/ the code below.
// TODO(danvk): factor out a generic, public zoomTo method.
if(!animatedZooms){this.dateWindow_ = null;this.axes_.forEach(function(axis){if(axis.valueRange)delete axis.valueRange;});this.drawGraph_();if(zoomCallback){zoomCallback.call(this,minDate,maxDate,this.yAxisRanges());}return;}var oldWindow=null,newWindow=null,oldValueRanges=null,newValueRanges=null;if(dirtyX){oldWindow = this.xAxisRange();newWindow = [minDate,maxDate];}if(dirtyY){oldValueRanges = this.yAxisRanges();newValueRanges = this.yAxisExtremes();}this.doAnimatedZoom(oldWindow,newWindow,oldValueRanges,newValueRanges,function(){_this4.dateWindow_ = null;_this4.axes_.forEach(function(axis){if(axis.valueRange)delete axis.valueRange;});if(zoomCallback){zoomCallback.call(_this4,minDate,maxDate,_this4.yAxisRanges());}});}; /**
 * Combined animation logic for all zoom functions.
 * either the x parameters or y parameters may be null.
 * @private
 */Dygraph.prototype.doAnimatedZoom = function(oldXRange,newXRange,oldYRanges,newYRanges,callback){var _this5=this;var steps=this.getBooleanOption("animatedZooms")?Dygraph.ANIMATION_STEPS:1;var windows=[];var valueRanges=[];var step,frac;if(oldXRange !== null && newXRange !== null){for(step = 1;step <= steps;step++) {frac = Dygraph.zoomAnimationFunction(step,steps);windows[step - 1] = [oldXRange[0] * (1 - frac) + frac * newXRange[0],oldXRange[1] * (1 - frac) + frac * newXRange[1]];}}if(oldYRanges !== null && newYRanges !== null){for(step = 1;step <= steps;step++) {frac = Dygraph.zoomAnimationFunction(step,steps);var thisRange=[];for(var j=0;j < this.axes_.length;j++) {thisRange.push([oldYRanges[j][0] * (1 - frac) + frac * newYRanges[j][0],oldYRanges[j][1] * (1 - frac) + frac * newYRanges[j][1]]);}valueRanges[step - 1] = thisRange;}}utils.repeatAndCleanup(function(step){if(valueRanges.length){for(var i=0;i < _this5.axes_.length;i++) {var w=valueRanges[step][i];_this5.axes_[i].valueRange = [w[0],w[1]];}}if(windows.length){_this5.dateWindow_ = windows[step];}_this5.drawGraph_();},steps,Dygraph.ANIMATION_DURATION / steps,callback);}; /**
 * Get the current graph's area object.
 *
 * Returns: {x, y, w, h}
 */Dygraph.prototype.getArea = function(){return this.plotter_.area;}; /**
 * Convert a mouse event to DOM coordinates relative to the graph origin.
 *
 * Returns a two-element array: [X, Y].
 */Dygraph.prototype.eventToDomCoords = function(event){if(event.offsetX && event.offsetY){return [event.offsetX,event.offsetY];}else {var eventElementPos=utils.findPos(this.mouseEventElement_);var canvasx=utils.pageX(event) - eventElementPos.x;var canvasy=utils.pageY(event) - eventElementPos.y;return [canvasx,canvasy];}}; /**
 * Given a canvas X coordinate, find the closest row.
 * @param {number} domX graph-relative DOM X coordinate
 * Returns {number} row number.
 * @private
 */Dygraph.prototype.findClosestRow = function(domX){var minDistX=Infinity;var closestRow=-1;var sets=this.layout_.points;for(var i=0;i < sets.length;i++) {var points=sets[i];var len=points.length;for(var j=0;j < len;j++) {var point=points[j];if(!utils.isValidPoint(point,true))continue;var dist=Math.abs(point.canvasx - domX);if(dist < minDistX){minDistX = dist;closestRow = point.idx;}}}return closestRow;}; /**
 * Given canvas X,Y coordinates, find the closest point.
 *
 * This finds the individual data point across all visible series
 * that's closest to the supplied DOM coordinates using the standard
 * Euclidean X,Y distance.
 *
 * @param {number} domX graph-relative DOM X coordinate
 * @param {number} domY graph-relative DOM Y coordinate
 * Returns: {row, seriesName, point}
 * @private
 */Dygraph.prototype.findClosestPoint = function(domX,domY){var minDist=Infinity;var dist,dx,dy,point,closestPoint,closestSeries,closestRow;for(var setIdx=this.layout_.points.length - 1;setIdx >= 0;--setIdx) {var points=this.layout_.points[setIdx];for(var i=0;i < points.length;++i) {point = points[i];if(!utils.isValidPoint(point))continue;dx = point.canvasx - domX;dy = point.canvasy - domY;dist = dx * dx + dy * dy;if(dist < minDist){minDist = dist;closestPoint = point;closestSeries = setIdx;closestRow = point.idx;}}}var name=this.layout_.setNames[closestSeries];return {row:closestRow,seriesName:name,point:closestPoint};}; /**
 * Given canvas X,Y coordinates, find the touched area in a stacked graph.
 *
 * This first finds the X data point closest to the supplied DOM X coordinate,
 * then finds the series which puts the Y coordinate on top of its filled area,
 * using linear interpolation between adjacent point pairs.
 *
 * @param {number} domX graph-relative DOM X coordinate
 * @param {number} domY graph-relative DOM Y coordinate
 * Returns: {row, seriesName, point}
 * @private
 */Dygraph.prototype.findStackedPoint = function(domX,domY){var row=this.findClosestRow(domX);var closestPoint,closestSeries;for(var setIdx=0;setIdx < this.layout_.points.length;++setIdx) {var boundary=this.getLeftBoundary_(setIdx);var rowIdx=row - boundary;var points=this.layout_.points[setIdx];if(rowIdx >= points.length)continue;var p1=points[rowIdx];if(!utils.isValidPoint(p1))continue;var py=p1.canvasy;if(domX > p1.canvasx && rowIdx + 1 < points.length){ // interpolate series Y value using next point
var p2=points[rowIdx + 1];if(utils.isValidPoint(p2)){var dx=p2.canvasx - p1.canvasx;if(dx > 0){var r=(domX - p1.canvasx) / dx;py += r * (p2.canvasy - p1.canvasy);}}}else if(domX < p1.canvasx && rowIdx > 0){ // interpolate series Y value using previous point
var p0=points[rowIdx - 1];if(utils.isValidPoint(p0)){var dx=p1.canvasx - p0.canvasx;if(dx > 0){var r=(p1.canvasx - domX) / dx;py += r * (p0.canvasy - p1.canvasy);}}} // Stop if the point (domX, py) is above this series' upper edge
if(setIdx === 0 || py < domY){closestPoint = p1;closestSeries = setIdx;}}var name=this.layout_.setNames[closestSeries];return {row:row,seriesName:name,point:closestPoint};}; /**
 * When the mouse moves in the canvas, display information about a nearby data
 * point and draw dots over those points in the data series. This function
 * takes care of cleanup of previously-drawn dots.
 * @param {Object} event The mousemove event from the browser.
 * @private
 */Dygraph.prototype.mouseMove_ = function(event){ // This prevents JS errors when mousing over the canvas before data loads.
var points=this.layout_.points;if(points === undefined || points === null)return;var canvasCoords=this.eventToDomCoords(event);var canvasx=canvasCoords[0];var canvasy=canvasCoords[1];var highlightSeriesOpts=this.getOption("highlightSeriesOpts");var selectionChanged=false;if(highlightSeriesOpts && !this.isSeriesLocked()){var closest;if(this.getBooleanOption("stackedGraph")){closest = this.findStackedPoint(canvasx,canvasy);}else {closest = this.findClosestPoint(canvasx,canvasy);}selectionChanged = this.setSelection(closest.row,closest.seriesName);}else {var idx=this.findClosestRow(canvasx);selectionChanged = this.setSelection(idx);}var callback=this.getFunctionOption("highlightCallback");if(callback && selectionChanged){callback.call(this,event,this.lastx_,this.selPoints_,this.lastRow_,this.highlightSet_);}}; /**
 * Fetch left offset from the specified set index or if not passed, the
 * first defined boundaryIds record (see bug #236).
 * @private
 */Dygraph.prototype.getLeftBoundary_ = function(setIdx){if(this.boundaryIds_[setIdx]){return this.boundaryIds_[setIdx][0];}else {for(var i=0;i < this.boundaryIds_.length;i++) {if(this.boundaryIds_[i] !== undefined){return this.boundaryIds_[i][0];}}return 0;}};Dygraph.prototype.animateSelection_ = function(direction){var totalSteps=10;var millis=30;if(this.fadeLevel === undefined)this.fadeLevel = 0;if(this.animateId === undefined)this.animateId = 0;var start=this.fadeLevel;var steps=direction < 0?start:totalSteps - start;if(steps <= 0){if(this.fadeLevel){this.updateSelection_(1.0);}return;}var thisId=++this.animateId;var that=this;var cleanupIfClearing=function cleanupIfClearing(){ // if we haven't reached fadeLevel 0 in the max frame time,
// ensure that the clear happens and just go to 0
if(that.fadeLevel !== 0 && direction < 0){that.fadeLevel = 0;that.clearSelection();}};utils.repeatAndCleanup(function(n){ // ignore simultaneous animations
if(that.animateId != thisId)return;that.fadeLevel += direction;if(that.fadeLevel === 0){that.clearSelection();}else {that.updateSelection_(that.fadeLevel / totalSteps);}},steps,millis,cleanupIfClearing);}; /**
 * Draw dots over the selectied points in the data series. This function
 * takes care of cleanup of previously-drawn dots.
 * @private
 */Dygraph.prototype.updateSelection_ = function(opt_animFraction){ /*var defaultPrevented = */this.cascadeEvents_('select',{selectedRow:this.lastRow_ === -1?undefined:this.lastRow_,selectedX:this.lastx_ === -1?undefined:this.lastx_,selectedPoints:this.selPoints_}); // TODO(danvk): use defaultPrevented here?
// Clear the previously drawn vertical, if there is one
var i;var ctx=this.canvas_ctx_;if(this.getOption('highlightSeriesOpts')){ctx.clearRect(0,0,this.width_,this.height_);var alpha=1.0 - this.getNumericOption('highlightSeriesBackgroundAlpha');var backgroundColor=utils.toRGB_(this.getOption('highlightSeriesBackgroundColor'));if(alpha){ // Activating background fade includes an animation effect for a gradual
// fade. TODO(klausw): make this independently configurable if it causes
// issues? Use a shared preference to control animations?
var animateBackgroundFade=true;if(animateBackgroundFade){if(opt_animFraction === undefined){ // start a new animation
this.animateSelection_(1);return;}alpha *= opt_animFraction;}ctx.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + alpha + ')';ctx.fillRect(0,0,this.width_,this.height_);} // Redraw only the highlighted series in the interactive canvas (not the
// static plot canvas, which is where series are usually drawn).
this.plotter_._renderLineChart(this.highlightSet_,ctx);}else if(this.previousVerticalX_ >= 0){ // Determine the maximum highlight circle size.
var maxCircleSize=0;var labels=this.attr_('labels');for(i = 1;i < labels.length;i++) {var r=this.getNumericOption('highlightCircleSize',labels[i]);if(r > maxCircleSize)maxCircleSize = r;}var px=this.previousVerticalX_;ctx.clearRect(px - maxCircleSize - 1,0,2 * maxCircleSize + 2,this.height_);}if(this.selPoints_.length > 0){ // Draw colored circles over the center of each selected point
var canvasx=this.selPoints_[0].canvasx;ctx.save();for(i = 0;i < this.selPoints_.length;i++) {var pt=this.selPoints_[i];if(isNaN(pt.canvasy))continue;var circleSize=this.getNumericOption('highlightCircleSize',pt.name);var callback=this.getFunctionOption("drawHighlightPointCallback",pt.name);var color=this.plotter_.colors[pt.name];if(!callback){callback = utils.Circles.DEFAULT;}ctx.lineWidth = this.getNumericOption('strokeWidth',pt.name);ctx.strokeStyle = color;ctx.fillStyle = color;callback.call(this,this,pt.name,ctx,canvasx,pt.canvasy,color,circleSize,pt.idx);}ctx.restore();this.previousVerticalX_ = canvasx;}}; /**
 * Manually set the selected points and display information about them in the
 * legend. The selection can be cleared using clearSelection() and queried
 * using getSelection().
 *
 * To set a selected series but not a selected point, call setSelection with
 * row=false and the selected series name.
 *
 * @param {number} row Row number that should be highlighted (i.e. appear with
 * hover dots on the chart).
 * @param {seriesName} optional series name to highlight that series with the
 * the highlightSeriesOpts setting.
 * @param { locked } optional If true, keep seriesName selected when mousing
 * over the graph, disabling closest-series highlighting. Call clearSelection()
 * to unlock it.
 */Dygraph.prototype.setSelection = function(row,opt_seriesName,opt_locked){ // Extract the points we've selected
this.selPoints_ = [];var changed=false;if(row !== false && row >= 0){if(row != this.lastRow_)changed = true;this.lastRow_ = row;for(var setIdx=0;setIdx < this.layout_.points.length;++setIdx) {var points=this.layout_.points[setIdx]; // Check if the point at the appropriate index is the point we're looking
// for.  If it is, just use it, otherwise search the array for a point
// in the proper place.
var setRow=row - this.getLeftBoundary_(setIdx);if(setRow >= 0 && setRow < points.length && points[setRow].idx == row){var point=points[setRow];if(point.yval !== null)this.selPoints_.push(point);}else {for(var pointIdx=0;pointIdx < points.length;++pointIdx) {var point=points[pointIdx];if(point.idx == row){if(point.yval !== null){this.selPoints_.push(point);}break;}}}}}else {if(this.lastRow_ >= 0)changed = true;this.lastRow_ = -1;}if(this.selPoints_.length){this.lastx_ = this.selPoints_[0].xval;}else {this.lastx_ = -1;}if(opt_seriesName !== undefined){if(this.highlightSet_ !== opt_seriesName)changed = true;this.highlightSet_ = opt_seriesName;}if(opt_locked !== undefined){this.lockedSet_ = opt_locked;}if(changed){this.updateSelection_(undefined);}return changed;}; /**
 * The mouse has left the canvas. Clear out whatever artifacts remain
 * @param {Object} event the mouseout event from the browser.
 * @private
 */Dygraph.prototype.mouseOut_ = function(event){if(this.getFunctionOption("unhighlightCallback")){this.getFunctionOption("unhighlightCallback").call(this,event);}if(this.getBooleanOption("hideOverlayOnMouseOut") && !this.lockedSet_){this.clearSelection();}}; /**
 * Clears the current selection (i.e. points that were highlighted by moving
 * the mouse over the chart).
 */Dygraph.prototype.clearSelection = function(){this.cascadeEvents_('deselect',{});this.lockedSet_ = false; // Get rid of the overlay data
if(this.fadeLevel){this.animateSelection_(-1);return;}this.canvas_ctx_.clearRect(0,0,this.width_,this.height_);this.fadeLevel = 0;this.selPoints_ = [];this.lastx_ = -1;this.lastRow_ = -1;this.highlightSet_ = null;}; /**
 * Returns the number of the currently selected row. To get data for this row,
 * you can use the getValue method.
 * @return {number} row number, or -1 if nothing is selected
 */Dygraph.prototype.getSelection = function(){if(!this.selPoints_ || this.selPoints_.length < 1){return -1;}for(var setIdx=0;setIdx < this.layout_.points.length;setIdx++) {var points=this.layout_.points[setIdx];for(var row=0;row < points.length;row++) {if(points[row].x == this.selPoints_[0].x){return points[row].idx;}}}return -1;}; /**
 * Returns the name of the currently-highlighted series.
 * Only available when the highlightSeriesOpts option is in use.
 */Dygraph.prototype.getHighlightSeries = function(){return this.highlightSet_;}; /**
 * Returns true if the currently-highlighted series was locked
 * via setSelection(..., seriesName, true).
 */Dygraph.prototype.isSeriesLocked = function(){return this.lockedSet_;}; /**
 * Fires when there's data available to be graphed.
 * @param {string} data Raw CSV data to be plotted
 * @private
 */Dygraph.prototype.loadedEvent_ = function(data){this.rawData_ = this.parseCSV_(data);this.cascadeDataDidUpdateEvent_();this.predraw_();}; /**
 * Add ticks on the x-axis representing years, months, quarters, weeks, or days
 * @private
 */Dygraph.prototype.addXTicks_ = function(){ // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...
var range;if(this.dateWindow_){range = [this.dateWindow_[0],this.dateWindow_[1]];}else {range = this.xAxisExtremes();}var xAxisOptionsView=this.optionsViewForAxis_('x');var xTicks=xAxisOptionsView('ticker')(range[0],range[1],this.plotter_.area.w, // TODO(danvk): should be area.width
xAxisOptionsView,this); // var msg = 'ticker(' + range[0] + ', ' + range[1] + ', ' + this.width_ + ', ' + this.attr_('pixelsPerXLabel') + ') -> ' + JSON.stringify(xTicks);
// console.log(msg);
this.layout_.setXTicks(xTicks);}; /**
 * Returns the correct handler class for the currently set options.
 * @private
 */Dygraph.prototype.getHandlerClass_ = function(){var handlerClass;if(this.attr_('dataHandler')){handlerClass = this.attr_('dataHandler');}else if(this.fractions_){if(this.getBooleanOption('errorBars')){handlerClass = _datahandlerBarsFractions2['default'];}else {handlerClass = _datahandlerDefaultFractions2['default'];}}else if(this.getBooleanOption('customBars')){handlerClass = _datahandlerBarsCustom2['default'];}else if(this.getBooleanOption('errorBars')){handlerClass = _datahandlerBarsError2['default'];}else {handlerClass = _datahandlerDefault2['default'];}return handlerClass;}; /**
 * @private
 * This function is called once when the chart's data is changed or the options
 * dictionary is updated. It is _not_ called when the user pans or zooms. The
 * idea is that values derived from the chart's data can be computed here,
 * rather than every time the chart is drawn. This includes things like the
 * number of axes, rolling averages, etc.
 */Dygraph.prototype.predraw_ = function(){var start=new Date(); // Create the correct dataHandler
this.dataHandler_ = new (this.getHandlerClass_())();this.layout_.computePlotArea(); // TODO(danvk): move more computations out of drawGraph_ and into here.
this.computeYAxes_();if(!this.is_initial_draw_){this.canvas_ctx_.restore();this.hidden_ctx_.restore();}this.canvas_ctx_.save();this.hidden_ctx_.save(); // Create a new plotter.
this.plotter_ = new _dygraphCanvas2['default'](this,this.hidden_,this.hidden_ctx_,this.layout_); // The roller sits in the bottom left corner of the chart. We don't know where
// this will be until the options are available, so it's positioned here.
this.createRollInterface_();this.cascadeEvents_('predraw'); // Convert the raw data (a 2D array) into the internal format and compute
// rolling averages.
this.rolledSeries_ = [null]; // x-axis is the first series and it's special
for(var i=1;i < this.numColumns();i++) { // var logScale = this.attr_('logscale', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.
var series=this.dataHandler_.extractSeries(this.rawData_,i,this.attributes_);if(this.rollPeriod_ > 1){series = this.dataHandler_.rollingAverage(series,this.rollPeriod_,this.attributes_);}this.rolledSeries_.push(series);} // If the data or options have changed, then we'd better redraw.
this.drawGraph_(); // This is used to determine whether to do various animations.
var end=new Date();this.drawingTimeMs_ = end - start;}; /**
 * Point structure.
 *
 * xval_* and yval_* are the original unscaled data values,
 * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.
 * yval_stacked is the cumulative Y value used for stacking graphs,
 * and bottom/top/minus/plus are used for error bar graphs.
 *
 * @typedef {{
 *     idx: number,
 *     name: string,
 *     x: ?number,
 *     xval: ?number,
 *     y_bottom: ?number,
 *     y: ?number,
 *     y_stacked: ?number,
 *     y_top: ?number,
 *     yval_minus: ?number,
 *     yval: ?number,
 *     yval_plus: ?number,
 *     yval_stacked
 * }}
 */Dygraph.PointType = undefined; /**
 * Calculates point stacking for stackedGraph=true.
 *
 * For stacking purposes, interpolate or extend neighboring data across
 * NaN values based on stackedGraphNaNFill settings. This is for display
 * only, the underlying data value as shown in the legend remains NaN.
 *
 * @param {Array.<Dygraph.PointType>} points Point array for a single series.
 *     Updates each Point's yval_stacked property.
 * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y
 *     values for the series seen so far. Index is the row number. Updated
 *     based on the current series's values.
 * @param {Array.<number>} seriesExtremes Min and max values, updated
 *     to reflect the stacked values.
 * @param {string} fillMethod Interpolation method, one of 'all', 'inside', or
 *     'none'.
 * @private
 */Dygraph.stackPoints_ = function(points,cumulativeYval,seriesExtremes,fillMethod){var lastXval=null;var prevPoint=null;var nextPoint=null;var nextPointIdx=-1; // Find the next stackable point starting from the given index.
var updateNextPoint=function updateNextPoint(idx){ // If we've previously found a non-NaN point and haven't gone past it yet,
// just use that.
if(nextPointIdx >= idx)return; // We haven't found a non-NaN point yet or have moved past it,
// look towards the right to find a non-NaN point.
for(var j=idx;j < points.length;++j) { // Clear out a previously-found point (if any) since it's no longer
// valid, we shouldn't use it for interpolation anymore.
nextPoint = null;if(!isNaN(points[j].yval) && points[j].yval !== null){nextPointIdx = j;nextPoint = points[j];break;}}};for(var i=0;i < points.length;++i) {var point=points[i];var xval=point.xval;if(cumulativeYval[xval] === undefined){cumulativeYval[xval] = 0;}var actualYval=point.yval;if(isNaN(actualYval) || actualYval === null){if(fillMethod == 'none'){actualYval = 0;}else { // Interpolate/extend for stacking purposes if possible.
updateNextPoint(i);if(prevPoint && nextPoint && fillMethod != 'none'){ // Use linear interpolation between prevPoint and nextPoint.
actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) * ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));}else if(prevPoint && fillMethod == 'all'){actualYval = prevPoint.yval;}else if(nextPoint && fillMethod == 'all'){actualYval = nextPoint.yval;}else {actualYval = 0;}}}else {prevPoint = point;}var stackedYval=cumulativeYval[xval];if(lastXval != xval){ // If an x-value is repeated, we ignore the duplicates.
stackedYval += actualYval;cumulativeYval[xval] = stackedYval;}lastXval = xval;point.yval_stacked = stackedYval;if(stackedYval > seriesExtremes[1]){seriesExtremes[1] = stackedYval;}if(stackedYval < seriesExtremes[0]){seriesExtremes[0] = stackedYval;}}}; /**
 * Loop over all fields and create datasets, calculating extreme y-values for
 * each series and extreme x-indices as we go.
 *
 * dateWindow is passed in as an explicit parameter so that we can compute
 * extreme values "speculatively", i.e. without actually setting state on the
 * dygraph.
 *
 * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where
 *     rolledSeries[seriesIndex][row] = raw point, where
 *     seriesIndex is the column number starting with 1, and
 *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].
 * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.
 * @return {{
 *     points: Array.<Array.<Dygraph.PointType>>,
 *     seriesExtremes: Array.<Array.<number>>,
 *     boundaryIds: Array.<number>}}
 * @private
 */Dygraph.prototype.gatherDatasets_ = function(rolledSeries,dateWindow){var boundaryIds=[];var points=[];var cumulativeYval=[]; // For stacked series.
var extremes={}; // series name -> [low, high]
var seriesIdx,sampleIdx;var firstIdx,lastIdx;var axisIdx; // Loop over the fields (series).  Go from the last to the first,
// because if they're stacked that's how we accumulate the values.
var num_series=rolledSeries.length - 1;var series;for(seriesIdx = num_series;seriesIdx >= 1;seriesIdx--) {if(!this.visibility()[seriesIdx - 1])continue; // Prune down to the desired range, if necessary (for zooming)
// Because there can be lines going to points outside of the visible area,
// we actually prune to visible points, plus one on either side.
if(dateWindow){series = rolledSeries[seriesIdx];var low=dateWindow[0];var high=dateWindow[1]; // TODO(danvk): do binary search instead of linear search.
// TODO(danvk): pass firstIdx and lastIdx directly to the renderer.
firstIdx = null;lastIdx = null;for(sampleIdx = 0;sampleIdx < series.length;sampleIdx++) {if(series[sampleIdx][0] >= low && firstIdx === null){firstIdx = sampleIdx;}if(series[sampleIdx][0] <= high){lastIdx = sampleIdx;}}if(firstIdx === null)firstIdx = 0;var correctedFirstIdx=firstIdx;var isInvalidValue=true;while(isInvalidValue && correctedFirstIdx > 0) {correctedFirstIdx--; // check if the y value is null.
isInvalidValue = series[correctedFirstIdx][1] === null;}if(lastIdx === null)lastIdx = series.length - 1;var correctedLastIdx=lastIdx;isInvalidValue = true;while(isInvalidValue && correctedLastIdx < series.length - 1) {correctedLastIdx++;isInvalidValue = series[correctedLastIdx][1] === null;}if(correctedFirstIdx !== firstIdx){firstIdx = correctedFirstIdx;}if(correctedLastIdx !== lastIdx){lastIdx = correctedLastIdx;}boundaryIds[seriesIdx - 1] = [firstIdx,lastIdx]; // .slice's end is exclusive, we want to include lastIdx.
series = series.slice(firstIdx,lastIdx + 1);}else {series = rolledSeries[seriesIdx];boundaryIds[seriesIdx - 1] = [0,series.length - 1];}var seriesName=this.attr_("labels")[seriesIdx];var seriesExtremes=this.dataHandler_.getExtremeYValues(series,dateWindow,this.getBooleanOption("stepPlot",seriesName));var seriesPoints=this.dataHandler_.seriesToPoints(series,seriesName,boundaryIds[seriesIdx - 1][0]);if(this.getBooleanOption("stackedGraph")){axisIdx = this.attributes_.axisForSeries(seriesName);if(cumulativeYval[axisIdx] === undefined){cumulativeYval[axisIdx] = [];}Dygraph.stackPoints_(seriesPoints,cumulativeYval[axisIdx],seriesExtremes,this.getBooleanOption("stackedGraphNaNFill"));}extremes[seriesName] = seriesExtremes;points[seriesIdx] = seriesPoints;}return {points:points,extremes:extremes,boundaryIds:boundaryIds};}; /**
 * Update the graph with new data. This method is called when the viewing area
 * has changed. If the underlying data or options have changed, predraw_ will
 * be called before drawGraph_ is called.
 *
 * @private
 */Dygraph.prototype.drawGraph_ = function(){var start=new Date(); // This is used to set the second parameter to drawCallback, below.
var is_initial_draw=this.is_initial_draw_;this.is_initial_draw_ = false;this.layout_.removeAllDatasets();this.setColors_();this.attrs_.pointSize = 0.5 * this.getNumericOption('highlightCircleSize');var packed=this.gatherDatasets_(this.rolledSeries_,this.dateWindow_);var points=packed.points;var extremes=packed.extremes;this.boundaryIds_ = packed.boundaryIds;this.setIndexByName_ = {};var labels=this.attr_("labels");var dataIdx=0;for(var i=1;i < points.length;i++) {if(!this.visibility()[i - 1])continue;this.layout_.addDataset(labels[i],points[i]);this.datasetIndex_[i] = dataIdx++;}for(var i=0;i < labels.length;i++) {this.setIndexByName_[labels[i]] = i;}this.computeYAxisRanges_(extremes);this.layout_.setYAxes(this.axes_);this.addXTicks_(); // Tell PlotKit to use this new data and render itself
this.layout_.evaluate();this.renderGraph_(is_initial_draw);if(this.getStringOption("timingName")){var end=new Date();console.log(this.getStringOption("timingName") + " - drawGraph: " + (end - start) + "ms");}}; /**
 * This does the work of drawing the chart. It assumes that the layout and axis
 * scales have already been set (e.g. by predraw_).
 *
 * @private
 */Dygraph.prototype.renderGraph_ = function(is_initial_draw){this.cascadeEvents_('clearChart');this.plotter_.clear();var underlayCallback=this.getFunctionOption('underlayCallback');if(underlayCallback){ // NOTE: we pass the dygraph object to this callback twice to avoid breaking
// users who expect a deprecated form of this callback.
underlayCallback.call(this,this.hidden_ctx_,this.layout_.getPlotArea(),this,this);}var e={canvas:this.hidden_,drawingContext:this.hidden_ctx_};this.cascadeEvents_('willDrawChart',e);this.plotter_.render();this.cascadeEvents_('didDrawChart',e);this.lastRow_ = -1; // because plugins/legend.js clears the legend
// TODO(danvk): is this a performance bottleneck when panning?
// The interaction canvas should already be empty in that situation.
this.canvas_.getContext('2d').clearRect(0,0,this.width_,this.height_);var drawCallback=this.getFunctionOption("drawCallback");if(drawCallback !== null){drawCallback.call(this,this,is_initial_draw);}if(is_initial_draw){this.readyFired_ = true;while(this.readyFns_.length > 0) {var fn=this.readyFns_.pop();fn(this);}}}; /**
 * @private
 * Determine properties of the y-axes which are independent of the data
 * currently being displayed. This includes things like the number of axes and
 * the style of the axes. It does not include the range of each axis and its
 * tick marks.
 * This fills in this.axes_.
 * axes_ = [ { options } ]
 *   indices are into the axes_ array.
 */Dygraph.prototype.computeYAxes_ = function(){var axis,index,opts,v; // this.axes_ doesn't match this.attributes_.axes_.options. It's used for
// data computation as well as options storage.
// Go through once and add all the axes.
this.axes_ = [];for(axis = 0;axis < this.attributes_.numAxes();axis++) { // Add a new axis, making a copy of its per-axis options.
opts = {g:this};utils.update(opts,this.attributes_.axisOptions(axis));this.axes_[axis] = opts;}for(axis = 0;axis < this.axes_.length;axis++) {if(axis === 0){opts = this.optionsViewForAxis_('y' + (axis?'2':''));v = opts("valueRange");if(v)this.axes_[axis].valueRange = v;}else { // To keep old behavior
var axes=this.user_attrs_.axes;if(axes && axes.y2){v = axes.y2.valueRange;if(v)this.axes_[axis].valueRange = v;}}}}; /**
 * Returns the number of y-axes on the chart.
 * @return {number} the number of axes.
 */Dygraph.prototype.numAxes = function(){return this.attributes_.numAxes();}; /**
 * @private
 * Returns axis properties for the given series.
 * @param {string} setName The name of the series for which to get axis
 * properties, e.g. 'Y1'.
 * @return {Object} The axis properties.
 */Dygraph.prototype.axisPropertiesForSeries = function(series){ // TODO(danvk): handle errors.
return this.axes_[this.attributes_.axisForSeries(series)];}; /**
 * @private
 * Determine the value range and tick marks for each axis.
 * @param {Object} extremes A mapping from seriesName -> [low, high]
 * This fills in the valueRange and ticks fields in each entry of this.axes_.
 */Dygraph.prototype.computeYAxisRanges_ = function(extremes){var isNullUndefinedOrNaN=function isNullUndefinedOrNaN(num){return isNaN(parseFloat(num));};var numAxes=this.attributes_.numAxes();var ypadCompat,span,series,ypad;var p_axis; // Compute extreme values, a span and tick marks for each axis.
for(var i=0;i < numAxes;i++) {var axis=this.axes_[i];var logscale=this.attributes_.getForAxis("logscale",i);var includeZero=this.attributes_.getForAxis("includeZero",i);var independentTicks=this.attributes_.getForAxis("independentTicks",i);series = this.attributes_.seriesForAxis(i); // Add some padding. This supports two Y padding operation modes:
//
// - backwards compatible (yRangePad not set):
//   10% padding for automatic Y ranges, but not for user-supplied
//   ranges, and move a close-to-zero edge to zero, since drawing at the edge
//   results in invisible lines. Unfortunately lines drawn at the edge of a
//   user-supplied range will still be invisible. If logscale is
//   set, add a variable amount of padding at the top but
//   none at the bottom.
//
// - new-style (yRangePad set by the user):
//   always add the specified Y padding.
//
ypadCompat = true;ypad = 0.1; // add 10%
var yRangePad=this.getNumericOption('yRangePad');if(yRangePad !== null){ypadCompat = false; // Convert pixel padding to ratio
ypad = yRangePad / this.plotter_.area.h;}if(series.length === 0){ // If no series are defined or visible then use a reasonable default
axis.extremeRange = [0,1];}else { // Calculate the extremes of extremes.
var minY=Infinity; // extremes[series[0]][0];
var maxY=-Infinity; // extremes[series[0]][1];
var extremeMinY,extremeMaxY;for(var j=0;j < series.length;j++) { // this skips invisible series
if(!extremes.hasOwnProperty(series[j]))continue; // Only use valid extremes to stop null data series' from corrupting the scale.
extremeMinY = extremes[series[j]][0];if(extremeMinY !== null){minY = Math.min(extremeMinY,minY);}extremeMaxY = extremes[series[j]][1];if(extremeMaxY !== null){maxY = Math.max(extremeMaxY,maxY);}} // Include zero if requested by the user.
if(includeZero && !logscale){if(minY > 0)minY = 0;if(maxY < 0)maxY = 0;} // Ensure we have a valid scale, otherwise default to [0, 1] for safety.
if(minY == Infinity)minY = 0;if(maxY == -Infinity)maxY = 1;span = maxY - minY; // special case: if we have no sense of scale, center on the sole value.
if(span === 0){if(maxY !== 0){span = Math.abs(maxY);}else { // ... and if the sole value is zero, use range 0-1.
maxY = 1;span = 1;}}var maxAxisY=maxY,minAxisY=minY;if(ypadCompat){if(logscale){maxAxisY = maxY + ypad * span;minAxisY = minY;}else {maxAxisY = maxY + ypad * span;minAxisY = minY - ypad * span; // Backwards-compatible behavior: Move the span to start or end at zero if it's
// close to zero.
if(minAxisY < 0 && minY >= 0)minAxisY = 0;if(maxAxisY > 0 && maxY <= 0)maxAxisY = 0;}}axis.extremeRange = [minAxisY,maxAxisY];}if(axis.valueRange){ // This is a user-set value range for this axis.
var y0=isNullUndefinedOrNaN(axis.valueRange[0])?axis.extremeRange[0]:axis.valueRange[0];var y1=isNullUndefinedOrNaN(axis.valueRange[1])?axis.extremeRange[1]:axis.valueRange[1];axis.computedValueRange = [y0,y1];}else {axis.computedValueRange = axis.extremeRange;}if(!ypadCompat){ // When using yRangePad, adjust the upper/lower bounds to add
// padding unless the user has zoomed/panned the Y axis range.
if(logscale){y0 = axis.computedValueRange[0];y1 = axis.computedValueRange[1];var y0pct=ypad / (2 * ypad - 1);var y1pct=(ypad - 1) / (2 * ypad - 1);axis.computedValueRange[0] = utils.logRangeFraction(y0,y1,y0pct);axis.computedValueRange[1] = utils.logRangeFraction(y0,y1,y1pct);}else {y0 = axis.computedValueRange[0];y1 = axis.computedValueRange[1];span = y1 - y0;axis.computedValueRange[0] = y0 - span * ypad;axis.computedValueRange[1] = y1 + span * ypad;}}if(independentTicks){axis.independentTicks = independentTicks;var opts=this.optionsViewForAxis_('y' + (i?'2':''));var ticker=opts('ticker');axis.ticks = ticker(axis.computedValueRange[0],axis.computedValueRange[1],this.plotter_.area.h,opts,this); // Define the first independent axis as primary axis.
if(!p_axis)p_axis = axis;}}if(p_axis === undefined){throw "Configuration Error: At least one axis has to have the \\"independentTicks\\" option activated.";} // Add ticks. By default, all axes inherit the tick positions of the
// primary axis. However, if an axis is specifically marked as having
// independent ticks, then that is permissible as well.
for(var i=0;i < numAxes;i++) {var axis=this.axes_[i];if(!axis.independentTicks){var opts=this.optionsViewForAxis_('y' + (i?'2':''));var ticker=opts('ticker');var p_ticks=p_axis.ticks;var p_scale=p_axis.computedValueRange[1] - p_axis.computedValueRange[0];var scale=axis.computedValueRange[1] - axis.computedValueRange[0];var tick_values=[];for(var k=0;k < p_ticks.length;k++) {var y_frac=(p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;var y_val=axis.computedValueRange[0] + y_frac * scale;tick_values.push(y_val);}axis.ticks = ticker(axis.computedValueRange[0],axis.computedValueRange[1],this.plotter_.area.h,opts,this,tick_values);}}}; /**
 * Detects the type of the str (date or numeric) and sets the various
 * formatting attributes in this.attrs_ based on this type.
 * @param {string} str An x value.
 * @private
 */Dygraph.prototype.detectTypeFromString_ = function(str){var isDate=false;var dashPos=str.indexOf('-'); // could be 2006-01-01 _or_ 1.0e-2
if(dashPos > 0 && str[dashPos - 1] != 'e' && str[dashPos - 1] != 'E' || str.indexOf('/') >= 0 || isNaN(parseFloat(str))){isDate = true;}else if(str.length == 8 && str > '19700101' && str < '20371231'){ // TODO(danvk): remove support for this format.
isDate = true;}this.setXAxisOptions_(isDate);};Dygraph.prototype.setXAxisOptions_ = function(isDate){if(isDate){this.attrs_.xValueParser = utils.dateParser;this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;}else { /** @private (shut up, jsdoc!) */this.attrs_.xValueParser = function(x){return parseFloat(x);}; // TODO(danvk): use Dygraph.numberValueFormatter here?
/** @private (shut up, jsdoc!) */this.attrs_.axes.x.valueFormatter = function(x){return x;};this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;}}; /**
 * @private
 * Parses a string in a special csv format.  We expect a csv file where each
 * line is a date point, and the first field in each line is the date string.
 * We also expect that all remaining fields represent series.
 * if the errorBars attribute is set, then interpret the fields as:
 * date, series1, stddev1, series2, stddev2, ...
 * @param {[Object]} data See above.
 *
 * @return [Object] An array with one entry for each row. These entries
 * are an array of cells in that row. The first entry is the parsed x-value for
 * the row. The second, third, etc. are the y-values. These can take on one of
 * three forms, depending on the CSV and constructor parameters:
 * 1. numeric value
 * 2. [ value, stddev ]
 * 3. [ low value, center value, high value ]
 */Dygraph.prototype.parseCSV_ = function(data){var ret=[];var line_delimiter=utils.detectLineDelimiter(data);var lines=data.split(line_delimiter || "\\n");var vals,j; // Use the default delimiter or fall back to a tab if that makes sense.
var delim=this.getStringOption('delimiter');if(lines[0].indexOf(delim) == -1 && lines[0].indexOf('\t') >= 0){delim = '\t';}var start=0;if(!('labels' in this.user_attrs_)){ // User hasn't explicitly set labels, so they're (presumably) in the CSV.
start = 1;this.attrs_.labels = lines[0].split(delim); // NOTE: _not_ user_attrs_.
this.attributes_.reparseSeries();}var line_no=0;var xParser;var defaultParserSet=false; // attempt to auto-detect x value type
var expectedCols=this.attr_("labels").length;var outOfOrder=false;for(var i=start;i < lines.length;i++) {var line=lines[i];line_no = i;if(line.length === 0)continue; // skip blank lines
if(line[0] == '#')continue; // skip comment lines
var inFields=line.split(delim);if(inFields.length < 2)continue;var fields=[];if(!defaultParserSet){this.detectTypeFromString_(inFields[0]);xParser = this.getFunctionOption("xValueParser");defaultParserSet = true;}fields[0] = xParser(inFields[0],this); // If fractions are expected, parse the numbers as "A/B"
if(this.fractions_){for(j = 1;j < inFields.length;j++) { // TODO(danvk): figure out an appropriate way to flag parse errors.
vals = inFields[j].split("/");if(vals.length != 2){console.error('Expected fractional "num/den" values in CSV data ' + "but found a value '" + inFields[j] + "' on line " + (1 + i) + " ('" + line + "') which is not of this form.");fields[j] = [0,0];}else {fields[j] = [utils.parseFloat_(vals[0],i,line),utils.parseFloat_(vals[1],i,line)];}}}else if(this.getBooleanOption("errorBars")){ // If there are error bars, values are (value, stddev) pairs
if(inFields.length % 2 != 1){console.error('Expected alternating (value, stdev.) pairs in CSV data ' + 'but line ' + (1 + i) + ' has an odd number of values (' + (inFields.length - 1) + "): '" + line + "'");}for(j = 1;j < inFields.length;j += 2) {fields[(j + 1) / 2] = [utils.parseFloat_(inFields[j],i,line),utils.parseFloat_(inFields[j + 1],i,line)];}}else if(this.getBooleanOption("customBars")){ // Bars are a low;center;high tuple
for(j = 1;j < inFields.length;j++) {var val=inFields[j];if(/^ *$/.test(val)){fields[j] = [null,null,null];}else {vals = val.split(";");if(vals.length == 3){fields[j] = [utils.parseFloat_(vals[0],i,line),utils.parseFloat_(vals[1],i,line),utils.parseFloat_(vals[2],i,line)];}else {console.warn('When using customBars, values must be either blank ' + 'or "low;center;high" tuples (got "' + val + '" on line ' + (1 + i));}}}}else { // Values are just numbers
for(j = 1;j < inFields.length;j++) {fields[j] = utils.parseFloat_(inFields[j],i,line);}}if(ret.length > 0 && fields[0] < ret[ret.length - 1][0]){outOfOrder = true;}if(fields.length != expectedCols){console.error("Number of columns in line " + i + " (" + fields.length + ") does not agree with number of labels (" + expectedCols + ") " + line);} // If the user specified the 'labels' option and none of the cells of the
// first row parsed correctly, then they probably double-specified the
// labels. We go with the values set in the option, discard this row and
// log a warning to the JS console.
if(i === 0 && this.attr_('labels')){var all_null=true;for(j = 0;all_null && j < fields.length;j++) {if(fields[j])all_null = false;}if(all_null){console.warn("The dygraphs 'labels' option is set, but the first row " + "of CSV data ('" + line + "') appears to also contain " + "labels. Will drop the CSV labels and use the option " + "labels.");continue;}}ret.push(fields);}if(outOfOrder){console.warn("CSV is out of order; order it correctly to speed loading.");ret.sort(function(a,b){return a[0] - b[0];});}return ret;}; // In native format, all values must be dates or numbers.
// This check isn't perfect but will catch most mistaken uses of strings.
function validateNativeFormat(data){var firstRow=data[0];var firstX=firstRow[0];if(typeof firstX !== 'number' && !utils.isDateLike(firstX)){throw new Error('Expected number or date but got ' + typeof firstX + ': ' + firstX + '.');}for(var i=1;i < firstRow.length;i++) {var val=firstRow[i];if(val === null || val === undefined)continue;if(typeof val === 'number')continue;if(utils.isArrayLike(val))continue; // e.g. error bars or custom bars.
throw new Error('Expected number or array but got ' + typeof val + ': ' + val + '.');}} /**
 * The user has provided their data as a pre-packaged JS array. If the x values
 * are numeric, this is the same as dygraphs' internal format. If the x values
 * are dates, we need to convert them from Date objects to ms since epoch.
 * @param {!Array} data
 * @return {Object} data with numeric x values.
 * @private
 */Dygraph.prototype.parseArray_ = function(data){ // Peek at the first x value to see if it's numeric.
if(data.length === 0){console.error("Can't plot empty data set");return null;}if(data[0].length === 0){console.error("Data set cannot contain an empty row");return null;}validateNativeFormat(data);var i;if(this.attr_("labels") === null){console.warn("Using default labels. Set labels explicitly via 'labels' " + "in the options parameter");this.attrs_.labels = ["X"];for(i = 1;i < data[0].length;i++) {this.attrs_.labels.push("Y" + i); // Not user_attrs_.
}this.attributes_.reparseSeries();}else {var num_labels=this.attr_("labels");if(num_labels.length != data[0].length){console.error("Mismatch between number of labels (" + num_labels + ")" + " and number of columns in array (" + data[0].length + ")");return null;}}if(utils.isDateLike(data[0][0])){ // Some intelligent defaults for a date x-axis.
this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter; // Assume they're all dates.
var parsedData=utils.clone(data);for(i = 0;i < data.length;i++) {if(parsedData[i].length === 0){console.error("Row " + (1 + i) + " of data is empty");return null;}if(parsedData[i][0] === null || typeof parsedData[i][0].getTime != 'function' || isNaN(parsedData[i][0].getTime())){console.error("x value in row " + (1 + i) + " is not a Date");return null;}parsedData[i][0] = parsedData[i][0].getTime();}return parsedData;}else { // Some intelligent defaults for a numeric x-axis.
/** @private (shut up, jsdoc!) */this.attrs_.axes.x.valueFormatter = function(x){return x;};this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;this.attrs_.axes.x.axisLabelFormatter = utils.numberAxisLabelFormatter;return data;}}; /**
 * Parses a DataTable object from gviz.
 * The data is expected to have a first column that is either a date or a
 * number. All subsequent columns must be numbers. If there is a clear mismatch
 * between this.xValueParser_ and the type of the first column, it will be
 * fixed. Fills out rawData_.
 * @param {!google.visualization.DataTable} data See above.
 * @private
 */Dygraph.prototype.parseDataTable_ = function(data){var shortTextForAnnotationNum=function shortTextForAnnotationNum(num){ // converts [0-9]+ [A-Z][a-z]*
// example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab
// and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz
var shortText=String.fromCharCode(65 /* A */ + num % 26);num = Math.floor(num / 26);while(num > 0) {shortText = String.fromCharCode(65 /* A */ + (num - 1) % 26) + shortText.toLowerCase();num = Math.floor((num - 1) / 26);}return shortText;};var cols=data.getNumberOfColumns();var rows=data.getNumberOfRows();var indepType=data.getColumnType(0);if(indepType == 'date' || indepType == 'datetime'){this.attrs_.xValueParser = utils.dateParser;this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;}else if(indepType == 'number'){this.attrs_.xValueParser = function(x){return parseFloat(x);};this.attrs_.axes.x.valueFormatter = function(x){return x;};this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;}else {throw new Error("only 'date', 'datetime' and 'number' types are supported " + "for column 1 of DataTable input (Got '" + indepType + "')");} // Array of the column indices which contain data (and not annotations).
var colIdx=[];var annotationCols={}; // data index -> [annotation cols]
var hasAnnotations=false;var i,j;for(i = 1;i < cols;i++) {var type=data.getColumnType(i);if(type == 'number'){colIdx.push(i);}else if(type == 'string' && this.getBooleanOption('displayAnnotations')){ // This is OK -- it's an annotation column.
var dataIdx=colIdx[colIdx.length - 1];if(!annotationCols.hasOwnProperty(dataIdx)){annotationCols[dataIdx] = [i];}else {annotationCols[dataIdx].push(i);}hasAnnotations = true;}else {throw new Error("Only 'number' is supported as a dependent type with Gviz." + " 'string' is only supported if displayAnnotations is true");}} // Read column labels
// TODO(danvk): add support back for errorBars
var labels=[data.getColumnLabel(0)];for(i = 0;i < colIdx.length;i++) {labels.push(data.getColumnLabel(colIdx[i]));if(this.getBooleanOption("errorBars"))i += 1;}this.attrs_.labels = labels;cols = labels.length;var ret=[];var outOfOrder=false;var annotations=[];for(i = 0;i < rows;i++) {var row=[];if(typeof data.getValue(i,0) === 'undefined' || data.getValue(i,0) === null){console.warn("Ignoring row " + i + " of DataTable because of undefined or null first column.");continue;}if(indepType == 'date' || indepType == 'datetime'){row.push(data.getValue(i,0).getTime());}else {row.push(data.getValue(i,0));}if(!this.getBooleanOption("errorBars")){for(j = 0;j < colIdx.length;j++) {var col=colIdx[j];row.push(data.getValue(i,col));if(hasAnnotations && annotationCols.hasOwnProperty(col) && data.getValue(i,annotationCols[col][0]) !== null){var ann={};ann.series = data.getColumnLabel(col);ann.xval = row[0];ann.shortText = shortTextForAnnotationNum(annotations.length);ann.text = '';for(var k=0;k < annotationCols[col].length;k++) {if(k)ann.text += "\\n";ann.text += data.getValue(i,annotationCols[col][k]);}annotations.push(ann);}} // Strip out infinities, which give dygraphs problems later on.
for(j = 0;j < row.length;j++) {if(!isFinite(row[j]))row[j] = null;}}else {for(j = 0;j < cols - 1;j++) {row.push([data.getValue(i,1 + 2 * j),data.getValue(i,2 + 2 * j)]);}}if(ret.length > 0 && row[0] < ret[ret.length - 1][0]){outOfOrder = true;}ret.push(row);}if(outOfOrder){console.warn("DataTable is out of order; order it correctly to speed loading.");ret.sort(function(a,b){return a[0] - b[0];});}this.rawData_ = ret;if(annotations.length > 0){this.setAnnotations(annotations,true);}this.attributes_.reparseSeries();}; /**
 * Signals to plugins that the chart data has updated.
 * This happens after the data has updated but before the chart has redrawn.
 * @private
 */Dygraph.prototype.cascadeDataDidUpdateEvent_ = function(){ // TODO(danvk): there are some issues checking xAxisRange() and using
// toDomCoords from handlers of this event. The visible range should be set
// when the chart is drawn, not derived from the data.
this.cascadeEvents_('dataDidUpdate',{});}; /**
 * Get the CSV data. If it's in a function, call that function. If it's in a
 * file, do an XMLHttpRequest to get it.
 * @private
 */Dygraph.prototype.start_ = function(){var data=this.file_; // Functions can return references of all other types.
if(typeof data == 'function'){data = data();}if(utils.isArrayLike(data)){this.rawData_ = this.parseArray_(data);this.cascadeDataDidUpdateEvent_();this.predraw_();}else if(typeof data == 'object' && typeof data.getColumnRange == 'function'){ // must be a DataTable from gviz.
this.parseDataTable_(data);this.cascadeDataDidUpdateEvent_();this.predraw_();}else if(typeof data == 'string'){ // Heuristic: a newline means it's CSV data. Otherwise it's an URL.
var line_delimiter=utils.detectLineDelimiter(data);if(line_delimiter){this.loadedEvent_(data);}else { // REMOVE_FOR_IE
var req;if(window.XMLHttpRequest){ // Firefox, Opera, IE7, and other browsers will use the native object
req = new XMLHttpRequest();}else { // IE 5 and 6 will use the ActiveX control
req = new ActiveXObject("Microsoft.XMLHTTP");}var caller=this;req.onreadystatechange = function(){if(req.readyState == 4){if(req.status === 200 ||  // Normal http
req.status === 0){ // Chrome w/ --allow-file-access-from-files
caller.loadedEvent_(req.responseText);}}};req.open("GET",data,true);req.send(null);}}else {console.error("Unknown data format: " + typeof data);}}; /**
 * Changes various properties of the graph. These can include:
 * <ul>
 * <li>file: changes the source data for the graph</li>
 * <li>errorBars: changes whether the data contains stddev</li>
 * </ul>
 *
 * There's a huge variety of options that can be passed to this method. For a
 * full list, see http://dygraphs.com/options.html.
 *
 * @param {Object} input_attrs The new properties and values
 * @param {boolean} block_redraw Usually the chart is redrawn after every
 *     call to updateOptions(). If you know better, you can pass true to
 *     explicitly block the redraw. This can be useful for chaining
 *     updateOptions() calls, avoiding the occasional infinite loop and
 *     preventing redraws when it's not necessary (e.g. when updating a
 *     callback).
 */Dygraph.prototype.updateOptions = function(input_attrs,block_redraw){if(typeof block_redraw == 'undefined')block_redraw = false; // copyUserAttrs_ drops the "file" parameter as a convenience to us.
var file=input_attrs.file;var attrs=Dygraph.copyUserAttrs_(input_attrs); // TODO(danvk): this is a mess. Move these options into attr_.
if('rollPeriod' in attrs){this.rollPeriod_ = attrs.rollPeriod;}if('dateWindow' in attrs){this.dateWindow_ = attrs.dateWindow;} // TODO(danvk): validate per-series options.
// Supported:
// strokeWidth
// pointSize
// drawPoints
// highlightCircleSize
// Check if this set options will require new points.
var requiresNewPoints=utils.isPixelChangingOptionList(this.attr_("labels"),attrs);utils.updateDeep(this.user_attrs_,attrs);this.attributes_.reparseSeries();if(file){ // This event indicates that the data is about to change, but hasn't yet.
// TODO(danvk): support cancellation of the update via this event.
this.cascadeEvents_('dataWillUpdate',{});this.file_ = file;if(!block_redraw)this.start_();}else {if(!block_redraw){if(requiresNewPoints){this.predraw_();}else {this.renderGraph_(false);}}}}; /**
 * Make a copy of input attributes, removing file as a convenience.
 * @private
 */Dygraph.copyUserAttrs_ = function(attrs){var my_attrs={};for(var k in attrs) {if(!attrs.hasOwnProperty(k))continue;if(k == 'file')continue;if(attrs.hasOwnProperty(k))my_attrs[k] = attrs[k];}return my_attrs;}; /**
 * Resizes the dygraph. If no parameters are specified, resizes to fill the
 * containing div (which has presumably changed size since the dygraph was
 * instantiated. If the width/height are specified, the div will be resized.
 *
 * This is far more efficient than destroying and re-instantiating a
 * Dygraph, since it doesn't have to reparse the underlying data.
 *
 * @param {number} width Width (in pixels)
 * @param {number} height Height (in pixels)
 */Dygraph.prototype.resize = function(width,height){if(this.resize_lock){return;}this.resize_lock = true;if(width === null != (height === null)){console.warn("Dygraph.resize() should be called with zero parameters or " + "two non-NULL parameters. Pretending it was zero.");width = height = null;}var old_width=this.width_;var old_height=this.height_;if(width){this.maindiv_.style.width = width + "px";this.maindiv_.style.height = height + "px";this.width_ = width;this.height_ = height;}else {this.width_ = this.maindiv_.clientWidth;this.height_ = this.maindiv_.clientHeight;}if(old_width != this.width_ || old_height != this.height_){ // Resizing a canvas erases it, even when the size doesn't change, so
// any resize needs to be followed by a redraw.
this.resizeElements_();this.predraw_();}this.resize_lock = false;}; /**
 * Adjusts the number of points in the rolling average. Updates the graph to
 * reflect the new averaging period.
 * @param {number} length Number of points over which to average the data.
 */Dygraph.prototype.adjustRoll = function(length){this.rollPeriod_ = length;this.predraw_();}; /**
 * Returns a boolean array of visibility statuses.
 */Dygraph.prototype.visibility = function(){ // Do lazy-initialization, so that this happens after we know the number of
// data series.
if(!this.getOption("visibility")){this.attrs_.visibility = [];} // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.
while(this.getOption("visibility").length < this.numColumns() - 1) {this.attrs_.visibility.push(true);}return this.getOption("visibility");}; /**
 * Changes the visibility of one or more series.
 *
 * @param {number|number[]|object} num the series index or an array of series indices
 *                                     or a boolean array of visibility states by index
 *                                     or an object mapping series numbers, as keys, to
 *                                     visibility state (boolean values)
 * @param {boolean} value the visibility state expressed as a boolean
 */Dygraph.prototype.setVisibility = function(num,value){var x=this.visibility();var numIsObject=false;if(!Array.isArray(num)){if(num !== null && typeof num === 'object'){numIsObject = true;}else {num = [num];}}if(numIsObject){for(var i in num) {if(num.hasOwnProperty(i)){if(i < 0 || i >= x.length){console.warn("Invalid series number in setVisibility: " + i);}else {x[i] = num[i];}}}}else {for(var i=0;i < num.length;i++) {if(typeof num[i] === 'boolean'){if(i >= x.length){console.warn("Invalid series number in setVisibility: " + i);}else {x[i] = num[i];}}else {if(num[i] < 0 || num[i] >= x.length){console.warn("Invalid series number in setVisibility: " + num[i]);}else {x[num[i]] = value;}}}}this.predraw_();}; /**
 * How large of an area will the dygraph render itself in?
 * This is used for testing.
 * @return A {width: w, height: h} object.
 * @private
 */Dygraph.prototype.size = function(){return {width:this.width_,height:this.height_};}; /**
 * Update the list of annotations and redraw the chart.
 * See dygraphs.com/annotations.html for more info on how to use annotations.
 * @param ann {Array} An array of annotation objects.
 * @param suppressDraw {Boolean} Set to "true" to block chart redraw (optional).
 */Dygraph.prototype.setAnnotations = function(ann,suppressDraw){ // Only add the annotation CSS rule once we know it will be used.
this.annotations_ = ann;if(!this.layout_){console.warn("Tried to setAnnotations before dygraph was ready. " + "Try setting them in a ready() block. See " + "dygraphs.com/tests/annotation.html");return;}this.layout_.setAnnotations(this.annotations_);if(!suppressDraw){this.predraw_();}}; /**
 * Return the list of annotations.
 */Dygraph.prototype.annotations = function(){return this.annotations_;}; /**
 * Get the list of label names for this graph. The first column is the
 * x-axis, so the data series names start at index 1.
 *
 * Returns null when labels have not yet been defined.
 */Dygraph.prototype.getLabels = function(){var labels=this.attr_("labels");return labels?labels.slice():null;}; /**
 * Get the index of a series (column) given its name. The first column is the
 * x-axis, so the data series start with index 1.
 */Dygraph.prototype.indexFromSetName = function(name){return this.setIndexByName_[name];}; /**
 * Find the row number corresponding to the given x-value.
 * Returns null if there is no such x-value in the data.
 * If there are multiple rows with the same x-value, this will return the
 * first one.
 * @param {number} xVal The x-value to look for (e.g. millis since epoch).
 * @return {?number} The row number, which you can pass to getValue(), or null.
 */Dygraph.prototype.getRowForX = function(xVal){var low=0,high=this.numRows() - 1;while(low <= high) {var idx=high + low >> 1;var x=this.getValue(idx,0);if(x < xVal){low = idx + 1;}else if(x > xVal){high = idx - 1;}else if(low != idx){ // equal, but there may be an earlier match.
high = idx;}else {return idx;}}return null;}; /**
 * Trigger a callback when the dygraph has drawn itself and is ready to be
 * manipulated. This is primarily useful when dygraphs has to do an XHR for the
 * data (i.e. a URL is passed as the data source) and the chart is drawn
 * asynchronously. If the chart has already drawn, the callback will fire
 * immediately.
 *
 * This is a good place to call setAnnotation().
 *
 * @param {function(!Dygraph)} callback The callback to trigger when the chart
 *     is ready.
 */Dygraph.prototype.ready = function(callback){if(this.is_initial_draw_){this.readyFns_.push(callback);}else {callback.call(this,this);}}; /**
 * Add an event handler. This event handler is kept until the graph is
 * destroyed with a call to graph.destroy().
 *
 * @param {!Node} elem The element to add the event to.
 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
 * @param {function(Event):(boolean|undefined)} fn The function to call
 *     on the event. The function takes one parameter: the event object.
 * @private
 */Dygraph.prototype.addAndTrackEvent = function(elem,type,fn){utils.addEvent(elem,type,fn);this.registeredEvents_.push({elem:elem,type:type,fn:fn});};Dygraph.prototype.removeTrackedEvents_ = function(){if(this.registeredEvents_){for(var idx=0;idx < this.registeredEvents_.length;idx++) {var reg=this.registeredEvents_[idx];utils.removeEvent(reg.elem,reg.type,reg.fn);}}this.registeredEvents_ = [];}; // Installed plugins, in order of precedence (most-general to most-specific).
Dygraph.PLUGINS = [_pluginsLegend2['default'],_pluginsAxes2['default'],_pluginsRangeSelector2['default'], // Has to be before ChartLabels so that its callbacks are called after ChartLabels' callbacks.
_pluginsChartLabels2['default'],_pluginsAnnotations2['default'],_pluginsGrid2['default']]; // There are many symbols which have historically been available through the
// Dygraph class. These are exported here for backwards compatibility.
Dygraph.GVizChart = _dygraphGviz2['default'];Dygraph.DASHED_LINE = utils.DASHED_LINE;Dygraph.DOT_DASH_LINE = utils.DOT_DASH_LINE;Dygraph.dateAxisLabelFormatter = utils.dateAxisLabelFormatter;Dygraph.toRGB_ = utils.toRGB_;Dygraph.findPos = utils.findPos;Dygraph.pageX = utils.pageX;Dygraph.pageY = utils.pageY;Dygraph.dateString_ = utils.dateString_;Dygraph.defaultInteractionModel = _dygraphInteractionModel2['default'].defaultModel;Dygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = _dygraphInteractionModel2['default'].nonInteractiveModel_;Dygraph.Circles = utils.Circles;Dygraph.Plugins = {Legend:_pluginsLegend2['default'],Axes:_pluginsAxes2['default'],Annotations:_pluginsAnnotations2['default'],ChartLabels:_pluginsChartLabels2['default'],Grid:_pluginsGrid2['default'],RangeSelector:_pluginsRangeSelector2['default']};Dygraph.DataHandlers = {DefaultHandler:_datahandlerDefault2['default'],BarsHandler:_datahandlerBars2['default'],CustomBarsHandler:_datahandlerBarsCustom2['default'],DefaultFractionHandler:_datahandlerDefaultFractions2['default'],ErrorBarsHandler:_datahandlerBarsError2['default'],FractionsBarsHandler:_datahandlerBarsFractions2['default']};Dygraph.startPan = _dygraphInteractionModel2['default'].startPan;Dygraph.startZoom = _dygraphInteractionModel2['default'].startZoom;Dygraph.movePan = _dygraphInteractionModel2['default'].movePan;Dygraph.moveZoom = _dygraphInteractionModel2['default'].moveZoom;Dygraph.endPan = _dygraphInteractionModel2['default'].endPan;Dygraph.endZoom = _dygraphInteractionModel2['default'].endZoom;Dygraph.numericLinearTicks = DygraphTickers.numericLinearTicks;Dygraph.numericTicks = DygraphTickers.numericTicks;Dygraph.dateTicker = DygraphTickers.dateTicker;Dygraph.Granularity = DygraphTickers.Granularity;Dygraph.getDateAxis = DygraphTickers.getDateAxis;Dygraph.floatFormat = utils.floatFormat;exports['default'] = Dygraph;module.exports = exports['default'];

}).call(this,require('_process'))

},{"./datahandler/bars":5,"./datahandler/bars-custom":2,"./datahandler/bars-error":3,"./datahandler/bars-fractions":4,"./datahandler/default":8,"./datahandler/default-fractions":7,"./dygraph-canvas":9,"./dygraph-default-attrs":10,"./dygraph-gviz":11,"./dygraph-interaction-model":12,"./dygraph-layout":13,"./dygraph-options":15,"./dygraph-options-reference":14,"./dygraph-tickers":16,"./dygraph-utils":17,"./iframe-tarp":19,"./plugins/annotations":20,"./plugins/axes":21,"./plugins/chart-labels":22,"./plugins/grid":23,"./plugins/legend":24,"./plugins/range-selector":25,"_process":1}],19:[function(require,module,exports){
/**
 * To create a "drag" interaction, you typically register a mousedown event
 * handler on the element where the drag begins. In that handler, you register a
 * mouseup handler on the window to determine when the mouse is released,
 * wherever that release happens. This works well, except when the user releases
 * the mouse over an off-domain iframe. In that case, the mouseup event is
 * handled by the iframe and never bubbles up to the window handler.
 *
 * To deal with this issue, we cover iframes with high z-index divs to make sure
 * they don't capture mouseup.
 *
 * Usage:
 * element.addEventListener('mousedown', function() {
 *   var tarper = new IFrameTarp();
 *   tarper.cover();
 *   var mouseUpHandler = function() {
 *     ...
 *     window.removeEventListener(mouseUpHandler);
 *     tarper.uncover();
 *   };
 *   window.addEventListener('mouseup', mouseUpHandler);
 * };
 *
 * @constructor
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

function IFrameTarp() {
  /** @type {Array.<!HTMLDivElement>} */
  this.tarps = [];
};

/**
 * Find all the iframes in the document and cover them with high z-index
 * transparent divs.
 */
IFrameTarp.prototype.cover = function () {
  var iframes = document.getElementsByTagName("iframe");
  for (var i = 0; i < iframes.length; i++) {
    var iframe = iframes[i];
    var pos = utils.findPos(iframe),
        x = pos.x,
        y = pos.y,
        width = iframe.offsetWidth,
        height = iframe.offsetHeight;

    var div = document.createElement("div");
    div.style.position = "absolute";
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    div.style.width = width + 'px';
    div.style.height = height + 'px';
    div.style.zIndex = 999;
    document.body.appendChild(div);
    this.tarps.push(div);
  }
};

/**
 * Remove all the iframe covers. You should call this in a mouseup handler.
 */
IFrameTarp.prototype.uncover = function () {
  for (var i = 0; i < this.tarps.length; i++) {
    this.tarps[i].parentNode.removeChild(this.tarps[i]);
  }
  this.tarps = [];
};

exports["default"] = IFrameTarp;
module.exports = exports["default"];

},{"./dygraph-utils":17}],20:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/*global Dygraph:false */

"use strict";

/**
Current bits of jankiness:
- Uses dygraph.layout_ to get the parsed annotations.
- Uses dygraph.plotter_.area

It would be nice if the plugin didn't require so much special support inside
the core dygraphs classes, but annotations involve quite a bit of parsing and
layout.

TODO(danvk): cache DOM elements.
*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var annotations = function annotations() {
  this.annotations_ = [];
};

annotations.prototype.toString = function () {
  return "Annotations Plugin";
};

annotations.prototype.activate = function (g) {
  return {
    clearChart: this.clearChart,
    didDrawChart: this.didDrawChart
  };
};

annotations.prototype.detachLabels = function () {
  for (var i = 0; i < this.annotations_.length; i++) {
    var a = this.annotations_[i];
    if (a.parentNode) a.parentNode.removeChild(a);
    this.annotations_[i] = null;
  }
  this.annotations_ = [];
};

annotations.prototype.clearChart = function (e) {
  this.detachLabels();
};

annotations.prototype.didDrawChart = function (e) {
  var g = e.dygraph;

  // Early out in the (common) case of zero annotations.
  var points = g.layout_.annotated_points;
  if (!points || points.length === 0) return;

  var containerDiv = e.canvas.parentNode;

  var bindEvt = function bindEvt(eventName, classEventName, pt) {
    return function (annotation_event) {
      var a = pt.annotation;
      if (a.hasOwnProperty(eventName)) {
        a[eventName](a, pt, g, annotation_event);
      } else if (g.getOption(classEventName)) {
        g.getOption(classEventName)(a, pt, g, annotation_event);
      }
    };
  };

  // Add the annotations one-by-one.
  var area = e.dygraph.getArea();

  // x-coord to sum of previous annotation's heights (used for stacking).
  var xToUsedHeight = {};

  for (var i = 0; i < points.length; i++) {
    var p = points[i];
    if (p.canvasx < area.x || p.canvasx > area.x + area.w || p.canvasy < area.y || p.canvasy > area.y + area.h) {
      continue;
    }

    var a = p.annotation;
    var tick_height = 6;
    if (a.hasOwnProperty("tickHeight")) {
      tick_height = a.tickHeight;
    }

    // TODO: deprecate axisLabelFontSize in favor of CSS
    var div = document.createElement("div");
    div.style['fontSize'] = g.getOption('axisLabelFontSize') + "px";
    var className = 'dygraph-annotation';
    if (!a.hasOwnProperty('icon')) {
      // camelCase class names are deprecated.
      className += ' dygraphDefaultAnnotation dygraph-default-annotation';
    }
    if (a.hasOwnProperty('cssClass')) {
      className += " " + a.cssClass;
    }
    div.className = className;

    var width = a.hasOwnProperty('width') ? a.width : 16;
    var height = a.hasOwnProperty('height') ? a.height : 16;
    if (a.hasOwnProperty('icon')) {
      var img = document.createElement("img");
      img.src = a.icon;
      img.width = width;
      img.height = height;
      div.appendChild(img);
    } else if (p.annotation.hasOwnProperty('shortText')) {
      div.appendChild(document.createTextNode(p.annotation.shortText));
    }
    var left = p.canvasx - width / 2;
    div.style.left = left + "px";
    var divTop = 0;
    if (a.attachAtBottom) {
      var y = area.y + area.h - height - tick_height;
      if (xToUsedHeight[left]) {
        y -= xToUsedHeight[left];
      } else {
        xToUsedHeight[left] = 0;
      }
      xToUsedHeight[left] += tick_height + height;
      divTop = y;
    } else {
      divTop = p.canvasy - height - tick_height;
    }
    div.style.top = divTop + "px";
    div.style.width = width + "px";
    div.style.height = height + "px";
    div.title = p.annotation.text;
    div.style.color = g.colorsMap_[p.name];
    div.style.borderColor = g.colorsMap_[p.name];
    a.div = div;

    g.addAndTrackEvent(div, 'click', bindEvt('clickHandler', 'annotationClickHandler', p, this));
    g.addAndTrackEvent(div, 'mouseover', bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));
    g.addAndTrackEvent(div, 'mouseout', bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));
    g.addAndTrackEvent(div, 'dblclick', bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));

    containerDiv.appendChild(div);
    this.annotations_.push(div);

    var ctx = e.drawingContext;
    ctx.save();
    ctx.strokeStyle = a.hasOwnProperty('tickColor') ? a.tickColor : g.colorsMap_[p.name];
    ctx.lineWidth = a.hasOwnProperty('tickWidth') ? a.tickWidth : g.getOption('strokeWidth');
    ctx.beginPath();
    if (!a.attachAtBottom) {
      ctx.moveTo(p.canvasx, p.canvasy);
      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);
    } else {
      var y = divTop + height;
      ctx.moveTo(p.canvasx, y);
      ctx.lineTo(p.canvasx, y + tick_height);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
};

annotations.prototype.destroy = function () {
  this.detachLabels();
};

exports["default"] = annotations;
module.exports = exports["default"];

},{}],21:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/*global Dygraph:false */

'use strict';

/*
Bits of jankiness:
- Direct layout access
- Direct area access
- Should include calculation of ticks, not just the drawing.

Options left to make axis-friendly.
  ('drawAxesAtZero')
  ('xAxisHeight')
*/

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('../dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * Draws the axes. This includes the labels on the x- and y-axes, as well
 * as the tick marks on the axes.
 * It does _not_ draw the grid lines which span the entire chart.
 */
var axes = function axes() {
  this.xlabels_ = [];
  this.ylabels_ = [];
};

axes.prototype.toString = function () {
  return 'Axes Plugin';
};

axes.prototype.activate = function (g) {
  return {
    layout: this.layout,
    clearChart: this.clearChart,
    willDrawChart: this.willDrawChart
  };
};

axes.prototype.layout = function (e) {
  var g = e.dygraph;

  if (g.getOptionForAxis('drawAxis', 'y')) {
    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');
    e.reserveSpaceLeft(w);
  }

  if (g.getOptionForAxis('drawAxis', 'x')) {
    var h;
    // NOTE: I think this is probably broken now, since g.getOption() now
    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always
    // has a value.)
    if (g.getOption('xAxisHeight')) {
      h = g.getOption('xAxisHeight');
    } else {
      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');
    }
    e.reserveSpaceBottom(h);
  }

  if (g.numAxes() == 2) {
    if (g.getOptionForAxis('drawAxis', 'y2')) {
      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');
      e.reserveSpaceRight(w);
    }
  } else if (g.numAxes() > 2) {
    g.error('Only two y-axes are supported at this time. (Trying ' + 'to use ' + g.numAxes() + ')');
  }
};

axes.prototype.detachLabels = function () {
  function removeArray(ary) {
    for (var i = 0; i < ary.length; i++) {
      var el = ary[i];
      if (el.parentNode) el.parentNode.removeChild(el);
    }
  }

  removeArray(this.xlabels_);
  removeArray(this.ylabels_);
  this.xlabels_ = [];
  this.ylabels_ = [];
};

axes.prototype.clearChart = function (e) {
  this.detachLabels();
};

axes.prototype.willDrawChart = function (e) {
  var _this = this;

  var g = e.dygraph;

  if (!g.getOptionForAxis('drawAxis', 'x') && !g.getOptionForAxis('drawAxis', 'y') && !g.getOptionForAxis('drawAxis', 'y2')) {
    return;
  }

  // Round pixels to half-integer boundaries for crisper drawing.
  function halfUp(x) {
    return Math.round(x) + 0.5;
  }
  function halfDown(y) {
    return Math.round(y) - 0.5;
  }

  var context = e.drawingContext;
  var containerDiv = e.canvas.parentNode;
  var canvasWidth = g.width_; // e.canvas.width is affected by pixel ratio.
  var canvasHeight = g.height_;

  var label, x, y, tick, i;

  var makeLabelStyle = function makeLabelStyle(axis) {
    return {
      position: 'absolute',
      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',
      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px'
    };
  };

  var labelStyles = {
    x: makeLabelStyle('x'),
    y: makeLabelStyle('y'),
    y2: makeLabelStyle('y2')
  };

  var makeDiv = function makeDiv(txt, axis, prec_axis) {
    /*
     * This seems to be called with the following three sets of axis/prec_axis:
     * x: undefined
     * y: y1
     * y: y2
     */
    var div = document.createElement('div');
    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];
    utils.update(div.style, labelStyle);
    // TODO: combine outer & inner divs
    var inner_div = document.createElement('div');
    inner_div.className = 'dygraph-axis-label' + ' dygraph-axis-label-' + axis + (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');
    inner_div.innerHTML = txt;
    div.appendChild(inner_div);
    return div;
  };

  // axis lines
  context.save();

  var layout = g.layout_;
  var area = e.dygraph.plotter_.area;

  // Helper for repeated axis-option accesses.
  var makeOptionGetter = function makeOptionGetter(axis) {
    return function (option) {
      return g.getOptionForAxis(option, axis);
    };
  };

  if (g.getOptionForAxis('drawAxis', 'y')) {
    if (layout.yticks && layout.yticks.length > 0) {
      var num_axes = g.numAxes();
      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];
      layout.yticks.forEach(function (tick) {
        if (tick.label === undefined) return; // this tick only has a grid line.
        x = area.x;
        var sgn = 1;
        var prec_axis = 'y1';
        var getAxisOption = getOptions[0];
        if (tick.axis == 1) {
          // right-side y-axis
          x = area.x + area.w;
          sgn = -1;
          prec_axis = 'y2';
          getAxisOption = getOptions[1];
        }
        var fontSize = getAxisOption('axisLabelFontSize');
        y = area.y + tick.pos * area.h;

        /* Tick marks are currently clipped, so don't bother drawing them.
        context.beginPath();
        context.moveTo(halfUp(x), halfDown(y));
        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));
        context.closePath();
        context.stroke();
        */

        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);
        var top = y - fontSize / 2;
        if (top < 0) top = 0;

        if (top + fontSize + 3 > canvasHeight) {
          label.style.bottom = '0';
        } else {
          label.style.top = top + 'px';
        }
        // TODO: replace these with css classes?
        if (tick.axis === 0) {
          label.style.left = area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize') + 'px';
          label.style.textAlign = 'right';
        } else if (tick.axis == 1) {
          label.style.left = area.x + area.w + getAxisOption('axisTickSize') + 'px';
          label.style.textAlign = 'left';
        }
        label.style.width = getAxisOption('axisLabelWidth') + 'px';
        containerDiv.appendChild(label);
        _this.ylabels_.push(label);
      });

      // The lowest tick on the y-axis often overlaps with the leftmost
      // tick on the x-axis. Shift the bottom tick up a little bit to
      // compensate if necessary.
      var bottomTick = this.ylabels_[0];
      // Interested in the y2 axis also?
      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');
      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;
      if (bottom > canvasHeight - fontSize) {
        bottomTick.style.top = parseInt(bottomTick.style.top, 10) - fontSize / 2 + 'px';
      }
    }

    // draw a vertical line on the left to separate the chart from the labels.
    var axisX;
    if (g.getOption('drawAxesAtZero')) {
      var r = g.toPercentXCoord(0);
      if (r > 1 || r < 0 || isNaN(r)) r = 0;
      axisX = halfUp(area.x + r * area.w);
    } else {
      axisX = halfUp(area.x);
    }

    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');
    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');

    context.beginPath();
    context.moveTo(axisX, halfDown(area.y));
    context.lineTo(axisX, halfDown(area.y + area.h));
    context.closePath();
    context.stroke();

    // if there's a secondary y-axis, draw a vertical line for that, too.
    if (g.numAxes() == 2) {
      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');
      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');
      context.beginPath();
      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));
      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));
      context.closePath();
      context.stroke();
    }
  }

  if (g.getOptionForAxis('drawAxis', 'x')) {
    if (layout.xticks) {
      var getAxisOption = makeOptionGetter('x');
      layout.xticks.forEach(function (tick) {
        if (tick.label === undefined) return; // this tick only has a grid line.
        x = area.x + tick.pos * area.w;
        y = area.y + area.h;

        /* Tick marks are currently clipped, so don't bother drawing them.
        context.beginPath();
        context.moveTo(halfUp(x), halfDown(y));
        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));
        context.closePath();
        context.stroke();
        */

        label = makeDiv(tick.label, 'x');
        label.style.textAlign = 'center';
        label.style.top = y + getAxisOption('axisTickSize') + 'px';

        var left = x - getAxisOption('axisLabelWidth') / 2;
        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {
          left = canvasWidth - getAxisOption('axisLabelWidth');
          label.style.textAlign = 'right';
        }
        if (left < 0) {
          left = 0;
          label.style.textAlign = 'left';
        }

        label.style.left = left + 'px';
        label.style.width = getAxisOption('axisLabelWidth') + 'px';
        containerDiv.appendChild(label);
        _this.xlabels_.push(label);
      });
    }

    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');
    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');
    context.beginPath();
    var axisY;
    if (g.getOption('drawAxesAtZero')) {
      var r = g.toPercentYCoord(0, 0);
      if (r > 1 || r < 0) r = 1;
      axisY = halfDown(area.y + r * area.h);
    } else {
      axisY = halfDown(area.y + area.h);
    }
    context.moveTo(halfUp(area.x), axisY);
    context.lineTo(halfUp(area.x + area.w), axisY);
    context.closePath();
    context.stroke();
  }

  context.restore();
};

exports['default'] = axes;
module.exports = exports['default'];

},{"../dygraph-utils":17}],22:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false */

"use strict";

// TODO(danvk): move chart label options out of dygraphs and into the plugin.
// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.

Object.defineProperty(exports, "__esModule", {
  value: true
});
var chart_labels = function chart_labels() {
  this.title_div_ = null;
  this.xlabel_div_ = null;
  this.ylabel_div_ = null;
  this.y2label_div_ = null;
};

chart_labels.prototype.toString = function () {
  return "ChartLabels Plugin";
};

chart_labels.prototype.activate = function (g) {
  return {
    layout: this.layout,
    // clearChart: this.clearChart,
    didDrawChart: this.didDrawChart
  };
};

// QUESTION: should there be a plugin-utils.js?
var createDivInRect = function createDivInRect(r) {
  var div = document.createElement('div');
  div.style.position = 'absolute';
  div.style.left = r.x + 'px';
  div.style.top = r.y + 'px';
  div.style.width = r.w + 'px';
  div.style.height = r.h + 'px';
  return div;
};

// Detach and null out any existing nodes.
chart_labels.prototype.detachLabels_ = function () {
  var els = [this.title_div_, this.xlabel_div_, this.ylabel_div_, this.y2label_div_];
  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    if (!el) continue;
    if (el.parentNode) el.parentNode.removeChild(el);
  }

  this.title_div_ = null;
  this.xlabel_div_ = null;
  this.ylabel_div_ = null;
  this.y2label_div_ = null;
};

var createRotatedDiv = function createRotatedDiv(g, box, axis, classes, html) {
  // TODO(danvk): is this outer div actually necessary?
  var div = document.createElement("div");
  div.style.position = 'absolute';
  if (axis == 1) {
    // NOTE: this is cheating. Should be positioned relative to the box.
    div.style.left = '0px';
  } else {
    div.style.left = box.x + 'px';
  }
  div.style.top = box.y + 'px';
  div.style.width = box.w + 'px';
  div.style.height = box.h + 'px';
  div.style.fontSize = g.getOption('yLabelWidth') - 2 + 'px';

  var inner_div = document.createElement("div");
  inner_div.style.position = 'absolute';
  inner_div.style.width = box.h + 'px';
  inner_div.style.height = box.w + 'px';
  inner_div.style.top = box.h / 2 - box.w / 2 + 'px';
  inner_div.style.left = box.w / 2 - box.h / 2 + 'px';
  // TODO: combine inner_div and class_div.
  inner_div.className = 'dygraph-label-rotate-' + (axis == 1 ? 'right' : 'left');

  var class_div = document.createElement("div");
  class_div.className = classes;
  class_div.innerHTML = html;

  inner_div.appendChild(class_div);
  div.appendChild(inner_div);
  return div;
};

chart_labels.prototype.layout = function (e) {
  this.detachLabels_();

  var g = e.dygraph;
  var div = e.chart_div;
  if (g.getOption('title')) {
    // QUESTION: should this return an absolutely-positioned div instead?
    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));
    this.title_div_ = createDivInRect(title_rect);
    this.title_div_.style.fontSize = g.getOption('titleHeight') - 8 + 'px';

    var class_div = document.createElement("div");
    class_div.className = 'dygraph-label dygraph-title';
    class_div.innerHTML = g.getOption('title');
    this.title_div_.appendChild(class_div);
    div.appendChild(this.title_div_);
  }

  if (g.getOption('xlabel')) {
    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));
    this.xlabel_div_ = createDivInRect(x_rect);
    this.xlabel_div_.style.fontSize = g.getOption('xLabelHeight') - 2 + 'px';

    var class_div = document.createElement("div");
    class_div.className = 'dygraph-label dygraph-xlabel';
    class_div.innerHTML = g.getOption('xlabel');
    this.xlabel_div_.appendChild(class_div);
    div.appendChild(this.xlabel_div_);
  }

  if (g.getOption('ylabel')) {
    // It would make sense to shift the chart here to make room for the y-axis
    // label, but the default yAxisLabelWidth is large enough that this results
    // in overly-padded charts. The y-axis label should fit fine. If it
    // doesn't, the yAxisLabelWidth option can be increased.
    var y_rect = e.reserveSpaceLeft(0);

    this.ylabel_div_ = createRotatedDiv(g, y_rect, 1, // primary (left) y-axis
    'dygraph-label dygraph-ylabel', g.getOption('ylabel'));
    div.appendChild(this.ylabel_div_);
  }

  if (g.getOption('y2label') && g.numAxes() == 2) {
    // same logic applies here as for ylabel.
    var y2_rect = e.reserveSpaceRight(0);
    this.y2label_div_ = createRotatedDiv(g, y2_rect, 2, // secondary (right) y-axis
    'dygraph-label dygraph-y2label', g.getOption('y2label'));
    div.appendChild(this.y2label_div_);
  }
};

chart_labels.prototype.didDrawChart = function (e) {
  var g = e.dygraph;
  if (this.title_div_) {
    this.title_div_.children[0].innerHTML = g.getOption('title');
  }
  if (this.xlabel_div_) {
    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');
  }
  if (this.ylabel_div_) {
    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');
  }
  if (this.y2label_div_) {
    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');
  }
};

chart_labels.prototype.clearChart = function () {};

chart_labels.prototype.destroy = function () {
  this.detachLabels_();
};

exports["default"] = chart_labels;
module.exports = exports["default"];

},{}],23:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false */

/*

Current bits of jankiness:
- Direct layout access
- Direct area access

*/

"use strict";

/**
 * Draws the gridlines, i.e. the gray horizontal & vertical lines running the
 * length of the chart.
 *
 * @constructor
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
var grid = function grid() {};

grid.prototype.toString = function () {
  return "Gridline Plugin";
};

grid.prototype.activate = function (g) {
  return {
    willDrawChart: this.willDrawChart
  };
};

grid.prototype.willDrawChart = function (e) {
  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to
  // half-integers. This prevents them from drawing in two rows/cols.
  var g = e.dygraph;
  var ctx = e.drawingContext;
  var layout = g.layout_;
  var area = e.dygraph.plotter_.area;

  function halfUp(x) {
    return Math.round(x) + 0.5;
  }
  function halfDown(y) {
    return Math.round(y) - 0.5;
  }

  var x, y, i, ticks;
  if (g.getOptionForAxis('drawGrid', 'y')) {
    var axes = ["y", "y2"];
    var strokeStyles = [],
        lineWidths = [],
        drawGrid = [],
        stroking = [],
        strokePattern = [];
    for (var i = 0; i < axes.length; i++) {
      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);
      if (drawGrid[i]) {
        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);
        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);
        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);
        stroking[i] = strokePattern[i] && strokePattern[i].length >= 2;
      }
    }
    ticks = layout.yticks;
    ctx.save();
    // draw grids for the different y axes
    ticks.forEach(function (tick) {
      if (!tick.has_tick) return;
      var axis = tick.axis;
      if (drawGrid[axis]) {
        ctx.save();
        if (stroking[axis]) {
          if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);
        }
        ctx.strokeStyle = strokeStyles[axis];
        ctx.lineWidth = lineWidths[axis];

        x = halfUp(area.x);
        y = halfDown(area.y + tick.pos * area.h);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + area.w, y);
        ctx.stroke();

        ctx.restore();
      }
    });
    ctx.restore();
  }

  // draw grid for x axis
  if (g.getOptionForAxis('drawGrid', 'x')) {
    ticks = layout.xticks;
    ctx.save();
    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');
    var stroking = strokePattern && strokePattern.length >= 2;
    if (stroking) {
      if (ctx.setLineDash) ctx.setLineDash(strokePattern);
    }
    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');
    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');
    ticks.forEach(function (tick) {
      if (!tick.has_tick) return;
      x = halfUp(area.x + tick.pos * area.w);
      y = halfDown(area.y + area.h);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, area.y);
      ctx.closePath();
      ctx.stroke();
    });
    if (stroking) {
      if (ctx.setLineDash) ctx.setLineDash([]);
    }
    ctx.restore();
  }
};

grid.prototype.destroy = function () {};

exports["default"] = grid;
module.exports = exports["default"];

},{}],24:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false */

/*
Current bits of jankiness:
- Uses two private APIs:
    1. Dygraph.optionsViewForAxis_
    2. dygraph.plotter_.area
- Registers for a "predraw" event, which should be renamed.
- I call calculateEmWidthInDiv more often than needed.
*/

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphUtils = require('../dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * Creates the legend, which appears when the user hovers over the chart.
 * The legend can be either a user-specified or generated div.
 *
 * @constructor
 */
var Legend = function Legend() {
  this.legend_div_ = null;
  this.is_generated_div_ = false; // do we own this div, or was it user-specified?
};

Legend.prototype.toString = function () {
  return "Legend Plugin";
};

/**
 * This is called during the dygraph constructor, after options have been set
 * but before the data is available.
 *
 * Proper tasks to do here include:
 * - Reading your own options
 * - DOM manipulation
 * - Registering event listeners
 *
 * @param {Dygraph} g Graph instance.
 * @return {object.<string, function(ev)>} Mapping of event names to callbacks.
 */
Legend.prototype.activate = function (g) {
  var div;

  var userLabelsDiv = g.getOption('labelsDiv');
  if (userLabelsDiv && null !== userLabelsDiv) {
    if (typeof userLabelsDiv == "string" || userLabelsDiv instanceof String) {
      div = document.getElementById(userLabelsDiv);
    } else {
      div = userLabelsDiv;
    }
  } else {
    div = document.createElement("div");
    div.className = "dygraph-legend";
    // TODO(danvk): come up with a cleaner way to expose this.
    g.graphDiv.appendChild(div);
    this.is_generated_div_ = true;
  }

  this.legend_div_ = div;
  this.one_em_width_ = 10; // just a guess, will be updated.

  return {
    select: this.select,
    deselect: this.deselect,
    // TODO(danvk): rethink the name "predraw" before we commit to it in any API.
    predraw: this.predraw,
    didDrawChart: this.didDrawChart
  };
};

// Needed for dashed lines.
var calculateEmWidthInDiv = function calculateEmWidthInDiv(div) {
  var sizeSpan = document.createElement('span');
  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');
  div.appendChild(sizeSpan);
  var oneEmWidth = sizeSpan.offsetWidth;
  div.removeChild(sizeSpan);
  return oneEmWidth;
};

var escapeHTML = function escapeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
};

Legend.prototype.select = function (e) {
  var xValue = e.selectedX;
  var points = e.selectedPoints;
  var row = e.selectedRow;

  var legendMode = e.dygraph.getOption('legend');
  if (legendMode === 'never') {
    this.legend_div_.style.display = 'none';
    return;
  }

  if (legendMode === 'follow') {
    // create floating legend div
    var area = e.dygraph.plotter_.area;
    var labelsDivWidth = this.legend_div_.offsetWidth;
    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');
    // determine floating [left, top] coordinates of the legend div
    // within the plotter_ area
    // offset 50 px to the right and down from the first selection point
    // 50 px is guess based on mouse cursor size
    var leftLegend = points[0].x * area.w + 50;
    var topLegend = points[0].y * area.h - 50;

    // if legend floats to end of the chart area, it flips to the other
    // side of the selection point
    if (leftLegend + labelsDivWidth + 1 > area.w) {
      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);
    }

    e.dygraph.graphDiv.appendChild(this.legend_div_);
    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + "px";
    this.legend_div_.style.top = topLegend + "px";
  }

  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);
  this.legend_div_.innerHTML = html;
  this.legend_div_.style.display = '';
};

Legend.prototype.deselect = function (e) {
  var legendMode = e.dygraph.getOption('legend');
  if (legendMode !== 'always') {
    this.legend_div_.style.display = "none";
  }

  // Have to do this every time, since styles might have changed.
  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);
  this.one_em_width_ = oneEmWidth;

  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);
  this.legend_div_.innerHTML = html;
};

Legend.prototype.didDrawChart = function (e) {
  this.deselect(e);
};

// Right edge should be flush with the right edge of the charting area (which
// may not be the same as the right edge of the div, if we have two y-axes.
// TODO(danvk): is any of this really necessary? Could just set "right" in "activate".
/**
 * Position the labels div so that:
 * - its right edge is flush with the right edge of the charting area
 * - its top edge is flush with the top edge of the charting area
 * @private
 */
Legend.prototype.predraw = function (e) {
  // Don't touch a user-specified labelsDiv.
  if (!this.is_generated_div_) return;

  // TODO(danvk): only use real APIs for this.
  e.dygraph.graphDiv.appendChild(this.legend_div_);
  var area = e.dygraph.getArea();
  var labelsDivWidth = this.legend_div_.offsetWidth;
  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + "px";
  this.legend_div_.style.top = area.y + "px";
};

/**
 * Called when dygraph.destroy() is called.
 * You should null out any references and detach any DOM elements.
 */
Legend.prototype.destroy = function () {
  this.legend_div_ = null;
};

/**
 * Generates HTML for the legend which is displayed when hovering over the
 * chart. If no selected points are specified, a default legend is returned
 * (this may just be the empty string).
 * @param {number} x The x-value of the selected points.
 * @param {Object} sel_points List of selected points for the given
 *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.
 * @param {number} oneEmWidth The pixel width for 1em in the legend. Only
 *   relevant when displaying a legend with no selection (i.e. {legend:
 *   'always'}) and with dashed lines.
 * @param {number} row The selected row index.
 * @private
 */
Legend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {
  // Data about the selection to pass to legendFormatter
  var data = {
    dygraph: g,
    x: x,
    series: []
  };

  var labelToSeries = {};
  var labels = g.getLabels();
  if (labels) {
    for (var i = 1; i < labels.length; i++) {
      var series = g.getPropertiesForSeries(labels[i]);
      var strokePattern = g.getOption('strokePattern', labels[i]);
      var seriesData = {
        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),
        label: labels[i],
        labelHTML: escapeHTML(labels[i]),
        isVisible: series.visible,
        color: series.color
      };

      data.series.push(seriesData);
      labelToSeries[labels[i]] = seriesData;
    }
  }

  if (typeof x !== 'undefined') {
    var xOptView = g.optionsViewForAxis_('x');
    var xvf = xOptView('valueFormatter');
    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);

    var yOptViews = [];
    var num_axes = g.numAxes();
    for (var i = 0; i < num_axes; i++) {
      // TODO(danvk): remove this use of a private API
      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));
    }

    var showZeros = g.getOption('labelsShowZeroValues');
    var highlightSeries = g.getHighlightSeries();
    for (i = 0; i < sel_points.length; i++) {
      var pt = sel_points[i];
      var seriesData = labelToSeries[pt.name];
      seriesData.y = pt.yval;

      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {
        seriesData.isVisible = false;
        continue;
      }

      var series = g.getPropertiesForSeries(pt.name);
      var yOptView = yOptViews[series.axis - 1];
      var fmtFunc = yOptView('valueFormatter');
      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));

      utils.update(seriesData, { yHTML: yHTML });

      if (pt.name == highlightSeries) {
        seriesData.isHighlighted = true;
      }
    }
  }

  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;
  return formatter.call(g, data);
};

Legend.defaultFormatter = function (data) {
  var g = data.dygraph;

  // TODO(danvk): deprecate this option in place of {legend: 'never'}
  // XXX should this logic be in the formatter?
  if (g.getOption('showLabelsOnHighlight') !== true) return '';

  var sepLines = g.getOption('labelsSeparateLines');
  var html;

  if (typeof data.x === 'undefined') {
    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.
    if (g.getOption('legend') != 'always') {
      return '';
    }

    html = '';
    for (var i = 0; i < data.series.length; i++) {
      var series = data.series[i];
      if (!series.isVisible) continue;

      if (html !== '') html += sepLines ? '<br/>' : ' ';
      html += "<span style='font-weight: bold; color: " + series.color + ";'>" + series.dashHTML + " " + series.labelHTML + "</span>";
    }
    return html;
  }

  html = data.xHTML + ':';
  for (var i = 0; i < data.series.length; i++) {
    var series = data.series[i];
    if (!series.isVisible) continue;
    if (sepLines) html += '<br>';
    var cls = series.isHighlighted ? ' class="highlight"' : '';
    html += "<span" + cls + "> <b><span style='color: " + series.color + ";'>" + series.labelHTML + "</span></b>:&#160;" + series.yHTML + "</span>";
  }
  return html;
};

/**
 * Generates html for the "dash" displayed on the legend when using "legend: always".
 * In particular, this works for dashed lines with any stroke pattern. It will
 * try to scale the pattern to fit in 1em width. Or if small enough repeat the
 * pattern for 1em width.
 *
 * @param strokePattern The pattern
 * @param color The color of the series.
 * @param oneEmWidth The width in pixels of 1em in the legend.
 * @private
 */
// TODO(danvk): cache the results of this
function generateLegendDashHTML(strokePattern, color, oneEmWidth) {
  // Easy, common case: a solid line
  if (!strokePattern || strokePattern.length <= 1) {
    return "<div class=\\"dygraph-legend-line\\" style=\\"border-bottom-color: " + color + ";\\"></div>";
  }

  var i, j, paddingLeft, marginRight;
  var strokePixelLength = 0,
      segmentLoop = 0;
  var normalizedPattern = [];
  var loop;

  // Compute the length of the pixels including the first segment twice,
  // since we repeat it.
  for (i = 0; i <= strokePattern.length; i++) {
    strokePixelLength += strokePattern[i % strokePattern.length];
  }

  // See if we can loop the pattern by itself at least twice.
  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));
  if (loop > 1) {
    // This pattern fits at least two times, no scaling just convert to em;
    for (i = 0; i < strokePattern.length; i++) {
      normalizedPattern[i] = strokePattern[i] / oneEmWidth;
    }
    // Since we are repeating the pattern, we don't worry about repeating the
    // first segment in one draw.
    segmentLoop = normalizedPattern.length;
  } else {
    // If the pattern doesn't fit in the legend we scale it to fit.
    loop = 1;
    for (i = 0; i < strokePattern.length; i++) {
      normalizedPattern[i] = strokePattern[i] / strokePixelLength;
    }
    // For the scaled patterns we do redraw the first segment.
    segmentLoop = normalizedPattern.length + 1;
  }

  // Now make the pattern.
  var dash = "";
  for (j = 0; j < loop; j++) {
    for (i = 0; i < segmentLoop; i += 2) {
      // The padding is the drawn segment.
      paddingLeft = normalizedPattern[i % normalizedPattern.length];
      if (i < strokePattern.length) {
        // The margin is the space segment.
        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];
      } else {
        // The repeated first segment has no right margin.
        marginRight = 0;
      }
      dash += "<div class=\\"dygraph-legend-dash\\" style=\\"margin-right: " + marginRight + "em; padding-left: " + paddingLeft + "em;\\"></div>";
    }
  }
  return dash;
};

exports["default"] = Legend;
module.exports = exports["default"];

},{"../dygraph-utils":17}],25:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false,TouchEvent:false */

/**
 * @fileoverview This file contains the RangeSelector plugin used to provide
 * a timeline range selector widget for dygraphs.
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('../dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

var _dygraphInteractionModel = require('../dygraph-interaction-model');

var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

var _iframeTarp = require('../iframe-tarp');

var _iframeTarp2 = _interopRequireDefault(_iframeTarp);

var rangeSelector = function rangeSelector() {
  this.hasTouchInterface_ = typeof TouchEvent != 'undefined';
  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);
  this.interfaceCreated_ = false;
};

rangeSelector.prototype.toString = function () {
  return "RangeSelector Plugin";
};

rangeSelector.prototype.activate = function (dygraph) {
  this.dygraph_ = dygraph;
  if (this.getOption_('showRangeSelector')) {
    this.createInterface_();
  }
  return {
    layout: this.reserveSpace_,
    predraw: this.renderStaticLayer_,
    didDrawChart: this.renderInteractiveLayer_
  };
};

rangeSelector.prototype.destroy = function () {
  this.bgcanvas_ = null;
  this.fgcanvas_ = null;
  this.leftZoomHandle_ = null;
  this.rightZoomHandle_ = null;
};

//------------------------------------------------------------------
// Private methods
//------------------------------------------------------------------

rangeSelector.prototype.getOption_ = function (name, opt_series) {
  return this.dygraph_.getOption(name, opt_series);
};

rangeSelector.prototype.setDefaultOption_ = function (name, value) {
  this.dygraph_.attrs_[name] = value;
};

/**
 * @private
 * Creates the range selector elements and adds them to the graph.
 */
rangeSelector.prototype.createInterface_ = function () {
  this.createCanvases_();
  this.createZoomHandles_();
  this.initInteraction_();

  // Range selector and animatedZooms have a bad interaction. See issue 359.
  if (this.getOption_('animatedZooms')) {
    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');
    this.dygraph_.updateOptions({ animatedZooms: false }, true);
  }

  this.interfaceCreated_ = true;
  this.addToGraph_();
};

/**
 * @private
 * Adds the range selector to the graph.
 */
rangeSelector.prototype.addToGraph_ = function () {
  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;
  graphDiv.appendChild(this.bgcanvas_);
  graphDiv.appendChild(this.fgcanvas_);
  graphDiv.appendChild(this.leftZoomHandle_);
  graphDiv.appendChild(this.rightZoomHandle_);
};

/**
 * @private
 * Removes the range selector from the graph.
 */
rangeSelector.prototype.removeFromGraph_ = function () {
  var graphDiv = this.graphDiv_;
  graphDiv.removeChild(this.bgcanvas_);
  graphDiv.removeChild(this.fgcanvas_);
  graphDiv.removeChild(this.leftZoomHandle_);
  graphDiv.removeChild(this.rightZoomHandle_);
  this.graphDiv_ = null;
};

/**
 * @private
 * Called by Layout to allow range selector to reserve its space.
 */
rangeSelector.prototype.reserveSpace_ = function (e) {
  if (this.getOption_('showRangeSelector')) {
    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);
  }
};

/**
 * @private
 * Renders the static portion of the range selector at the predraw stage.
 */
rangeSelector.prototype.renderStaticLayer_ = function () {
  if (!this.updateVisibility_()) {
    return;
  }
  this.resize_();
  this.drawStaticLayer_();
};

/**
 * @private
 * Renders the interactive portion of the range selector after the chart has been drawn.
 */
rangeSelector.prototype.renderInteractiveLayer_ = function () {
  if (!this.updateVisibility_() || this.isChangingRange_) {
    return;
  }
  this.placeZoomHandles_();
  this.drawInteractiveLayer_();
};

/**
 * @private
 * Check to see if the range selector is enabled/disabled and update visibility accordingly.
 */
rangeSelector.prototype.updateVisibility_ = function () {
  var enabled = this.getOption_('showRangeSelector');
  if (enabled) {
    if (!this.interfaceCreated_) {
      this.createInterface_();
    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {
      this.addToGraph_();
    }
  } else if (this.graphDiv_) {
    this.removeFromGraph_();
    var dygraph = this.dygraph_;
    setTimeout(function () {
      dygraph.width_ = 0;dygraph.resize();
    }, 1);
  }
  return enabled;
};

/**
 * @private
 * Resizes the range selector.
 */
rangeSelector.prototype.resize_ = function () {
  function setElementRect(canvas, context, rect, pixelRatioOption) {
    var canvasScale = pixelRatioOption || utils.getContextPixelRatio(context);

    canvas.style.top = rect.y + 'px';
    canvas.style.left = rect.x + 'px';
    canvas.width = rect.w * canvasScale;
    canvas.height = rect.h * canvasScale;
    canvas.style.width = rect.w + 'px';
    canvas.style.height = rect.h + 'px';

    if (canvasScale != 1) {
      context.scale(canvasScale, canvasScale);
    }
  }

  var plotArea = this.dygraph_.layout_.getPlotArea();

  var xAxisLabelHeight = 0;
  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {
    xAxisLabelHeight = this.getOption_('xAxisHeight') || this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize');
  }
  this.canvasRect_ = {
    x: plotArea.x,
    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,
    w: plotArea.w,
    h: this.getOption_('rangeSelectorHeight')
  };

  var pixelRatioOption = this.dygraph_.getNumericOption('pixelRatio');
  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_, pixelRatioOption);
  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_, pixelRatioOption);
};

/**
 * @private
 * Creates the background and foreground canvases.
 */
rangeSelector.prototype.createCanvases_ = function () {
  this.bgcanvas_ = utils.createCanvas();
  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';
  this.bgcanvas_.style.position = 'absolute';
  this.bgcanvas_.style.zIndex = 9;
  this.bgcanvas_ctx_ = utils.getContext(this.bgcanvas_);

  this.fgcanvas_ = utils.createCanvas();
  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';
  this.fgcanvas_.style.position = 'absolute';
  this.fgcanvas_.style.zIndex = 9;
  this.fgcanvas_.style.cursor = 'default';
  this.fgcanvas_ctx_ = utils.getContext(this.fgcanvas_);
};

/**
 * @private
 * Creates the zoom handle elements.
 */
rangeSelector.prototype.createZoomHandles_ = function () {
  var img = new Image();
  img.className = 'dygraph-rangesel-zoomhandle';
  img.style.position = 'absolute';
  img.style.zIndex = 10;
  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.
  img.style.cursor = 'col-resize';
  // TODO: change image to more options
  img.width = 9;
  img.height = 16;
  img.src = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' + 'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' + 'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' + '6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' + 'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';

  if (this.isMobileDevice_) {
    img.width *= 2;
    img.height *= 2;
  }

  this.leftZoomHandle_ = img;
  this.rightZoomHandle_ = img.cloneNode(false);
};

/**
 * @private
 * Sets up the interaction for the range selector.
 */
rangeSelector.prototype.initInteraction_ = function () {
  var self = this;
  var topElem = document;
  var clientXLast = 0;
  var handle = null;
  var isZooming = false;
  var isPanning = false;
  var dynamic = !this.isMobileDevice_;

  // We cover iframes during mouse interactions. See comments in
  // dygraph-utils.js for more info on why this is a good idea.
  var tarp = new _iframeTarp2['default']();

  // functions, defined below.  Defining them this way (rather than with
  // "function foo() {...}" makes JSHint happy.
  var toXDataWindow, onZoomStart, onZoom, onZoomEnd, doZoom, isMouseInPanZone, onPanStart, onPan, onPanEnd, doPan, onCanvasHover;

  // Touch event functions
  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;

  toXDataWindow = function (zoomHandleStatus) {
    var xDataLimits = self.dygraph_.xAxisExtremes();
    var fact = (xDataLimits[1] - xDataLimits[0]) / self.canvasRect_.w;
    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x) * fact;
    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x) * fact;
    return [xDataMin, xDataMax];
  };

  onZoomStart = function (e) {
    utils.cancelEvent(e);
    isZooming = true;
    clientXLast = e.clientX;
    handle = e.target ? e.target : e.srcElement;
    if (e.type === 'mousedown' || e.type === 'dragstart') {
      // These events are removed manually.
      utils.addEvent(topElem, 'mousemove', onZoom);
      utils.addEvent(topElem, 'mouseup', onZoomEnd);
    }
    self.fgcanvas_.style.cursor = 'col-resize';
    tarp.cover();
    return true;
  };

  onZoom = function (e) {
    if (!isZooming) {
      return false;
    }
    utils.cancelEvent(e);

    var delX = e.clientX - clientXLast;
    if (Math.abs(delX) < 4) {
      return true;
    }
    clientXLast = e.clientX;

    // Move handle.
    var zoomHandleStatus = self.getZoomHandleStatus_();
    var newPos;
    if (handle == self.leftZoomHandle_) {
      newPos = zoomHandleStatus.leftHandlePos + delX;
      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);
      newPos = Math.max(newPos, self.canvasRect_.x);
    } else {
      newPos = zoomHandleStatus.rightHandlePos + delX;
      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);
      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);
    }
    var halfHandleWidth = handle.width / 2;
    handle.style.left = newPos - halfHandleWidth + 'px';
    self.drawInteractiveLayer_();

    // Zoom on the fly.
    if (dynamic) {
      doZoom();
    }
    return true;
  };

  onZoomEnd = function (e) {
    if (!isZooming) {
      return false;
    }
    isZooming = false;
    tarp.uncover();
    utils.removeEvent(topElem, 'mousemove', onZoom);
    utils.removeEvent(topElem, 'mouseup', onZoomEnd);
    self.fgcanvas_.style.cursor = 'default';

    // If on a slower device, zoom now.
    if (!dynamic) {
      doZoom();
    }
    return true;
  };

  doZoom = function () {
    try {
      var zoomHandleStatus = self.getZoomHandleStatus_();
      self.isChangingRange_ = true;
      if (!zoomHandleStatus.isZoomed) {
        self.dygraph_.resetZoom();
      } else {
        var xDataWindow = toXDataWindow(zoomHandleStatus);
        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);
      }
    } finally {
      self.isChangingRange_ = false;
    }
  };

  isMouseInPanZone = function (e) {
    var rect = self.leftZoomHandle_.getBoundingClientRect();
    var leftHandleClientX = rect.left + rect.width / 2;
    rect = self.rightZoomHandle_.getBoundingClientRect();
    var rightHandleClientX = rect.left + rect.width / 2;
    return e.clientX > leftHandleClientX && e.clientX < rightHandleClientX;
  };

  onPanStart = function (e) {
    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {
      utils.cancelEvent(e);
      isPanning = true;
      clientXLast = e.clientX;
      if (e.type === 'mousedown') {
        // These events are removed manually.
        utils.addEvent(topElem, 'mousemove', onPan);
        utils.addEvent(topElem, 'mouseup', onPanEnd);
      }
      return true;
    }
    return false;
  };

  onPan = function (e) {
    if (!isPanning) {
      return false;
    }
    utils.cancelEvent(e);

    var delX = e.clientX - clientXLast;
    if (Math.abs(delX) < 4) {
      return true;
    }
    clientXLast = e.clientX;

    // Move range view
    var zoomHandleStatus = self.getZoomHandleStatus_();
    var leftHandlePos = zoomHandleStatus.leftHandlePos;
    var rightHandlePos = zoomHandleStatus.rightHandlePos;
    var rangeSize = rightHandlePos - leftHandlePos;
    if (leftHandlePos + delX <= self.canvasRect_.x) {
      leftHandlePos = self.canvasRect_.x;
      rightHandlePos = leftHandlePos + rangeSize;
    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {
      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;
      leftHandlePos = rightHandlePos - rangeSize;
    } else {
      leftHandlePos += delX;
      rightHandlePos += delX;
    }
    var halfHandleWidth = self.leftZoomHandle_.width / 2;
    self.leftZoomHandle_.style.left = leftHandlePos - halfHandleWidth + 'px';
    self.rightZoomHandle_.style.left = rightHandlePos - halfHandleWidth + 'px';
    self.drawInteractiveLayer_();

    // Do pan on the fly.
    if (dynamic) {
      doPan();
    }
    return true;
  };

  onPanEnd = function (e) {
    if (!isPanning) {
      return false;
    }
    isPanning = false;
    utils.removeEvent(topElem, 'mousemove', onPan);
    utils.removeEvent(topElem, 'mouseup', onPanEnd);
    // If on a slower device, do pan now.
    if (!dynamic) {
      doPan();
    }
    return true;
  };

  doPan = function () {
    try {
      self.isChangingRange_ = true;
      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());
      self.dygraph_.drawGraph_(false);
    } finally {
      self.isChangingRange_ = false;
    }
  };

  onCanvasHover = function (e) {
    if (isZooming || isPanning) {
      return;
    }
    var cursor = isMouseInPanZone(e) ? 'move' : 'default';
    if (cursor != self.fgcanvas_.style.cursor) {
      self.fgcanvas_.style.cursor = cursor;
    }
  };

  onZoomHandleTouchEvent = function (e) {
    if (e.type == 'touchstart' && e.targetTouches.length == 1) {
      if (onZoomStart(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {
      if (onZoom(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else {
      onZoomEnd(e);
    }
  };

  onCanvasTouchEvent = function (e) {
    if (e.type == 'touchstart' && e.targetTouches.length == 1) {
      if (onPanStart(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {
      if (onPan(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else {
      onPanEnd(e);
    }
  };

  addTouchEvents = function (elem, fn) {
    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];
    for (var i = 0; i < types.length; i++) {
      self.dygraph_.addAndTrackEvent(elem, types[i], fn);
    }
  };

  this.setDefaultOption_('interactionModel', _dygraphInteractionModel2['default'].dragIsPanInteractionModel);
  this.setDefaultOption_('panEdgeFraction', 0.0001);

  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';
  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);
  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);

  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);
  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);

  // Touch events
  if (this.hasTouchInterface_) {
    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);
    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);
    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);
  }
};

/**
 * @private
 * Draws the static layer in the background canvas.
 */
rangeSelector.prototype.drawStaticLayer_ = function () {
  var ctx = this.bgcanvas_ctx_;
  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);
  try {
    this.drawMiniPlot_();
  } catch (ex) {
    console.warn(ex);
  }

  var margin = 0.5;
  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');
  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');
  ctx.beginPath();
  ctx.moveTo(margin, margin);
  ctx.lineTo(margin, this.canvasRect_.h - margin);
  ctx.lineTo(this.canvasRect_.w - margin, this.canvasRect_.h - margin);
  ctx.lineTo(this.canvasRect_.w - margin, margin);
  ctx.stroke();
};

/**
 * @private
 * Draws the mini plot in the background canvas.
 */
rangeSelector.prototype.drawMiniPlot_ = function () {
  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');
  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');
  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');
  if (!fillStyle && !strokeStyle) {
    return;
  }

  var stepPlot = this.getOption_('stepPlot');

  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();
  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;

  // Draw the mini plot.
  var ctx = this.bgcanvas_ctx_;
  var margin = 0.5;

  var xExtremes = this.dygraph_.xAxisExtremes();
  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);
  var xFact = (this.canvasRect_.w - margin) / xRange;
  var yFact = (this.canvasRect_.h - margin) / yRange;
  var canvasWidth = this.canvasRect_.w - margin;
  var canvasHeight = this.canvasRect_.h - margin;

  var prevX = null,
      prevY = null;

  ctx.beginPath();
  ctx.moveTo(margin, canvasHeight);
  for (var i = 0; i < combinedSeriesData.data.length; i++) {
    var dataPoint = combinedSeriesData.data[i];
    var x = dataPoint[0] !== null ? (dataPoint[0] - xExtremes[0]) * xFact : NaN;
    var y = dataPoint[1] !== null ? canvasHeight - (dataPoint[1] - combinedSeriesData.yMin) * yFact : NaN;

    // Skip points that don't change the x-value. Overly fine-grained points
    // can cause major slowdowns with the ctx.fill() call below.
    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {
      continue;
    }

    if (isFinite(x) && isFinite(y)) {
      if (prevX === null) {
        ctx.lineTo(x, canvasHeight);
      } else if (stepPlot) {
        ctx.lineTo(x, prevY);
      }
      ctx.lineTo(x, y);
      prevX = x;
      prevY = y;
    } else {
      if (prevX !== null) {
        if (stepPlot) {
          ctx.lineTo(x, prevY);
          ctx.lineTo(x, canvasHeight);
        } else {
          ctx.lineTo(prevX, canvasHeight);
        }
      }
      prevX = prevY = null;
    }
  }
  ctx.lineTo(canvasWidth, canvasHeight);
  ctx.closePath();

  if (fillStyle) {
    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);
    if (fillGradientStyle) {
      lingrad.addColorStop(0, fillGradientStyle);
    }
    lingrad.addColorStop(1, fillStyle);
    this.bgcanvas_ctx_.fillStyle = lingrad;
    ctx.fill();
  }

  if (strokeStyle) {
    this.bgcanvas_ctx_.strokeStyle = strokeStyle;
    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');
    ctx.stroke();
  }
};

/**
 * @private
 * Computes and returns the combined series data along with min/max for the mini plot.
 * The combined series consists of averaged values for all series.
 * When series have error bars, the error bars are ignored.
 * @return {Object} An object containing combined series array, ymin, ymax.
 */
rangeSelector.prototype.computeCombinedSeriesAndLimits_ = function () {
  var g = this.dygraph_;
  var logscale = this.getOption_('logscale');
  var i;

  // Select series to combine. By default, all series are combined.
  var numColumns = g.numColumns();
  var labels = g.getLabels();
  var includeSeries = new Array(numColumns);
  var anySet = false;
  var visibility = g.visibility();
  var inclusion = [];

  for (i = 1; i < numColumns; i++) {
    var include = this.getOption_('showInRangeSelector', labels[i]);
    inclusion.push(include);
    if (include !== null) anySet = true; // it's set explicitly for this series
  }

  if (anySet) {
    for (i = 1; i < numColumns; i++) {
      includeSeries[i] = inclusion[i - 1];
    }
  } else {
    for (i = 1; i < numColumns; i++) {
      includeSeries[i] = visibility[i - 1];
    }
  }

  // Create a combined series (average of selected series values).
  // TODO(danvk): short-circuit if there's only one series.
  var rolledSeries = [];
  var dataHandler = g.dataHandler_;
  var options = g.attributes_;
  for (i = 1; i < g.numColumns(); i++) {
    if (!includeSeries[i]) continue;
    var series = dataHandler.extractSeries(g.rawData_, i, options);
    if (g.rollPeriod() > 1) {
      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);
    }

    rolledSeries.push(series);
  }

  var combinedSeries = [];
  for (i = 0; i < rolledSeries[0].length; i++) {
    var sum = 0;
    var count = 0;
    for (var j = 0; j < rolledSeries.length; j++) {
      var y = rolledSeries[j][i][1];
      if (y === null || isNaN(y)) continue;
      count++;
      sum += y;
    }
    combinedSeries.push([rolledSeries[0][i][0], sum / count]);
  }

  // Compute the y range.
  var yMin = Number.MAX_VALUE;
  var yMax = -Number.MAX_VALUE;
  for (i = 0; i < combinedSeries.length; i++) {
    var yVal = combinedSeries[i][1];
    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {
      yMin = Math.min(yMin, yVal);
      yMax = Math.max(yMax, yVal);
    }
  }

  // Convert Y data to log scale if needed.
  // Also, expand the Y range to compress the mini plot a little.
  var extraPercent = 0.25;
  if (logscale) {
    yMax = utils.log10(yMax);
    yMax += yMax * extraPercent;
    yMin = utils.log10(yMin);
    for (i = 0; i < combinedSeries.length; i++) {
      combinedSeries[i][1] = utils.log10(combinedSeries[i][1]);
    }
  } else {
    var yExtra;
    var yRange = yMax - yMin;
    if (yRange <= Number.MIN_VALUE) {
      yExtra = yMax * extraPercent;
    } else {
      yExtra = yRange * extraPercent;
    }
    yMax += yExtra;
    yMin -= yExtra;
  }

  return { data: combinedSeries, yMin: yMin, yMax: yMax };
};

/**
 * @private
 * Places the zoom handles in the proper position based on the current X data window.
 */
rangeSelector.prototype.placeZoomHandles_ = function () {
  var xExtremes = this.dygraph_.xAxisExtremes();
  var xWindowLimits = this.dygraph_.xAxisRange();
  var xRange = xExtremes[1] - xExtremes[0];
  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0]) / xRange);
  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1]) / xRange);
  var leftCoord = this.canvasRect_.x + this.canvasRect_.w * leftPercent;
  var rightCoord = this.canvasRect_.x + this.canvasRect_.w * (1 - rightPercent);
  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height) / 2);
  var halfHandleWidth = this.leftZoomHandle_.width / 2;
  this.leftZoomHandle_.style.left = leftCoord - halfHandleWidth + 'px';
  this.leftZoomHandle_.style.top = handleTop + 'px';
  this.rightZoomHandle_.style.left = rightCoord - halfHandleWidth + 'px';
  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;

  this.leftZoomHandle_.style.visibility = 'visible';
  this.rightZoomHandle_.style.visibility = 'visible';
};

/**
 * @private
 * Draws the interactive layer in the foreground canvas.
 */
rangeSelector.prototype.drawInteractiveLayer_ = function () {
  var ctx = this.fgcanvas_ctx_;
  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);
  var margin = 1;
  var width = this.canvasRect_.w - margin;
  var height = this.canvasRect_.h - margin;
  var zoomHandleStatus = this.getZoomHandleStatus_();

  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');
  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');
  if (!zoomHandleStatus.isZoomed) {
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, height);
    ctx.lineTo(width, height);
    ctx.lineTo(width, margin);
    ctx.stroke();
  } else {
    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);
    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);

    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';
    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);
    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);

    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(leftHandleCanvasPos, margin);
    ctx.lineTo(leftHandleCanvasPos, height);
    ctx.lineTo(rightHandleCanvasPos, height);
    ctx.lineTo(rightHandleCanvasPos, margin);
    ctx.lineTo(width, margin);
    ctx.stroke();
  }
};

/**
 * @private
 * Returns the current zoom handle position information.
 * @return {Object} The zoom handle status.
 */
rangeSelector.prototype.getZoomHandleStatus_ = function () {
  var halfHandleWidth = this.leftZoomHandle_.width / 2;
  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;
  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;
  return {
    leftHandlePos: leftHandlePos,
    rightHandlePos: rightHandlePos,
    isZoomed: leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x + this.canvasRect_.w
  };
};

exports['default'] = rangeSelector;
module.exports = exports['default'];

},{"../dygraph-interaction-model":12,"../dygraph-utils":17,"../iframe-tarp":19}]},{},[18])(18)
});
//# sourceMappingURL=dygraph.js.map




function gpxGraph(divId, url, highlightGpxPoint, clickGpxPoint) {
    function parseGpxFromXml(gpx) {
        var output = [];
        var points = gpx.getElementsByTagName("trkpt");
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            var out = {};
            out.lat = point.getAttribute("lat");
            out.lon = point.getAttribute("lon");
            var eles = point.getElementsByTagName("ele");
            if (eles.length == 1) {
                out.ele = parseFloat(eles[0].textContent);
            }
            var times = point.getElementsByTagName("time");
            if (times.length == 1) {
                out.time = Date.parse(times[0].textContent);
            }
            output.push(out);
        }
        return output;
    }

    function haversineDistance(point1, point2) {
        var lat1 = point1["lat"];
        var lon1 = point1["lon"];
        var lat2 = point2["lat"];
        var lon2 = point2["lon"];
        // https://www.movable-type.co.uk/scripts/latlong.html

        function toRadians(degrees) { return degrees * Math.PI / 180; };
        
        var R = 6371e3; // radius of earth in metres
        var φ1 = toRadians(lat1);
        var φ2 = toRadians(lat2);
        var Δφ = toRadians(lat2-lat1);
        var Δλ = toRadians(lon2-lon1);

        var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        var d = R * c;
        return d;
    }

    function gpxPlot(divId, gpx, highlightGpxPoint) {
        var data = [];
        var totalDistance = 0.0
        for (var i = 0; i < gpx.length; i++) {
            var point = gpx[i];

            if (i == 0) {
                data.push([new Date(point.time), point.ele, null, null]);
            } else  {
                var prevPoint = gpx[i - 1];

                var distance = haversineDistance(prevPoint, point); // m
                totalDistance += distance;

                var diff = point.time - prevPoint.time; // ms
                var speed = (distance / 1000) / (diff / 1000 / 60 / 60); // km/h

                data.push([new Date(point.time), point.ele, speed, totalDistance]);
            }
        }

        function highlightCallback(event, x, points, row, seriesName) {
            if (highlightGpxPoint) highlightGpxPoint(gpx[row]);
        }

        function clickCallback(event, x, points) {
            if (clickGpxPoint) clickGpxPoint(gpx[points[0].idx]);
        }
        
        return new Dygraph(document.getElementById(divId), data,
                           {
                               labels: ["Date", "Elevation", "Speed(km/h)", "Distance(m)"],
                               series: { "Distance(m)": { axis: "y2" } },
                               highlightCallback: highlightCallback,
                               clickCallback: clickCallback
                               // y2label: "Distance(m)",
                               // axes: { y2: { axisLabelWidth: 90 } }
                           });
    }

    let xml = new DOMParser().parseFromString(url, "text/xml");
    let gpx = parseGpxFromXml(xml);
    let plot = gpxPlot(divId, gpx, highlightGpxPoint);
    return function() { return plot.destroy(); };
}
    </script>
  </head>

  
  <body>
    <div id="mapid"></div>
    <div id="info" style="position:absolute;bottom:0px;z-index:9999;width:100%;background-color:white;display:none">
      <a href="#" onclick="document.getElementById('info').style.display='none';">close</a>
      <div id="infoinfo" style="width:100%;"></div>
    </div>
    <script>
      var mymap = L.map('mapid').setView([51.505, -0.09], 13);

      L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',{
      maxZoom: 20,
      subdomains:['mt0','mt1','mt2','mt3']
      }).addTo(mymap);

      global_prev_clicked_layer = null;
      function gpxclick(evt) {
        var gpx = evt.target;

        var info = document.getElementById("info");
        info.style.display = "block";

        var popup = L.popup();
        popup.setContent("<p>" + "name: " + gpx.get_name() + "<br/>"
                               + "start: " + gpx.get_start_time().toString() + "<br/>"
                               + "end: " + gpx.get_end_time().toString() + "<br/>"
                               + "duration: " + gpx.get_duration_string(gpx.get_total_time()) 
                                   + ", " + gpx.get_total_speed().toFixed(2) + " km/h<br/>"
                               + "moving duration: " + gpx.get_duration_string(gpx.get_moving_time()) 
                                   + ", " + gpx.get_moving_speed().toFixed(2) + " km/h<br/>"
                               + "elevation: +" + gpx.get_elevation_gain().toFixed(0)
                                 + ", -" + gpx.get_elevation_loss().toFixed(0)
                                 + ", =" + (gpx.get_elevation_gain() - gpx.get_elevation_loss()).toFixed(0) + "<br/>"
                               + "number of points: " + gpx._info.number_of_points + "<br/>"
                               + "</p>"
                               + "<div id=gpxplotid></div>"
                         + '<a href="#" onclick="mymap.removeLayer(global_prev_clicked_layer);">hide</a>');
        global_prev_clicked_layer = evt.layer; 
        popup.setLatLng(evt.latlng).openOn(mymap);
        global_gpxgraph_cleaner = null;
        var myIcon = L.icon({
          iconUrl: _DEFAULT_MARKER_OPTS.startIconUrl,
          iconSize: [33, 50],
          iconAnchor: [16, 45],
        });
        global_gpxgraph_marker = new L.Marker([0.0, 0.0], {icon: myIcon});
        global_gpxgraph_marker.addTo(mymap);
        if (global_gpxgraph_cleaner != null) global_gpxgraph_cleaner();
        global_gpxgraph_cleaner = gpxGraph("infoinfo", gpx._gpx,
              function(point) {
                global_gpxgraph_marker.setLatLng([point.lat, point.lon]);
              },
              function(point) {
                mymap.panTo([point.lat, point.lon], {animate:true});
              });
      }

      {{{GPXS}}}

      var photos = [
      {{{PHOTOS}}}
      ];

      var photoLayer = L.photo.cluster().on('click', function(evt) {
      var photo = evt.layer.photo;
      var template = "<a href='{url}'><img src='{url}' style='max-width:500px; max-height:500px; width:auto; height:auto' /></a><p>{name}</p>";
      evt.layer.bindPopup(L.Util.template(template, photo), { maxWidth:600}).openPopup();
      });
      photoLayer.add(photos).addTo(mymap);
      mymap.fitBounds(photoLayer.getBounds());
    </script>
  </body>
</html>

"""

# redbean-original-1.4.com https://redbean.dev/
redbeanbinary = """
TVpxRnBEPScKAAAQAPgAAAAAAAAAAQAIQAAAAAAAAAAAAAAASlQAAAAAAAAAAAAAAAAAAAAAAAAA
AAAA8AsAALJA6wDrFJCQ6wZIg+wIMdK9AADrBemwEAAA/A8fhz7gvwBwMcmOwfqO14nM+w4f6AAA
XoHucgC4AAJQUAcx/7kAAvOkDx+H0v/qjiAAAI7ZuQAbuFAAjsAxwDH/86qA+kB0E+gVAAewATHJ
MPa/GALoSABPdfrqICUAAFNStAjNE3IsiM+A5z+A4cDQwdDBhs0eBh8x9o7GvhAVh/elpaWlpaQf
k6uRq5KrWKqSW8NagPKAMcDNE3L368FQUYbN0MnQyQjBMduwAbQCzRNZWHIdjMaDxiCOxv7AOgYc
FXYNsAH+xjo2IBV2AzD2QcNQMcDNE1jrxYn+rITAdAm7BwC0Ds0Q6/LDV794JOjo/1/o5P+/gCTo
3v/zkOv8uQQAvgAErYXAdAtRVpe+niToBQBeWeLuw4n6hdJ0FFJWMcmxAwHKrF4MgO5arO5CSXn6
wwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVaon
CiMnIgpvPSIkKGNvbW1hbmQgLXYgIiQwIikiCmlmIFsgLWQgL0FwcGxpY2F0aW9ucyBdOyB0aGVu
CmRkIGlmPSIkbyIgb2Y9IiRvIiBicz04IHNraXA9IiAgICAgNDI1IiBjb3VudD0iICAgICAgODci
IGNvbnY9bm90cnVuYyAyPi9kZXYvbnVsbAplbGlmIGV4ZWMgNzw+ICIkbyI7IHRoZW4KcHJpbnRm
ICdcMTc3RUxGXDJcMVwxXDAxMVwwXDBcMFwwXDBcMFwwXDBcMlwwXDA3NlwwXDFcMFwwXDBcMDEy
XDAyMVwxMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwzNDBcMDEyXDAwMFwwMDBcMDAwXDAwMFwwMDBc
MDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMFwwXDBcMFwxMDBcMFwwNzBcMFww
MDRcMDAwXDBcMFwwMDBcMDAwXDAwMFwwMDAnID4mNwpleGVjIDc8Ji0KZWxzZQpleGl0IDEyMQpm
aQpleGVjICIkMCIgIiRAIgpSPSQ/CgppZiBbICRSIC1lcSAxMjYgXSAmJiBbICIkKHVuYW1lIC1t
KSIgIT0geDg2XzY0IF07IHRoZW4KaWYgUT0iJChjb21tYW5kIC12IHFlbXUteDg2XzY0KSI7IHRo
ZW4KZXhlYyAiJFEiICIkbyIgIiRAIgplbHNlCmVjaG8gZXJyb3I6IG5lZWQgcWVtdS14ODZfNjQg
PiYyCmZpCmVsaWYgWyAkUiAtZXEgMTI3IF07IHRoZW4KICBleGVjICIkbyIgIiRAIgpmaQpleGl0
ICRSCmVycm9yOiAADQoAY3B1aWQAb2xkc2tvb2wAZTgyMABub2xvbmcADAAAQ2YPH0QAADgAtCQA
AAAAAAAAAAAAAAAAAAAA//8AAACaDwD//wAAAJIPAP//AAAAms8A//8AAACSzwD//wAAAJuvAP//
AAAAk68AArCtGwAAAQD+T1Hk7AQAAAAAEAAAMBQAAAAYAAwFAABqAJ2yQA8gwIPg/g8iwGbqWiAA
AOjlC+g2/OjcC+gAAOgMAOi2AOhpAOgdAeh6AZxY9sSAdUxmnGZYZonBZrsAACAAZjHYZlBmnWac
ZlhmOcF0OWYJ2GZQZp1mvwAAAIBmifhmRw+iZjn4fBtmifgPoma/AAAAIGYh+mY5+nUIMcDDv4kk
6wi/lyTrA7+DJOip+79RAI7HZjH/ZjHbZrgg6AAAZrkYAAAAZrpQQU1TzRVyI2Y50HUehcl0DoP5
FXIG9kUUAXUDg8cYZoXbdAaB/wAQcsjDv5Ik6F/7+h4xwI7ASI7YvwAFvhAFJooFUIoEUCbGBQDG
BP8mgD3/WIgEWCaIBR91QLgBAOgsALCt5mToJQCw0OZk6CUA5GBQ6BgAsNHmZOgRAFgMAuZg6AkA
sK7mZOgCAOuj5GSoAnX6w+RkqAF0+sP7wx64AHmO2GbHBgBQA9AHAGbHBgBYA8AHAGbHBgBAA7AH
AGbHBgAwA6AHAGbHBgAgA5AHAGbHBgAQA5AHALkAAma4AwAAADH2ZokEZgUAEAAAg8YI4vJmuADg
BwAPItgfw/oPAR4iFQ8g4GYNoAIAAA8i4Ga5gAAAwA8yZg0BAQAADzAPARaoJA8gwGYNAwAAgGaD
4PsPIsDq8SYoAGowWI7YjtCOwI7gjui8AAAIAEUx5EUx7UUx9kUx/zHbMe1VSMfHAAUAAA8g3roA
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
VcyLNZiQBgBMiffoNzsAAIP4/3RuviAAAAC/AQAAAOjYPQIASYnFi0W8QYlFAEGJXQSLRbhBiUUI
6DQ6AABJiUUQSWPESI0EQEjB4ANIAwUM8gYAxwACAAAARIl4BEyJcAhMiWgQRIngSIPEKFtBXEFd
QV5BX13DQb8AAAAA6V////9MiffojzoAAESJ5+j1sAIA6BcAAABBicTryUSJ5+jjsAIA6AUAAABB
icTrt1VIieUPH0QAAOjKOQAAicfoaQAAAIkFAvsGAEjHwP////9dw1VIieUPH0QAAEG5APD/f0G4
AAAAAEiD+hC4EAAAAEgPRsJMOcB2LkyJwEjB4ARIjQwGSAH4TIsRTIlQCEiLSQhMOclzDYkIiclJ
KclJg8AB68NEiQhMicBdw1VIieUPH0QAAIH/6gAAAHdNhf8PhO0DAACB/+oAAAAPh+EDAACJ+P8k
xWi2QwCNh7bY//+D+CsPh8kDAACJwP8kxcC9QwCNh1b6//+D+AUPh7EDAACJwP8kxSC/QwCB/68F
AAB3eYH/qgUAAHPYgf/oBAAAD4eMAwAAgf+QBAAAchiNh3D7//+D+FgPh3UDAACJwP8kxVC/QwCB
/+UDAAAPhJIBAAB2F4H/5gMAAA+FUgMAAIsFeYwGAOmcAAAAgf/nAQAAD4RMAQAAgf/jAwAAD4Uv
AwAAiwWOjAYA63yB/3UnAAAPhxsDAACB/0onAAAPgzf///+B/x4nAAAPhLYCAAB2IIH/JicAAA+E
swIAAIH/NCcAAA+F6QIAAIsFuIsGAOs2gf8YBwAAD4RqAQAAgf8dJwAAdQiLBVyLBgDrGoH/+AYA
AA+FuQIAAIsFWIwGAOsGiwXQjAYAXcOLBTiLBgDr9osFMIsGAOvuiwV4jAYA6+aLBXCMBgDr3osF
OIwGAOvWiwVgjAYA686LBQiLBgDrxosFaIwGAOu+iwVQiwYA67aLBdiLBgDrrosFSIsGAOumiwXg
igYA656LBYiMBgDrlosF2IoGAOuOiwUYjAYA64aLBRCMBgDpe////4sFtYoGAOlw////iwWyjAYA
6WX///+LBU+LBgDpWv///4sFRIsGAOlP////iwUhiwYA6UT///+LBY6KBgDpOf///4sFS4sGAOku
////iwV4igYA6SP///+LBSWLBgDpGP///4sFUooGAOkN////iwVXiwYA6QL///+LBZSKBgDp9/7/
/4sFMYoGAOns/v//iwVGiwYA6eH+//+LBUuLBgDp1v7//4sFeIsGAOnL/v//iwVtiwYA6cD+//+L
BWKLBgDptf7//4sFP4sGAOmq/v//iwXkiQYA6Z/+//+LBdmJBgDplP7//4sFlosGAOmJ/v//iwUT
iwYA6X7+//+LBSCLBgDpc/7//4sFrYkGAOlo/v//iwUKiwYA6V3+//+LBf+KBgDpUv7//4sF3IoG
AOlH/v//iwWJiwYA6Tz+//+LBd6JBgDpMf7//4sFm4oGAOkm/v//iwXAiQYA6Rv+//+LBSWKBgDp
EP7//4sFaokGAOkF/v//iwU/iQYA6fr9//+LBayLBgDp7/3//4sFKYkGAOnk/f//iwWGigYA6dn9
//+LBWuJBgDpzv3//4sFcIoGAOnD/f//iwX9iAYA6bj9//+LBfKIBgDprf3//4sF74oGAOmi/f//
iwV0iQYA6Zf9//+LBamJBgDpjP3//4sFLooGAOmB/f//iwXDigYA6Xb9//+LBdCJBgDpa/3//4sF
xYkGAOlg/f//iwUqigYA6VX9//+J+OlO/f//VUiJ5UiDxIAPH0QAAEiNfYC+AAAAALqAAAAA6DYk
AwDHRYAGAAAAiwWh7gYAg/gHfhdImEgFAABAALoAAAAASIn+vwYAAAD/0L+GAAAA6CwpAwBVSInl
Dx9EAABIifhIxwYAAAAAZoM4IHUhSIPAAuv0SIsOSI0MiUiDwAIPt9KD6jBIY9JIjRRKSIkWD7cQ
jUrQZoP5CXbZXcNVSInlQVdBVkFVQVRTSIPsGA8fRAAASYn/SYn2SYnUSYnNuwAAAABMOeNzJ0yJ
4kgp2kmNNB5BuAAAAABIjU3MTIn/uAAAAABB/9WLRcxIAcPr1EiDxBhbQVxBXUFeQV9dw1VIieUP
H0QAALkbcEAA6Iv///9dw1VIieUPH0QAALkTb0AA6Hb///9dw0yNVCQISIPkwEH/cvhVSInlQVdB
VkFVQVRBUlNIgezAAAAADx9EAAC6LAAAAEiNtSD///+/JuFDAOiGOAAAhcAPhNYBAACD+Ct2Cr97
AAAA6Hw3AAC+AAAAAL8m4UMA6HA6AABIjXWISI29IP///+i4/v//SInHSI11gOis/v//ukAAAABI
jXWQSIt9iOhZ////uggAAAC+YBJHAEiLfYjoRv///0G+AAAAAOmPAAAAT41kLQBIizzVcBJHAOh5
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
AAAAAOsNSQHHSDtTCHJASYPEAU055XY3TInjSMHjBEwB80iLUwhIhdJ05EyJ+UiLM0iLfcDoG///
/0iD+P90E0iJwkgBRchJg///dbnrukiLRchIg8QYW0FcQV1BXkFfXcNMifm6AAAAAL4AAAAASIt9
wOjd/v//69m4CmNAAOkMJQAAVUiJ5UFUUw8fRAAASIn7gz8BdCBIi3sI6HsgAABBicSDOwR0KEWF
5HQxuAAAAABbQVxdw0iLfwjoUCIAAIP4AXXSSIt7COj7IAAA68dIi3sQ6EIgAABBIcTryuh1FwMA
681VSInlQVZBVUFUUw8fRAAAQYn0QYnVhf8PiOMAAABIY/9IOz3K1AYAD4PcAAAATI00f0nB5gNM
ifBIAwW61AYAiwCNUP+D+gEPl8KD+AQPlcCEwg+FsQAAAIP+/w+EvgAAAIn36CeEAgCJw4P4/w+E
nQAAAEljxEiNHEBIweMDSInYSAMFcdQGAIM4AA+FoAAAAEgDHWHUBgDHAwgAAABEiePowSAAAEiJ
x0iLBUnUBgBIY9NMjSRSScHkA0qNTCAISot0MAhIg+wIagJBuQEAAABBuAAAAABIifro1x8AAEiD
xBCFwHRXSIsFC9QGAEkBxEKLBDBBiQQkRYlsJATrEOgm1P//icPrB+ib0///icOJ2EiNZeBbQVxB
XUFeXcPoTZMCAInDg/j/D4Vy////699Eiefozn0CAOlT////id/o3JICAOgoFgMAicPrwlVIieVB
VkFVQVRTSIHskAAAAA8fRAAASYn8SYn1SYnWSI29cP///74AAAAAumgAAADopQoDAMeFcP///2gA
AADHRawAAQAASIsFXdMGAEiLUAhIiVXASItQIEiJVchIi0A4SIlF0LsCAAAA6wuJ3+hFfQIASIPD
AUg7HSTTBgBzIkiNBFtIweADSAMFG9MGAIM4AHTfi0AESIUFDHIGAHTT68pIg+wISI2FUP///1BI
jYVw////UGoAagBqAUG5AAAAAEG4AAAAALkAAAAATInyTInuTInn6Hb2//9Ig8Qwg/j/dRK4////
/0iNZeBbQVxBXUFeXcNIi71Y////6OQdAAC+/////0iLvVD////o7SEAAMdF3AMBAABIjXXcSIu9
UP///+haHwAAgX3cAwEAAHTPSIu9UP///+inHQAAi33c6DUeAABVSInlQVRTSIPsUA8fRAAAicuF
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
x1VIieVBV0FWQVVBVFNIg+wI6B2N//9IiftJifVIi0coSIXAdEyLQCglAPAAAD0AQAAAdE9Mi3so
TYX/dH1IiwXrQgYA8Ej/gOgKAABIi0MoSIt4CEyJ7uhFugAASYnETIngSIPECFtBXEFdQV5BX13D
SIt/CEgDPVNCBgDonrYCAOulgz2lpQYAAXcIQbwAAAAA68tBuHNlQwC5AAAAALo1CAAAviVlQwC/
AgAAALgAAAAA6DG+AADr0kiLexBIAz0KQgYA6IC3AgBJicZIg/j/D4TIAAAASI14Aein5wEASYnE
SIXAD4SzAAAASIN7KAAPhLAAAAC4AAAAAIXAD4XXAAAASIs1xEEGAEiLSxBIjVQOGg+2QgHB4AgP
thIJwkiNfA4cD7ZHAcHgCA+2Pwn4AdBImEiNRAEeSAHGTInnTIny6OfQAgBIi0MQSIPADkgDBXhB
BgAPtlADweIYD7ZIAsHhEAnKD7ZIAcHhCAnKD7YACcJMifZMiefoKv3//4TAD4TGAAAAQ8YENABN
he0PhMn+//9NiXUA6cD+//9NifzpuP7//0iLQxBIg8AISAMFGUEGAA+2UAHB4ggPtgAJ0IP4CHQK
uAAAAADpK////7gBAAAA6SH///9Ii3sISAM96UAGAOjptAIASInBSIsV2kAGAEiLQxBIjXwCGg+2
dwHB5ggPtj8J90yNRAIcQQ+2cAHB5ghFD7YARAnGAf5IY/ZIjUQwHkgBwkyJ9kyJ5+g2+v//hMAP
hQr///9MiefoO+YBAE2J/OkR/v//TInn6CvmAQBNifzpAf7//1VIieVBVFNIgezgAAAA6MKK//9J
ifxIibVI////SImVUP///0iJjVj///9MiYVg////TImNaP///4TAdCMPKYVw////DylNgA8pVZAP
KV2gDyllsA8pbcAPKXXQDyl94MeFKP///wgAAADHhSz///8wAAAASI1FEEiJhTD///9IjYVA////
SImFOP////MPb4Uo////DxGFEP///0iJhSD///9Iiz23PgYASIs1uD4GAEgp/kgDPbY+BgBIjY0o
////TIni6IauAgBIY9hIixWNPgYASIsFjj4GAEgp0Eg5w3MTSAEddz4GAEiBxOAAAABbQVxdw0iN
fBMB6Mb3//9Iiz1aPgYASIs1Wz4GAEgp/kgDPVk+BgBIjY0Q////TIni6CmuAgDrulVIieVBVFNI
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
uAAAAADr31VIieVIgezQAAAADx9EAABIibVY////SImVYP///0iJjWj///9MiYVw////TImNeP//
/4TAdCAPKUWADylNkA8pVaAPKV2wDyllwA8pbdAPKXXgDyl98MeFOP///wgAAADHhTz///8wAAAA
SI1FEEiJhUD///9IjYVQ////SImFSP///0iNtTj////oEgIAAMnDVUiJ5Q8fRAAA6JUuAQBIhcB0
Al3D6AAAAABVSInlDx9EAAC4fEJBAEiFwHQF6KEEAADoRRwCAFVIieUPH0QAAOhqLgEASIXAdAJd
w+jJ////VUiJ5UFUUw8fRAAASYn8SInz6E0uAQBIhcB0BVtBXF3DTYXkD5TBSIXbD5XCCNF06+iT
////VUiJ5UiD7DAPH0QAAEiJ0EyJwkjHReAAAAAASMdF8AAAAABIx0X4AAAAAEiJddBIiUXYSIlN
6EiNddDouKMBAMnDVUiJ5UFXQVZBVUFUU0iB7OgAAAAPH0QAAEmJ94s1XIEFALgAAAAA6FycAQBB
icWD+P8PhAcBAABIjbXw/v//icfo+JQBAIP4/w+E6AAAAEiLhSD///9IjXgB6JMtAQBJicZIhcB0
ZkiLlSD///9IgfoAACAAf3NBvAAAAABIi4Ug////TDngD4abAAAAS400JkiLlSD///9MKeJMieFE
ie/oqp4BAEiJw0iD+P91U0hjBfTqBQBIOwW5fQUAdM5MiffoGS0BAEG+AAAAAESJ7+h3iwEATInw
SIHE6AAAAFtBXEFdQV5BX13Diw2WfwUAvgAAAABEie/otpIBAOl1////SIXAdAhJAdzpbv///0iN
tfD+//9Eie/oIJQBAIP4/3Xk6IsaAgBNhf90A0mJB0PGBCYA65ZBvgAAAADrjkG+AAAAAOuOVUiJ
5UiD7BAPH0QAAEiJ8kiJ/kiNffjojC4BAIP4/3QGSItF+MnD6N79//9VSInlQVdBVkFVQVRTSIHs
GAEAAA8fRAAASIm92P7//0iJtdD+//9IiZXI/v//SYnMTYnHTYnNTIt1IITAdCkPKYVQ////DymN
YP///w8plXD///8PKV2ADyllkA8pbaAPKXWwDyl9wIsdyekFAIt1GEiLfRDorQQAALkIAAAAugAA
AABIi7XY/v//SI29AP///+iEAAIASIXAdQlmx4UA////PwBIjb0A////6GcOAgBIuHVua25vd24A
SImF4P7//74gAAAASI294P7//+jtlAEA6GKVAQCJwUFVQVf/tdD+//9BVP+1yP7//0FVTYnhTI2F
AP///0iNleD+//++uK1DAL8CAAAAsADoso0BAEiDxDBNhfZ0aUGAPgB0Y77s40MAvwIAAACwAOiS
jQEAx4UI////MAAAAMeFDP///zAAAABIjUUoSImFEP///0iNhSD///9IiYUY////SI2VCP///0yJ
9r8CAAAA6ByzAQC+D2dDAL8CAAAAsADoQI0BAOiLDgAAhMAPhK4AAABBv4qtQwCDPVctAwABD46m
AAAAQb6PrUMASIs9VHoFAOhFkwEASYnE6FYOAACEwA+EjwAAAEG9kq1DAInf6KPvAQBIicJIg+wI
QVdNifFNieBMiem+mK1DAL8CAAAAsADozowBAEiDxBBBvAEAAACLBe8sAwBIY9BMOeJ3Ukhj20g7
HYV7BQB1IL4PZ0MAvwIAAACwAOiZjAEAvmASRwC/AgAAAOgndwEA6FoAAABBv+3jQwDpTf///0G+
7eNDAOlV////Qb3t40MA6Wz/////yEiYTDngdim5j61DAEiLBYgsAwBKixTgvqmtQwC/AgAAALAA
6DqMAQBJ/8Tpbv///7nt40MA69VVSInlDx9EAACwALIBD7AVkOcFAHUevwAAAADoPJQBAIXAdAHM
vgAAAAC/AgAAAOilCgAAv00AAADoSmsBAFVIieVIgezQAAAADx9EAABMiY14////hMB0IA8pRYAP
KU2QDylVoA8pXbAPKWXADylt0A8pdeAPKX3wx4U4////KAAAAMeFPP///zAAAABIjUUQSImFQP//
/0iNhVD///9IiYVI////TI2NOP///+jvAwAAycNVSInlQVVBVFNIg+wIDx9EAABIiftBifRJidWL
PcvmBQDoA+4BAEiD7AhQTYnpQbjUbkMAuQAAAABEieJIid6/AgAAALAA6D////9Ig8QQSI1l6FtB
XEFdXcNVSInlQVRTDx9EAABEiyV/5gUASIX/dCyAPwB0J0iLNSKaBQDohAQBAEiLDRaaBQC6AgAA
AL4BAAAAvwquQwDoiQYBAEiLHfuZBQBEiefofO0BAEiJx0iJ3uhPBAEASIs14ZkFAL8KAAAA6NcD
AQBbQVxdw1VIieVTSIPsOA8fRAAAxwUKhQUAAwAAAMcFBIUFAAgAAADHBf6EBQAEAAAAxwX4hAUA
CwAAAMcF8oQFAAUAAADHBeyEBQAGAAAASIsF2XsFAIkF44QFAMcF3YQFAA0AAABIx0XAAAAAAEjH
RdAAAAAASMdF2AAAAABIx0XgAAAAAEjHRegAAAAASIsFynsFAEiJRchIjX3Y6OatAQC7AAAAAOsU
izSdIMlGAEiNfdjoNqABAEiDwwFIg/sHdua7AAAAAOsESIPDAUiD+wd3OIs8nSDJRgCF/3TrSI0E
m0iNhEOiSUEASIlFwEiNBFtIweAESInCSIHCoMdGAEiNdcDoJZ0BAOu+SIPEOFtdw1VIieVBVUFU
U0iB7KgBAAAPH0QAAEmJ/UGJ9OjLCgAAhMAPhN0AAAC+Da5DAEiNvUn+///omP8BAEiJw+iqCgAA
hMAPhMYAAAC+Eq5DAEiJ3+h7/wEAxwBlcnJvZsdABHIASI1YBeiACgAAhMAPhKYAAAC+HK5DAEiJ
3+hR/wEAZscAOgBIjXgBTInu6ED/AQBmxwA6AEiNWAFJY/xIid7of90BAEgBw2bHAzoASI17AUiL
NcT1BADoFP8BAEiJw+gmCgAAhMB0Wr6KrUMASInf6Pv+AQBmxwA6IMZAAgBIjVACSI21Sf7//0gp
8r8CAAAA6DyvAQBIgcSoAQAAW0FcQV1dw77t40MA6R7///++7eNDAOk1////vu3jQwDpVf///77t
40MA66RVSInlDx9EAACD5wcPvoclrkMAXcNVSInlQVRTSIHs4AAAAA8fRAAASIn76Dn9AABBicRI
id/ooP4AAInHg/j/D4SVAAAASWPESDsFGncFAHQSSDsFEXYFAHQJSDsFIHYFAHV3SI21EP///+gK
jQEAg/j/dA1Igb1A////ABJ6AH5ZSInf6FH+AACJx74AAAAA6L6NAQC6AAAAAL4AAAAASInf6HUC
AQDHQxQAAAAAx0MQAAAAAEiJ3+jf+wAARInn6F3qAQBIicK+iK5DAEiJ37gAAAAA6CoAAQBIgcTg
AAAAW0FcXcNVSInlQVdBVkFVQVRTSIHsuAAAAA8fRAAAQYn9SIm1WP///4mVVP///0iJy0yJhUj/
//9MiY1A////SIXJD4RjAQAASIXbD4RLAQAA/xUxJwMA2cDdjTj///9Ii5U4////SImVaP///9+t
OP///97p2A0dZwIA3Y04////SIuFOP///0iLDfngBQBIOcoPhB8BAABIiYUw////SIkV4uAFAEiJ
BePgBQBIOcoPhRcBAABIx4Uo////Lq5DAEiLPVAzAwDos9b+/0mJxEQPtjtBg/8BD4QsAQAA6CSO
AQCJhTj///++LgAAAEyJ5+j4/wEASYnGTSnmSIu9MP///+hDDQIASInH6IYQAgBIiYUw////RInv
6P/9//+JwouNOP///1FBVEFWi7VU////VkyLjVj///9Mi4Uw////SIuNKP///75WrkMASInfuAAA
AADoyf4AAEiDxCCFwA+OrAAAAEiLlUD///9Ii7VI////SInf6JUEAQBIid6/CgAAAOgv/wAAQYP/
AQ+EjAAAAEWF7Q+EkwAAAEiNZdhbQVxBXUFeQV9dw0iLHU7gBQDpkf7//0iJxkgrNc/fBQBIibUw
////6dL+//9IjXWQSI29aP///+hLYAAASI1NkLpDrkMAviAAAABIjb1w////6OxpAABIjYVw////
SImFKP///+m3/v//xgMA6cz+//9Iid/oGf3//+lH////xgMBSInf6HX6AADpZP///4u1VP///0iL
vVj////os/v//0i4dW5rbm93bgBIiYVw////viAAAABIjb1w////6CqMAQDon4wBAInBSI2VcP//
/75wrkMAvwIAAAC4AAAAAOgKhQEA6Nr4//9VSInl6BcNAABdw1VIieXoDA0AAF3DVUiJ5egBDQAA
XcNVSInl6PYMAABdw1VIieXo6wwAAF3DVUiJ5ejgDAAAXcNVSInl6NUMAABdw1VIieXoygwAAF3D
VUiJ5UFXQVZBVUFUU0iB7MgNAAAPH0QAAIm9JPL//0mJ9IsFFjEDAKgQD4XdAgAAqAQPhdwCAADo
SWUBAEiJw0iFwHRS6P4NAABIiYUY8v//SIXAdEFIx4Uw8v//tK5DAEjHhTjy//++rkMASMeFQPL/
/8GuQwBIiZ1I8v//uGgpRwBJicdIhcAPhKAAAABIixjpnQAAALj/////6S8CAABMjXEBSI2FMPb/
/0gB0EiJhM0w8v//xoQVMPb//zBMjWoCxoQVMfb//3hIg+8BSI2FMPb//0qNNCjoftgBAEmNVAUB
TYskJEyJ8U2F5EAPlcZIg/l+D5bAQITGdEJJi3wkCLiUVUMASDnHdZRIg+sBSInYSMHgBUkDRxBI
i3gYuJRVQwBIOcd04+ly////uwAAAAC6AAAAALkEAAAA66tIx4TNMPL//wAAAABIjX2w6M6ZAQCL
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
AwAASInDSIXAD4SZAQAATYX/dA5Ii0AYZkHBxAhmRIlgAk2F9nQOQYtGCIlDCEGLRgyJQwxNhe0P
hLwAAABIi0MYSI1QBEyJ7r8CAAAA6CASAACD+AEPhMoAAABNhfZ0CkH2BgQPhckAAABMi2MY6EgB
AABIicdMjU3IQbgIAAAATInhTInqvgIAAADopAgAAIXAD46qAAAATItDIEiLdchIiffov/sBAEg9
/QAAALr9AAAASA9HwkiNUAFMicfoHPgBAEiLRbhIiRi4AAAAAEiDxChbQVxBXUFeQV9dw7gAAAAA
6QX///9B9gYCD4QE////uP/////r1k2F9nQZQfYGAXUaugEAAH9Ii0MYiVAEuAAAAADruLoBAAB/
6+u6AAAAAOvkSItFuEiJGLgAAAAA65xIid/oiv3//7j+////641Mi2MY6EEBAABIicdBuAgAAABM
ieFMieq+AgAAAOggBQAAQYnEhcB+EUiLRbhIiRi4AAAAAOlT////SInf6EH9//9FheR1KLj+////
6Tz///+4/v///+ky////uP7////pKP///7j2////6R7///+49f///+kU////VUiJ5VNIgewIAQAA
Dx9EAABIgz07bAUAAHQRSIsFMmwFAEiBxAgBAABbXcNIxwUdbAUAYMpGAGoIWEiJBUtrBQBIxwVI
awUAkMpGAGpAWEiJBU5rBQBIxwVLawUA8MpGALoAAAAAvjDLRgC/Q2pBAOgxTQEA9gXgGwMABHUz
v/u0QwC+Y+xDAOjE5gAASInDSIXAdA9IicZIiz21awUA6CgBAABIid/obeMAAOlq////vvgAAABI
jb3w/v//6OXC/v9IicdIhcB1ub/7tEMA67JVSInlU0iD7AgPH0QAAEiDPcVrBQAAdA5IiwW8awUA
SIPECFtdw0jHBaprBQBAy0YAagOPBWJrBQBIxwVfawUAWMtGALoAAAAAvojLRgC/gGpBAOh9TAEA
9gUsGwMABHUwvmPsQwC/BrVDAOgQ5gAASInDSIXAdA9IicZIiz1ZawUA6CICAABIid/oueIAAOuH
SIs9Q2sFAOidwv7/6Xb///9VSInlU0iD7AgPH0QAAIn7vj4BAAC/AQAAAOjeCwEASIXAdC7HQAQC
AAAAx0AQEAAAAEiNUDBIiVAYZsdAMAIAid9mwccIZol4MkiNUEBIiVAgSIPECFtdw1VIieVBV0FW
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
icBIjTQSSAHyQQ+2tJAQw0MAi1WMOfIPjrMAAAAp8olVjIPAAYlFkIP4C39ri03M9sEDdcNIY8FI
acAfhetRSMH4JYnKwfofKdBrwGQ5wXUnSGPBSGnAH4XrUUjB+CeJysH6HynQacCQAQAAOcF0GEhj
1+uGDx8AugEAAADpef///2YPH0QAALoBAAAA6Wn///9mDx9EAADHRZAAAAAAuAAAAACDwQFwF4lN
zKgBD4R5////SMfA/////+lXAwAAuAEAAADr4mYPH4QAAAAAALgAAAAAgcGU+P//cE+JTcyD4AEP
hVADAACJTZSLfYCJvTD///+D/zt2T4HBbAcAAIH5sQcAAH84ugAAAACDx8WJ+XAfiY0w////9sIB
D4UfAwAAx0WAOwAAAOsjuAEAAADrqroBAAAA69pmDx9EAADHRYAAAAAA6waJhTD///+7AQAAAOsQ
Zi4PH4QAAAAAAEgB24PAAYP4Pn71SYncSffU628PH0QAAEw54A+OkgAAAEyJZbjpiQAAAGYPH0QA
AEiDfbgAfhG4AQAAAOmgAAAADx+AAAAAALj/////6Y8AAABmDx9EAABIg8IBSIlVuEg52g+OhwIA
AEiDwwFMOeMPj4wCAACFwA+OmgAAAEyLZbhIidhIweg/SAHYSNH4SInCTIngSMHoP0wB4EjR+EgB
0EiJRbhIOdgPjWn///9IiV24SI2VQP///0SJ9kiNfbhB/9VIhcAPhGP///9IjXWASI29QP///+jj
+v//hcB0QEiLVbhIOdoPhGr///9MOeIPhXb///9Ig+oBSIlVuEw54g+N8QEAAEmD7AHpXP///w8f
gAAAAABIi1246WH///+LRaCFwA+IywAAADuFYP///w+EvwAAAEmB/UClQQB0IUiLHVimBQBIhdsP
hLoBAACLQwiD6AGJhTT////p7QAAAEiLHT+mBQDr3Q8fRAAAQYPsAUWF5A+IywAAAEljxEiNBECL
faA5vMNQKgAAdOBJY8RIjRRASItFuEgDhNNIKgAASGOVNP///0iNFFJIK4TTSCoAAEiJRcBIjZVA
////RIn2SI19wEH/1UiFwHSgSI11gEiNvUD////o4Pn//4XAdYyLRaA5hWD///91gUiLRcBIiUW4
SItFuEhjlTD///9IidNIAcJIiVXASDnQD5/BidjB6B84wQ+F+QAAAEiJVbhMifpEifZIjX24Qf/V
SIXAdA1Ii4U4////xwABAAAASItFuOtvg600////AYO9NP///wB4I0hjhTT///9IjQRAi32gObzD
UCoAAHXZi0MIRI1g/+n5/v//SMfA/////+szSMfA/////+sqSMfA/////+shSMfA/////+sYSMfA
/////+sPDx+EAAAAAABIx8D/////SIHEqAAAAFtBXEFdQV5BX13DDx+AAAAAAEjHwP/////r3kjH
wP/////r1UjHwP/////rzA8fRAAASMfA/////+u+SMfA/////+u1SMfA/////+usSMfA/////+uj
Dx9AAEjHwP/////rlmYuDx+EAAAAAAAPH0QAAFVIieVBVkFVQVRTDx9EAABJifxJifVBidZIictB
uAAAAADoqfj//4M7AHQMW0FcQV1BXl3DDx8AQbgBAAAASInZRInyTInuTInn6IH4///r22YuDx+E
AAAAAAAPH0QAAFVIieVBV0FWQVVBVFNIgew4CAAADx9EAABIiftIibWw9///iZWs9///g38gAX4H
x0cgAQAAAEiNjcz3//+Llaz3//9Mi72w9///TIn+SInf6Ev///+Lvcz3//+Jvaj3//+F/w+F1gEA
AIN7IAAPiMwBAABJgf9ApUEAdDxMiy2NowUATYXtD4TFAQAAi4Wo9///Zg8fRAAAQTlFCH4qSGPQ
x4SV0Pv//wAAAACDwAHr5w8fgAAAAABMiy1ZowUA68IPH4AAAAAAQYtFBIPoAUSLvaj3///rCw8f
hAAAAAAAg+gBhcB4OUhj0EEPtowVmCUAAEiJyoO8jdD7//8AdeDHhI3Q+///AQAAAEljz4mUjdD3
//9FjX8B68UPH0QAAIuFqPf//4mFuPf//+nGAAAADx+AAAAAAEGDxgFFOf4PjasAAABJY8ZIY4SF
0Pf//0mJxEiNFECLQyBBOYTVUCoAAHTUSWPUSI0UUkmLlNVIKgAASGONvPf//0iNDElBK5TNSCoA
AAEThcAPlMAPtsCJQyBIjY3M9///i5Ws9///SIu1sPf//0iJ3+jx/f//g73M9///AA+FgwAAAEhj
hbz3//9IjQRASYuExUgqAABLjRRkQSuE1UgqAAABA4N7IAAPlMAPtsCJQyDpSf///5CDhbj3//8B
RDm9uPf//304SGOFuPf//0hjhIXQ9///iYW89///SI0EQIt7IEE5vMVQKgAAdcpEi7Wo9///6Qr/
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
9n8xg320AQ+ewApFhHRug32sAXQtx4Vw////AAAAAOtmi7Vw////TInv6JYKAABJicXrt0iJx+iJ
CgAASIlFoOvBSLj///////8PAEiLdbhIhcYPhcoAAABIifBIweggqQAA4H8PhMcAAACDwwFBg8YB
i0WsiYVw////6wrHhXD///8AAAAAg710////AA+FrQAAALgBAAAARAHwg+AfdAm6IAAAACnCidCD
+AQPjrcAAACD6AQBw0EBx0EBxoXbD4+9AAAARYX2D4/GAAAAg714////AA+FzgAAAItNqIXJD44p
AQAAg32EAA+E9wQAAEWF/w+PJgIAAIO9cP///wAPhS4CAABMi3WYTYnni0WEiYV0////TImlaP//
/+lEAwAAx4Vw////AAAAAOlV////x4Vw////AAAAAOlG////SItNoItBFImFdP///4PoAUiYi3yB
GOjfBwAAicK4IAAAACnQ6S////+D+AMPj0v///+DwBwBw0EBx0EBxuk7////id5Mie/o9QkAAEmJ
xekx////RIn2SIt9oOjhCQAASIlFoOkl////SIt1oEyJ7+jBCgAAhcAPiR7///+DbbABugAAAAC+
CgAAAEyJ7+jDBgAASYnFg32EAHUOi4Vo////iUWo6fH+//+6AAAAAL4KAAAASIt9mOiZBgAASIlF
mIuFaP///4lFqOnM/v//i0W0g/gDD5TCg/gFD5TACMIPhMD+//+FyQ+IwAAAALoAAAAAvgUAAABI
i32g6FUGAABIiUWgSInGTInv6CYKAACFwH4MTIt1mItNsOmiAAAATIt1mOsOSMdFoAAAAABBvgAA
AACLRYD30IlFsEyJ40jHRZgAAAAASIt9oOhTBQAATYX2dCBIi0WYSIXAD5XCTDnwD5XAhMIPhVoE
AABMiffoLgUAAEw54w+GyPr//4B7/zAPhb76//9Ig+sB6+dIx0WgAAAAAEG+AAAAAOuWSMdFoAAA
AABBvgAAAADrhkyLdZjrgEjHRaAAAAAAQb4AAAAASY1cJAFBxgQkMY1BAYlFsEjHRZgAAAAA6Wj/
//9Eif5Ii32Y6FYIAABIiUWY6cX9//9Ii12Yi3sI6N0DAABIY1MUSI0UlQgAAABIjXgQSI1zEOiW
+AAAvgEAAABIicfoGwgAAEmJxumc/f//i0WEiUWA6UABAABEieZMi6Vo////g714////OQ+EJAIA
AIX2fg+LhXD///+DwDGJhXj///9JjV8BD7aFeP///0GIB+nR/v//dR/2hXj///8BD4WZAQAA6xBM
i6Vo////6wdMi6Vo////SY1fAQ+2hXj///9BiAfpnf7//4N9gAAPj4cBAABJjV8BD7aFeP///0GI
B4tNqDmNdP///w+EQwIAALoAAAAAvgoAAABMie/ocwQAAEmJxUw5dZgPhJkBAAC6AAAAAL4KAAAA
SIt9mOhTBAAASIlFmLoAAAAAvgoAAABMiffoPQQAAEmJxoOFdP///wFJid9Ii12gSIneTInv6F0M
AACJhXD///+DwDCJhXj///9Ii3WYTInv6OYHAABBicRMifZIid/oMAgAAEiJw4N4EAAPhcP+//9I
icZMie/owAcAAIlFgEiJ3+giAwAAg32AAA+UwoN9tAEPlcCEwnQQ9kW4AXUKg32sAA+Plv7//0WF
5HgVD5TChNAPhPf+///2RbgBD4Xt/v//QYN9GAB1C0GDfRQBD464/v//g320AX4Ui0WshcAPhLD+
//+D+AIPhMv+//9Mi6Vo////g32AAA+Onf7//74BAAAATInv6DoGAABJicVIi3WgSInH6CAHAACF
wA+OWP7//4uFcP///4PAMYO9eP///zl0RImFeP///+lc/v//TIulaP///4N9rAAPlMCEhX////8P
hUL+//+DvXj///85dBZJjV8BD7aFeP///4PAAUGIB+nT/P//SY1fAUHGBzlMi32YTIl1mOnYAAAA
ugAAAAC+CgAAAEyJ9+i7AgAASYnGSIlFmOl1/v//TYnmQb8BAAAATIlluESLZajrIUU5531mugAA
AAC+CgAAAEyJ7+iFAgAASYnFQYPHAUmJ3kiLdaBMie/oqwoAAIPAMEmNXgFBiAZBg30YAHXCQYN9
FAF/u0yLZbhMi3WYSMdFmAAAAADpM/z//0yLpWj///9Mi32YTIl1mOsQiYV4////TItluEG/AAAA
AItFrIXAdFqD+AJ0IL4BAAAATInv6PMEAABJicVIi3WgSInH6NkFAACFwH4qSInaSIPrAQ+2Azw5
dUNJOdx17YNFsAHGAzFIidNMi3WYTIl9mOm8+///dQn2hXj///8BdctIidhIicNIg+gBgDgwdPRM
i3WYTIl9mOmV+///g8ABiANIidNMi3WYTIl9mOmA+///SIt9mOjTAAAA6Zj7//+JTbDpmPv//1VI
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
RAAASIn7gD3jSQQAAHQb2y37SQQASIld6N9t6EiF23gQ3slIg8QYW13D6H3////r3tgFhQkBAOvo
VUiJ5Q8fRAAAiz1o4QMA6PgbAABdw1VIieVIg+wQDx9EAACAPY1JBAAAdDYPMUjB4iBICcJIidBI
KwWASQQA2y2CSQQA2y2MSQQASIlF+N9t+HgV3snbLSsJAQDeyd7BycPoDP///+vD2AUUCQEA6+NV
SInlSIHs0AAAAA8fRAAASImVYP///0iJjWj///9MiYVw////TImNeP///4TAdCAPKUWADylNkA8p
VaAPKV2wDyllwA8pbdAPKXXgDyl98MeFOP///xAAAADHhTz///8wAAAASI1FEEiJhUD///9IjYVQ
////SImFSP///4OFOP///wiLjWD///+J8kiJ/os9OeADALgAAAAA6KMAAADJw1VIieVBV0FWQVVB
VFNIg+wYDx9EAACJfcxJifVBidRBic5Eiz1YTgQA6McnAACJw/YFZp8BAAF0BYP4/3QRidhIg8QY
W0FcQV1BXkFfXcOBPShOBAD/AAAAfuNEiT0fTgQATIs9rOMDAESJ+vfSRCHiRInxTInui33M6HYn
AACJw4P4/3S4TWPkTYX8dLC6AQAAAL4CAAAAicfo9iYAAOudVUiJ5UFWQVVBVFNIgezgAAAADx9E
AABBif1IifNBidRIiY1I////TImFUP///0yJjVj///+EwHQmDymFYP///w8pjXD///8PKVWADyld
kA8pZaAPKW2wDyl1wA8pfdDHhRj///8YAAAAx4Uc////MAAAAEiNRRBIiYUg////SI2FMP///0iJ
hSj///+DhRj///8IRIu1SP///0iF23Q9uPO4QQBIhcB0V7houUEASI21AP///0iJ3//QSIP4/3RA
gz0VTQQAAHUaSWP9SDs9ud4DAHQV6MxD/f/rQ+iRQ/3/6zzovkP9/+s1uPO4QQBEifJEieZIjb0A
/////9DrH4sF9p0BAKgGdCWoAnQ0RInxRIniSIneRInv6KIgAABIgcTgAAAAW0FcQV1BXl3DRInx
RIniSIneRInv6B/+///r3USJ8USJ4kiJ3kSJ7+jMgv3/68pVSInlDx9EAABIhf90EPYFkp0BAAR1
DujrIAAAXcPo+kL9/+v3vgAAAADoSIP9/+vrVUiJ5VNIg+woDx9EAABIidOD//8PlMJIichIweg/
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
9ro4AwAATInf6EJvAAC6gAAAAEyJ1+g1bwAASIXAdBqLEImVMPz//4tQBItACImVOPz//4mFNPz/
/0iF2w+ELQIAAEiLUyDzD35LKEiNhej9//9IjbMQAQAA8w9vm8gAAACLC0iJhZD9//9IiccPFktY
SImVwPz//4tTMEljwA8pjdD8///zD35LYPMPb4PYAAAASAUAAEAAiZXI/P//SIuTuAAAAA8WS2jz
D29TEGYPxsMCDymFcP3///MPfoP4AAAADymN4Pz///MPfktwZomVbP3//0iLk7AAAAAPFkt4DxaD
4AAAAA8Rldj9//8PKY3w/P//8w9+i4AAAABIiY2w/P//uUAAAAAPFouIAAAAZomVav3//0yJ2g8p
jQD9///zD36LkAAAAA8WSzgPKY0Q/f//8w9+S0DzSKUPKYVQ/f//TInWRInPDxaLmAAAAA8pjSD9
///zD36LoAAAAA8WS0gPKY0w/f//8w9+i6gAAAAPFktQDymNQP3////QSIuFQP3//7lAAAAA8w9v
pUj9///zD2+FOP3///MPb60Y/f//SI27EAEAAEiJg6gAAABIi4V4/f//Zg9sxPMPb7XY/P//8w9v
vej8//8PEWs4SImD0AAAAA+3hWz9///zD2+V+Pz///MPb50I/f//DxFDSEiJg7gAAAAPt4Vq/f//
8w9vpSj9//9Ii7WQ/f//DxFzWEiJg7AAAABIi4Vw/f//DxF7aEiJg9gAAABIi4VY/f//DxFTeEiJ
g+AAAABIi4VQ/f//DxGbiAAAAEiJg/gAAAAPEaOYAAAA80ilSIHEyAMAAFtdww8fhAAAAAAASWPA
TInaTInWRInPSAUAAEAA/9BIgcTIAwAAW13DZpBVSInlU0iB7MgDAAAPH0QAAEiJ04n6QYn5SInw
g+J/RIsElUAiRwBBg/gHD46JAgAATI2dsPz//0yNlTD8//8x9ro4AwAATInf6HJsAAC6gAAAAEyJ
1+hlbAAASIXAdBqLEImVMPz//4tQBItACImVOPz//4mFNPz//0iF2w+ERQIAAIuT3AAAAEiNhej9
//9IiYWQ/f//iZXY/f//SIsTSImVGP3//0iLUwhIiZUg/f//SItTEEiJlTj9//9Ii1MYSImVSP3/
/0iLUyBIiZXY/P//SItTKEiJleD8//9Ii1NwSImVQP3//0iLU2hIiZUw/f//SItTYEiJlSj9//9I
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
hsQAAACA+ioPhM4AAAC7AAAAAEiLhXj///+AOC4PhAABAADHhWj///8AAAAASIuVeP///w+2Ajxq
D4TBAQAAD49yAQAAPFoPhIkBAAA8aA+EJwIAADxMD4QDAgAAxoVk////H7oAAAAASIuFeP///0iN
SAFIiY14////D7YAD77IiY1g////PGYPhPMEAAAPjiUCAAA8cQ+EywQAAA+OcgMAADx1D4SwAwAA
D46+AwAAPHgPhSsCAAC4nOVDAEG4BAAAAOkLAwAASI29eP///+h4+v//icPpN////0GDfQAvdyBB
i0UASQNFEEGDRQAIixiF23gbSIOFeP///wHpEP///0mLRQhIjVAISYlVCOvfQYPOAvfbx4Vw////
LQAAAOvTQYPOIEiNUAFIiZV4////D7ZQAQ++woPoMIP4CXYUgPoqdD3HhWj///8AAAAA6dj+//9I
jb14////6Oz5//+JhWj///+DvWj///8AD4m5/v//x4Vo////AAAAAOmq/v//QYN9AC93H0GLRQBJ
A0UQQYNFAAiLAImFaP///0iDhXj///8B675Ji0UISI1QCEmJVQjr4DxsdGF9EcaFZP///x+6AAAA
AOmb/v//PHR0BDx6dRlIg4V4////AcaFZP///z+6AAAAAOl6/v//xoVk////H7oAAAAA6Wn+//9I
g8IBSImVeP///8aFZP///3+6AAAAAOlN/v//D7ZCATxmQA+UxjxGD5TBQAjOdBxIg8IBSImVeP//
/8aFZP///x+6AAAAAOkd/v//PGx1hkiDwgFIiZV4////6Xb///9Ig8IBSImVeP///8aFZP///x+6
AQAAAOnt/f//SI1CAUiJhXj///+AegFodBHGhWT///8PugAAAADpy/3//0iNQgJIiYV4////xoVk
////B7oAAAAA6a/9//88WA+EEwIAADxYfj48Yw+EIQIAAA+O5QAAADxkD4R7AQAAPGUPhJwAAACI
RY+6AQAAAEyJ/kiNfY9B/9SD+P8Phf74///pEhMAADxBD4Q+CwAAfkU8Rg+EbAIAADxHdV5B9sYg
dQrHhWj///8GAAAAhNIPhHgGAABJi0UISIPAD0iD4PBIjVAQSYlVCNso3Z1Y////6XwGAAA8JXWN
xkWPJboBAAAATIn+SI19j0H/1IP4/w+Fivj//+meEgAAPEUPhWT///9B9sYgdQrHhWj///8GAAAA
hNIPhEEHAABJi0UISIPAD0iD4PBIjVAQSYlVCNso3Z1Y////6UUHAAA8YQ+ElgoAADxiD4Ub////
QbgBAAAAuJzlQwAPto1k////SIPsCFBFD7b2QVZIY9tTTGONaP///0GD4AdMiepMif5MiefoBBcA
AEiDxCCD+P8Phe33///pARIAADxtD4QVAQAAfig8bw+EuAAAADxwD4W1/v//QYPOEEG4BAAAAMaF
ZP///z+4nOVDAOuNPGcPhMv+//88aQ+Fjf7//0GDzkBBg+bvQbgAAAAAuJzlQwDpZf///zxyD4Tt
AAAAPHMPhWX+//9Bg30ALw+H5wAAAEGLRQBJA0UQQYNFAAhIixC4IgAAAEljzg+2wFAPtoVk////
UExjy0xjhWj///9Mif5MiefoixsAAEiDxBCD+P8PhS33///pQREAALiJ5UMA6d/7//9BuAMAAAC4
nOVDAOnl/v//QYPOIEGDfQAvdypBi0UASQNFEEGDRQAIiwCJRazHhWj///8BAAAAuCcAAABIjVWs
6Xv///9Ji0UISI1QCEmJVQjr1bhZMUMASIXAdCG4WTFDAIu9TP/////QSInCuCIAAADGhWT///8A
6UL///+66a5DAOvoQYPOBEGDzgjpDv///0mLRQhIjVAISYlVCOkV////QfbGIHUKx4Vo////BgAA
AITSdB5Ji0UISIPAD0iD4PBIjVAQSYlVCNso3Z1Y////6yVBgX0ErwAAAA+H0AEAAEGLRQRJA0UQ
QYNFBBBIiwBIiYVY////uOVCQgBIhcAPhEMCAAC45UJCAEyNRaBIjU2USI1VkIu1aP///78DAAAA
8g8QhVj/////0EiJhVj///+BfZAPJwAAD4SCAQAAg32UAHQKx4Vw////LQAAAIuFaP///4XAfgIp
w4XbfjaDvXD///8AdAOD6wGDfZAAD47oAQAASIuFWP///0g5RaAPhOsBAAArXZCDvWj///8AfgOD
6wGF235sRInwg+ACiYVk////dV5B9sYBD4TTAQAAi4Vw////hcB0G4hFj7oBAAAATIn+SI19j0H/
1IP4/w+EXg8AAMZFjzC6AQAAAEyJ/kiNfY9B/9SD+P8PhEIPAACD6wGF23/di4Vk////iYVw////
i4Vw////hcB0G4hFj7oBAAAATIn+SI19j0H/1IP4/w+ECg8AAIN9kAAPj5sBAADGRY8wugEAAABM
if5IjX2PQf/Ug/j/D4TkDgAAg71o////AA+OTwEAAMZFjy66AQAAAEyJ/kiNfY9B/9SD+P8PhLsO
AABEi7Vo////g32QAA+JLgEAAMZFjzC6AQAAAEyJ/kiNfY9B/9SD+P8PhI4OAABBg+4Bg0WQAevQ
SYtFCEiNUAhJiVUI6Sz+//9Ix0WYAAAAAEiNVZiDfZQAdFJIidBIg8ABxkWYLUiLjVj///+AOU4P
lMEPtsmDvWD///9gQA+fxkAPtvZIY8lIjQxOiwyNsOVDAIkIQYPm08eFaP///wAAAAC4IgAAAOmY
/P//QfbGBHQJSI1CAcYCK+uqQfbGCHQJSI1CAcYCIOubSInQ65a66a5DAOu+uumuQwDrt7rprkMA
67CNQ/+DvWj///8AfhSD6wLpJP7//8dFkAEAAADpCf7//4nD6RH+///GRY8gugEAAABMif5IjX2P
Qf/Ug/j/D4SUDQAAg+sBhdt/3elZ/v//RIu1aP///+nI/v//RInwTIu1WP///4mdcP///4nD6aUA
AABMi7VY////6y24MAAAAIhFj7oBAAAATIn+SI19j0H/1IP4/w+EPA0AAItFkIPoAYlFkIXAfg5B
D74GhcB0y0mDxgHrykyJtVj///+DvWj///8AfmTGRY8uugEAAABMif5IjX2PQf/Ug/j/D4T1DAAA
TIu1WP///4mdcP///4udaP///+sguDAAAACIRY+6AQAAAEyJ/kiNfY9B/9SD+P8PhMAMAACD6wF4
I0EPvgaFwHTTSYPGAevSTIu1WP///4mdcP///4udaP///+vYi51w////g+sBD4hw8v//xkWPILoB
AAAATIn+SI19j0H/1IP4/3Xf6WwMAABBgX0ErwAAAA+HyQAAAEGLRQRJA0UQQYNFBBBIiwBIiYVY
////g71o////AA+ItgAAALjlQkIASIXAD4RH/v//uOVCQgCDvWj///8AD4SlAAAAvwIAAABMjUWg
SI1NlEiNVZCLtWj////yDxCFWP/////QSInBSImFWP///4tVkIH6DycAAA+Ebf3//0iLRaBIKciJ
xoO9aP///wB1a4B5AQB0XrkFAAAAAcGJhWj///+D+v18WznKf1cp0ImFaP///w+Jr/v//8eFaP//
/wAAAADpoPv//0mLRQhIjVAISYlVCOkz////x4Vo////AAAAAOk7////i71o////6VX///+5BAAA
AOugi41o////66CDrWD///8Ci41o////OcF/AonOjUb/iYVo////631BgX0ErwAAAA+HtQAAAEGL
RQRJA0UQQYNFBBBIiwBIiYVY////g71o////AA+IogAAALjlQkIASIXAD4Qf/f//uOVCQgCLjWj/
//+NcQFMjUWgSI1NlEiNVZC/AgAAAPIPEIVY/////9BIiYVY////gX2QDycAAA+ETfz//4N9lAB0
CseFcP///y0AAACLhWj///+DwAUpw4XbfhiDvXD///8AdAOD6wGDvWj///8AdAOD6wGLRZCD6AGJ
RZB5PPfY6zhJi0UISI1QCEmJVQjpR////8eFaP///wAAAADpT////4PrAUhj0Ehp0mdmZmZIwfoi
wfgfKcKJ0IP4Y3/jhdt+bESJ8IPgAomFZP///3VeQfbGAQ+E2QAAAIuFcP///4XAdBuIRY+6AQAA
AEyJ/kiNfY9B/9SD+P8PhPwJAADGRY8wugEAAABMif5IjX2PQf/Ug/j/D4TgCQAAg+sBhdt/3YuF
ZP///4mFcP///4uFcP///4XAdBuIRY+6AQAAAEyJ/kiNfY9B/9SD+P8PhKgJAABIi4VY////TI1w
AQ+2AIhFj7oBAAAATIn+SI19j0H/1IP4/w+EfwkAAIO9aP///wAPhIUAAADGRY8uugEAAABMif5I
jX2PQf/Ug/j/D4RWCQAAiZ1w////i51o////60jGRY8gugEAAABMif5IjX2PQf/Ug/j/D4QsCQAA
g+sBhdt/3elT////uDAAAACIRY+6AQAAAEyJ/kiNfY9B/9SD+P8PhAAJAACD6wF4HEEPvgaFwHTT
SYPGAevSiZ1w////i51o////69+LnXD///8PtoVg////iEWPugEAAABMif5IjX2PQf/Ug/j/D4S3
CAAAg32QAHgpxkWPK7oBAAAATIn+SI19j0H/1IP4/w+ElQgAALoKAAAAQb4CAAAA6yzGRY8tugEA
AABMif5IjX2PQf/Ug/j/D4RsCAAAi0WQ99iJRZDrzUGDxgGJwo0EkgHAO0WQfvCJnXD///9Mia1o
////QYnVi0WQmUH3/YnDjUAwiEWPugEAAABMif5IjX2PQf/Ug/j/D4QbCAAAQYPuAUWF9n4TQQ+v
3YtFkCnYjQSAAcCJRZDrvYudcP///0yLrWj///+D6wEPiNDt///GRY8gugEAAABMif5IjX2PQf/U
g/j/dd/pzAcAAEjHhVD///+J5UMA6wtIx4VQ////nOVDAITSD4SjAgAASYtFCEiDwA9Ig+DwSI1Q
EEmJVQjbKN2dWP///0iLjVj///9IichIweggicKB4gAA8H+B+gAA8H8PhDH3//+FwA+IkQIAAPIP
EIVY////Zg8uBdjAAAAPip8CAAAPhZkCAADHhWT///8AAAAAx4Vg////MAAAAEH2xiAPhAYFAACD
vWj///8NfgrHhWj///8NAAAA8g8QhVj///9mDy4Fi8AAAA+KnQMAAA+FlwMAAIO9ZP///wAPhTAF
AADHhUj///8BAAAASIuNWP///0iJyEjB6CCFwA+IUwUAAIuFSP///4PABSnDhdt+GIO9cP///wB0
A4PrAYO9aP///wB0A4PrAUiLjVj///9IichIhcl0FYO9aP///wB+DEgPvcCDwATB6AIpw4XbfmxE
ifCD4AKJhUT///91XkH2xgEPhD0FAACLjXD///+FyXQniE2PugEAAABMif5IjX2PQf/Ug/j/D4RE
BgAAi4VE////iYVw////xkWPMLoBAAAATIn+SI19j0H/1IP4/w+EHAYAAIPrAYXbf92LhXD///+F
wHQbiEWPugEAAABMif5IjX2PQf/Ug/j/D4TwBQAAxkWPMLoBAAAATIn+SI19j0H/1IP4/w+E1AUA
AEiLhVD///8PtkARiEWPugEAAABMif5IjX2PQf/Ug/j/D4SuBQAAD7aFYP///4hFj7oBAAAATIn+
SI19j0H/1IP4/w+EjAUAAIO9aP///wAPjnsEAADGRY8uugEAAABMif5IjX2PQf/Ug/j/D4RjBQAA
TIu1UP///4uFaP///0iLnVj///9Mia1w////RI1o/4XAD45YBAAASInYSMHoMIPgD0EPtgQGiEWP
ugEAAABMif5IjX2PQf/Ug/j/D4QSBQAASMHjBESJ6OvBQYF9BK8AAAB3HEGLRQRJA0UQQYNFBBBI
iwBIiYVY////6VP9//9Ji0UISI1QCEmJVQjr4yX///9/SMHgIInKSAnCSImVWP///8eFcP///y0A
AADpS/3//0iLvVj///9IifhIweggSIn5SMHpNEiJyo2JAfz//4mNZP///yX//w8ASInGSMHmIIn/
SAn3SIm9WP///4H5Afz//3QPx4Vg////MQAAAOko/f//jbIC/P//ibVk////hcB1MEiLlVj////p
kQAAAEONBACJwki4AAAAAP////9IIfhICdBIicdIweggPf//DwB3NYPuAUiJ+UjB6SAByUiJyEjB
4CCJ+kgJwkiJ10GJ0IXSebqJyIPIAUjB4CCJ0kiJ10gJx+unibVk////SIm9WP///8eFYP///zEA
AADpl/z//4OtZP///wGNBBKJwEi5AAAAAP////9IIcpICcKJ0IXSed6DrWT///8VidHB6QuJykiJ
0UjB4SCJwkgJysHgFYnBSLgAAAAA/////0gh0EgJyEiJhVj////HhWD///8xAAAA6TD8//+LjWj/
//+D+QwPj1r8//9Ii71Y////SIn+SMHuIIHOAAAQAEiJ8EjB4CCJ+kgJ0EiJhVj///+D+QR/fLoF
AAAAKcqNDJX/////ugEAAADT4oXWD4QR/P//jUr/jTwSCfmFznUIhcAPhP37//+NFBZIweIgicBI
CdBIiYVY////SIuNWP///0iJyEjB6CCpAAAgAA+E0fv//4OFZP///wFI0ehIweAgicpICcJIiZVY
////6bL7//+DvWj///8FdFy/DQAAACu9aP///8HnAo1P/7oBAAAA0+KFwg+Eifv//41K/0SNDBJE
CcmFwQ+Ed/v//wHCQYnQSLkAAAAA/////0ghyEwJwEiJhVj///+J+dPqhdIPhU/7///rCIXAD4lF
+///jUYBSMHgIIuVWP///0gJwkiJlVj////pP////0iLhVj///+FwHQhMdLzD7zQg+L8uCAAAAAp
0MH4AoPABYmFaP///+n9+v//SIuFWP///0jB6CAl//8PAImFaP///w+E4fr//zHS8w+80IPi/LgU
AAAAKdDB+AKJhWj////pw/r//4uFZP///4XAeCqLhWT///+5AQAAAIP4CX4eg8EBSGPQSGnSZ2Zm
ZkjB+iLB+B8pwonQ6+H32OvYiY1I////6Zf6//8l////f0jB4CCJykgJ0EiJhVj///9mSA9uwGYP
LgXdugAAeh51HIO9cP///wAPhHr6///HhXD///8tAAAA6Wv6///HhXD///8tAAAA6Vz6///GRY8g
ugEAAABMif5IjX2PQf/Ug/j/D4QQAQAAg+sBhdt/3env+v//TIu1UP///4uFaP///0iLnVj///9M
ia1w////6Zz7//9Mi61w////SIuFUP///w+2QBCIRY+6AQAAAEyJ/kiNfY9B/9SD+P8PhLcAAACL
nWT///+F23h6xkWPK7oBAAAATIn+SI19j0H/1IP4/w+EkQAAALoBAAAAi41k////idONBJIBwInC
Och+80SLtUj///9Mia1w////QYnNRInomff7g8AwiEWPugEAAABMif5IjX2PQf/Ug/j/dEhBg+4B
dDFEieiZ9/tEjSySRQHt68vGRY8tugEAAABMif5IjX2PQf/Ug/j/dBv324mdZP///+uATIutcP//
/+ns5f//uAAAAABIjWXYW0FcQV1BXkFfXcOA+kB3KYnR9sIDdSJIifCEyXQzg+kESIn6SNPqg+IP
D7aSd6tDAIgQSI1AAevhVUiJ5boZAAAAvsDlQwC/3uVDAOiJh///xgAASCnww2YuDx+EAAAAAAAP
H0AASbnNzMzMzMzMzEUxwA8fAEiJ+EmJ+kyJwUmDwAFJ9+FIweoDSI0EkkgBwEkpwkyJ0IPAMEKI
RAb/SIn4SInXSIP4CXfLQsYEBgBIhcl0JTHADx+AAAAAAA+2FAYPtjwOQIg8BkiDwAGIFA5Ig+kB
SDnIcuRMicDDDx+EAAAAAABVSInlSIX/eRfGBi1I999Ig8YB6Gj///9dSIPAAcNmkOhb////XcNV
SInlSIX/dBdIifpID73Sg8IEgeL8AAAA6OD+//9dw7oEAAAA6/JVSInlQVdBVkFVQVRTSIPsGA8f
RAAASYn+SIl1yEmJ1InLi30QRIttGItNIInOQYnPQYPnAnVfRYXtdBP2wQF0DkWEwHUF9sEMdARB
g+0BOfsPksKB+48AAAAPlsCEwnQMidhBxgQEMI1bAeviQPbGAXQjRDnrD5LAgfuPAAAAD5bChMB0
EITSdAyJ2EHGBAQwjVsB69f2wRB0WPbBIHUfhdt0Gzn7D5TCRDnrD5TACMJ0DI1D/4nCQYA8FDB0
d0GD+QQPlMKB+48AAAAPlsCEwg+EnAAAAInYQcYEBHiNWwGB+48AAAB3ConYQcYEBDCNWwGB+48A
AAB3E0WEwA+EjQAAAInYQcYEBC2NWwH2wQN1CUQ56w+CoQAAAEGJ2U2FyQ+E0wAAAEmNUf+4AAAA
AOnAAAAAhcB0K0GD+QRAD5TGQYP5AQ+UwkAI1nQeg+sCidpBgDwUMA+EYf///4nD6Vr///+Jw+lT
////icPpTP///0GD+QEPlMKE0A+EX////4nYQcYEBGKNWwHpUP////bBBHQPidhBxgQEK41bAelp
////9sEID4Rg////idhBxgQEII1bAelR////RInqKdpIi3XITIn36G8DAACD+P8PhUX////rZ0mN
NARJjQwUD7Y+RA+2AUSIBkCIOUiDwAFIg+oBSDnQct5MicpIi3XITInnQf/Wg/j/dDNFhP90KUQ5
63IHuAAAAADrIkSJ6inaSIt1yEyJ9+gOAwAAg/j/dAy4AAAAAOsFuAAAAABIg8QYW0FcQV1BXkFf
XcNVSInlQVdBVkFVQVRTSIHsyAAAAA8fRAAASIm9KP///0iJtSD///9JidJJictEiYUc////RYnM
RIt1IEyLfShIichICdB1BEGD5u9MidhMCdB1EUSJ84PjIA+FvgAAAEGJ3etnQb0AAAAAuwAAAADr
WrpsAAAAvjDmQwC/QOZDAOjSg///TIneTI1FwLoKAAAAuQAAAABMidfoYw8AAEmJwkmJ04t1wOtT
QYPFAYnZjVkBifZBD7Y0N4nJQIi0DTD///9MidhMCdB0V4H7jwAAAHeeRYXkdK2//////0SJ4dPn
if731kQh1k0PrdpJ0+tB9sRAdAZNidpFMdtB9saAdKdBg/0DdaGNSwGJ28aEHTD///8sQb0BAAAA
65K7AAAAAEiD7AhFD7b2QVaLRRhQi0UQUEWJ4UQPtoUc////idlIjZUw////SIu1IP///0iLvSj/
///oVvz//0iNZdhbQVxBXUFeQV9dw1VIieVBV0FWQVVBVFNIg+wYDx9EAABMiUXITInLi0UYQYnC
qCB0BEGD4v5B9sJAdQRBg+LzgPk/D4bVAAAAgzonD4ezAAAAiwJIA0IQgwIQTIsITItACEUx5EUx
7fbBQEEPlMRBD5XFSdPkSdPlTYnmTYnvSYPG/0mD1/9NifNNCeNMiflMCelNIdlMichJIchMicJB
9sJAD4SnAAAATYnpTTHBTYngSTHATQnBD4TJAAAATYngSSHATYnpSSHRTQnBdHlJicBJidFJ99hJ
g9EASffZTSHDTInYTCHJSInKQbgBAAAASYnBTSHxSInRTCH5TInISInK61FIi0IISIPAD0iD4PBM
jUAQTIlCCOk9////gzovdxeLAkgDQhCDAghMiwhBuAAAAADpKP///0iLQghMjUAITIlCCOvkQbgA
AAAA66FBuAAAAAD/dSBFD7bSQVJIi00QUVNEi03IQYPgAUiJ0UiJwugp/f//SI1l2FtBXEFdQV5B
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
bmQoJnpzKQBaX0RBVEFfRVJST1IAWl9ORUVEX0RJQ1QAWl9NRU1fRVJST1IAdGV4dC8AY2FuJ3Qg
bG9hZCBkaXJlY3RvcnkAL3JlZGJlYW4ucG5nAHRleHQvaHRtbDsgY2hhcnNldD1JU08tODg1OS0x
ADwhZG9jdHlwZSBodG1sPg0KPHRpdGxlPgAlZCAlcw0KADwvaDE+DQoALyVkLmh0bWwAdGV4dC9o
dG1sOyBjaGFyc2V0PXV0Zi04AEVSUk9SICVkICVzAE1ldGhvZCBOb3QgQWxsb3dlZAAlcy4lczog
JWxkDQoAdHZfc2VjAHR2X3VzZWMAcnVfdXRpbWUAcnVfc3RpbWUAcnVfbWF4cnNzAHJ1X2l4cnNz
AHJ1X2lkcnNzAHJ1X2lzcnNzAHJ1X21pbmZsdABydV9tYWpmbHQAcnVfbnN3YXAAcnVfaW5ibG9j
awBydV9vdWJsb2NrAHJ1X21zZ3NuZABydV9tc2dyY3YAcnVfbnNpZ25hbHMAcnVfbnZjc3cAcnVf
bml2Y3N3ACVzICUsbGQgYnl0ZSBtZXNzYWdlCiUuKnMAc2VuZGluZwBIVFRQLzEuMSAxMDAgQ29u
dGludWUNCg0KAHRvbyBtYW55IHByb2Nlc3NlcyAlcwBvcGVuKCVgJ3MpIGZhaWxlZCAlcwBTZXJ2
aWNlIFVuYXZhaWxhYmxlAEludGVybmFsIFNlcnZlciBFcnJvcgBraWxsKDAsIFNJR1VTUjIpAGlu
ZGV4aW5nIGFzc2V0cyAoaW5vZGUgJSNseCkAZmFsc2UAIT0AWklQX0NGSUxFX01BR0lDKHpiYXNl
ICsgY2YpAGtaaXBDZmlsZUhkck1hZ2ljAG9wZW4oKSBmYWlsZWQgdy8gJW0ALmNvbS5kYmcATVpx
RnBEAG1tYXAoKSBmYWlsZWQgdy8gJW0Ac3RhdCgpIGZhaWxlZCB3LyAlbQBtbWFwKCVgJ3MpIGZh
aWxlZCAlcwAvLmFwZQAvLmFwZSBub3QgZm91bmQAU2VydmVyOiAlcw0KAGVycm9yOiBub3QgYSBk
aXJlY3Rvcnk6ICVgJ3MKAGVycm9yOiBiYWQgcG9ydDogJWQKAGVycm9yOiBiYWQgYWRkcjogJXMg
KEVBSV8lcykKACVzJS4qczolcw0KAGVycm9yOiBpbGxlZ2FsIGhlYWRlcjogJWAncwoALy5oZWxw
LnR4dABTT19SRVVTRUFERFIAU09MX1NPQ0tFVABUQ1BfQ09SSwBJUFBST1RPX1RDUABUQ1BfTk9E
RUxBWQBUQ1BfRkFTVE9QRU4AVENQX1FVSUNLQUNLACVoaHUuJWhodS4laGh1LiVoaHUAMC4wLjAu
MABzb2NrZXQAbGlzdGVuAGdldHNvY2tuYW1lAFRlbXBvcmFyeSBSZWRpcmVjdAAvJXMAaHR0cDov
LyVzOiVkJXMAKHBpZCA9IGZvcmsoKSkAZXJybm8ARUlOVFIAJXMgZmFpbGVkIHdpdGggJWQAL2Rl
di9udWxsAHNldGdpZChkYWVtb25naWQpAHNldHVpZChkYWVtb251aWQpAGJhbGxvb25lZCB0byAl
LGxka2IgaW4gc2l6ZSVzAHJlY2VpdmVkICUsbGQgc2lnbmFscyVzAGdvdCBzd2FwcGVkICUsbGQg
dGltZXMlcwByZXNvdXJjZSByZXBvcnQgZm9yIHBpZCAlZAolcwB3YWl0IGVycm9yICVzAGtpbGwo
MCwgU0lHVEVSTSkAJXMgJSxsZCBieXRlIHBheWxvYWQKJS4qcwBuL2EAJWxkJSUAZGVmbGF0ZSgm
enMsIFpfRklOSVNIKQBaX1NUUkVBTV9FTkQAZGVmbGF0ZUVuZCgmenMpAGFuZCAAWklQX0NGSUxF
X01BR0lDKHpjZikAJVktJW0tJWQgJUg6JU06JVMgJVoAPC9wcmU+PGZvb3Rlcj48aHI+DQoAPHRh
YmxlIGJvcmRlcj0iMCI+PHRyPg0KADx0ZCB2YWxpZ249InRvcCI+DQoAc2F5cyB5b3VyIHJlZGJl
YW48YnI+DQoAJSxsZCBkYXklcyAAJSxsZCBob3VyJXMgACUsbGQgbWludXRlJXMgACUsbGQgbWVz
c2FnZSVzIGhhbmRsZWQ8YnI+DQoAPC90YWJsZT4NCgA8L2Zvb3Rlcj4NCgB0ZXh0L2h0bWwAU2Vy
dmVBc3NldENvbXByZXNzZWQoKQBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0AdGV4dC9wbGFpbgBT
ZXJ2ZUFzc2V0UmFuZ2UoKQBQYXJ0aWFsIENvbnRlbnQAYmFkIHJhbmdlICVgJy4qcwBSYW5nZSBO
b3QgU2F0aXNmaWFibGUATm90IE1vZGlmaWVkAFNlcnZlQXNzZXRQcmVjb21wcmVzc2VkKCkAU2Vy
dmVBc3NldFppcElkZW50aXR5KCVgJ3MpAFNlcnZlQXNzZXRJZGVudGl0eSglYCdzKQBMYXN0LU1v
ZGlmaWVkAHJld3JpdGluZyB0byAlYCdzAExvb3AgRGV0ZWN0ZWQASFRUUCBWZXJzaW9uIE5vdCBT
dXBwb3J0ZWQAJWQgcmVkaXJlY3RpbmcgJWAncwBSb3V0ZVBhdGgoJWAnLipzKQBGb3JiaWRkZW4A
aW5kZXguaHRtbABwcGlkAG5vdwBub3dpc2gAZ210b2ZmAENMS19UQ0sAc3RhcnRzZXJ2ZXIAbGFz
dG1lbHRkb3duAHdvcmtlcnMAYXNzZXRzLm4AY2hpbGRyZW4AL3N0YXR1c3oATm90IEZvdW5kAHJl
ZGJlYW4tb3JpZ2luYWwvMS40AGZyZW9wZW4obG9ncGF0aCwgImEiLCBzdGRlcnIpAE5VTEwAQmFk
IENvbnRlbnQgTGVuZ3RoAExlbmd0aCBSZXF1aXJlZABQYXlsb2FkIFRvbyBMYXJnZQBOb3QgSW1w
bGVtZW50ZWQARXhwZWN0YXRpb24gRmFpbGVkAHBheWxvYWQgc2xvd2xvcmlzAFJlcXVlc3QgVGlt
ZW91dABwYXlsb2FkIGRpc2Nvbm5lY3QAQmFkIFJlcXVlc3QAcGF5bG9hZCByZXNldABwYXlsb2Fk
IHJlYWQgdGltZW91dAAlcyBwYXlsb2FkIHJlYWQgZXJyb3IgJXMAJXMgd3JpdGUgcmVzZXQAJXMg
d3JpdGUgdGltZW91dAAlcyB3cml0ZSBlcnJvciAlcwBodHRwcwA4MABSRURJUkVDVCAlcyBmcm9t
ICVzIOKGkiAlcwBodHRwADEwMC1jb250aW51ZQByZWNlaXZlZAAqAGlkZW50aXR5AEJhZCBVUkkA
JXMgc2VudCBnYXJiYWdlICVgJ3MAQmFkIE1lc3NhZ2UAaGRyYnVmLm4AcCAtIGhkcmJ1Zi5wADw9
ACVgJy4qcyBsYXRlbmN5ICUsbGTCtXMAJXMgcmVhZCAlLHpkIGJ5dGVzACVzIHJlYWQgZmFpbGVk
ICVzAGFtdHJlYWQAbXNnc2l6ZQA8ACUsbGQgcGlwZWxpbmVkIGJ5dGVzACVzIGFjY2VwdGVkACVz
IGNsb3NpbmcgYWZ0ZXIgJSxsZMK1cwB0b28gbWFueSBvcGVuIGZpbGVzAHJhbiBvdXQgb2Ygb3Bl
biBmaWxlIHF1b3RhAHJhbiBvdXQgb2YgYnVmZmVyACVzIG5ldHdvcmsgZ29uZQAlcyBuZXR3b3Jr
IGRvd24AJXMgZXBoZW1lcmFsIGFjY2VwdCBlcnJvciAlcwAlcyBhY2NlcHQgZXJyb3IgJXMAJXMg
cmFuIG91dCBvZiBtZW1vcnkAcG9sbCBlcnJvciAlcwBndABNQVBfRkFJTEVEACh6ZmQgPSBvcGVu
KHpwYXRoLCBPX1JET05MWSkpAGZzdGF0KHpmZCwgJnpzdCkAcmVjZWl2ZWQga2V5Ym9hcmQgaW50
ZXJydXB0AHJlY2VpdmVkIHRlcm0gc2lnbmFsAHNlbmRpbmcgVEVSTSB0byBwcm9jZXNzIGdyb3Vw
AHNodXRkb3duIGNvbXBsZXRlAEdEQgBhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQAYXVkaW8v
YWFjAGltYWdlL2FwbmcAYXBwbGljYXRpb24vYXRvbSt4bWwAdmlkZW8veC1tc3ZpZGVvAGltYWdl
L2F2aWYAYXBwbGljYXRpb24vdm5kLmFtYXpvbi5lYm9vawBpbWFnZS9ibXAAYXBwbGljYXRpb24v
eC1iemlwMgB0ZXh0L2NzcwB0ZXh0L2NzdgBhcHBsaWNhdGlvbi9tc3dvcmQAYXBwbGljYXRpb24v
ZXB1Yit6aXAAaW1hZ2UvZ2lmAGFwcGxpY2F0aW9uL2d6aXAAaW1hZ2Uvdm5kLm1pY3Jvc29mdC5p
Y29uAGFwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZQBpbWFnZS9qcGVnAHRleHQvamF2YXNjcmlwdABh
cHBsaWNhdGlvbi9qc29uAGF1ZGlvL21wZWcAYXVkaW8vbWlkaQB2aWRlby9tcDQAdmlkZW8vbXBl
ZwBhdWRpby9vZ2cAYXBwbGljYXRpb24vb2dnAHZpZGVvL29nZwBmb250L290ZgBhcHBsaWNhdGlv
bi9wZGYAaW1hZ2UvcG5nAGFwcGxpY2F0aW9uL3ZuZC5yYXIAYXBwbGljYXRpb24vcnRmAGFwcGxp
Y2F0aW9uL3gtc2gAYXBwbGljYXRpb24vdm5kLnNxbGl0ZTMAaW1hZ2Uvc3ZnK3htbABhcHBsaWNh
dGlvbi94LXNob2Nrd2F2ZS1mbGFzaABpbWFnZS90MzgAYXBwbGljYXRpb24veC10YXIAaW1hZ2Uv
dGlmZgBmb250L3R0ZgBhdWRpby9iYXNpYwBhcHBsaWNhdGlvbi93YXNtAGF1ZGlvL3gtd2F2AGF1
ZGlvL3dlYm0AdmlkZW8vd2VibQBpbWFnZS93ZWJwAGZvbnQvd29mZgBmb250L3dvZmYyAGFwcGxp
Y2F0aW9uL3dzZGwreG1sAGFwcGxpY2F0aW9uL3hodG1sK3htbABhcHBsaWNhdGlvbi92bmQubXMt
ZXhjZWwAYXBwbGljYXRpb24veG1sAGFwcGxpY2F0aW9uL3hzbHQreG1sAGFwcGxpY2F0aW9uL3gt
eHoAYXBwbGljYXRpb24vemxpYgBhcHBsaWNhdGlvbi96aXAAYXBwbGljYXRpb24venN0ZAAPH4AA
AAAAaW5mbGF0ZSgp4oaSJWQgZG49JWxkIHNuPSVsZCBuZXh0X2luPSVsZCBhdmFpbF9pbj0lbGQg
bmV4dF9vdXQ9JWxkIGF2YWlsX291dD0lbGQAAAAAAAAAAGNvcnJ1cHQgemlwIGZpbGUgYXQgJWAn
LipzIGhhZCBjcmMgMHglMDh4IGJ1dCBleHBlY3RlZCAweCUwOHgAAAA8aW1nIGFsdD0iW2xvZ29d
IiBzcmM9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwAAAA8L3RpdGxlPg0KPHN0eWxlPg0KaHRtbCB7
IGNvbG9yOiAjMTExOyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgfQ0KaW1nIHsgdmVydGljYWwt
YWxpZ246IG1pZGRsZTsgfQ0KPC9zdHlsZT4NCjxoMT4NCgAAAABIVFRQLzEuMSA0MDggUmVxdWVz
dCBUaW1lb3V0DQpDb25uZWN0aW9uOiBjbG9zZQ0KQ29udGVudC1MZW5ndGg6IDANCg0KAABIVFRQ
LzEuMSA1MDMgU2VydmljZSBVbmF2YWlsYWJsZQ0KQ29ubmVjdGlvbjogY2xvc2UNCkNvbnRlbnQt
TGVuZ3RoOiAwDQoNCgAAAAAAAHJlZGJlYW4gaXMgbWVsdGluZyBkb3duICglLGQgd29ya2VycykA
AABSRUFEMzJMRSh6Y2RpcikgPT0ga1ppcENkaXI2NEhkck1hZ2ljIHx8IFJFQUQzMkxFKHpjZGly
KSA9PSBrWmlwQ2Rpckhkck1hZ2ljAAAAAGRvbid0IHVuZGVyc3RhbmQgemlwIGNvbXByZXNzaW9u
IG1ldGhvZCAlZCB1c2VkIGJ5ICVgJy4qcwAAAAAAAABtdW5tYXAoem1hcCwgemJhc2UgKyB6c2l6
ZSAtIHptYXApAAAAAAAASXNaaXBDZGlyMzIoemJhc2UsIHpzaXplLCB6Y2RpciAtIHpiYXNlKSB8
fCBJc1ppcENkaXI2NCh6YmFzZSwgenNpemUsIHpjZGlyIC0gemJhc2UpAAAAAGNvdWxkbid0IGxv
Y2F0ZSBjZW50cmFsIGRpcmVjdG9yeQAAAAAAAABlcnJvcjogdW5zdXBwb3J0ZWQgcmVkaXJlY3Qg
Y29kZSAlZAoAAAAAZXJyb3I6IGJyYW5kIGlzbid0IGxhdGluMSBlbmNvZGFibGU6ICVgJ3MAAAAA
AAAAZXJyb3I6IGNhbid0IHByb2dyYW0gaGVhZGVyOiAlYCdzCgAAAAAAAHNldHNvY2tvcHQoc2Vy
dmVyLCAlcywgJXMsICVkKSBmYWlsZWQgJXMAAAAAAAAAAGVycm9yOiAlczogJWhodS4laGh1LiVo
aHUuJWhodTolaHUKAAAAAABMSVNURU4gaHR0cDovLyVoaHUuJWhodS4laGh1LiVoaHU6JWQAAAAA
b3BlbmluZyBicm93c2VyIHdpdGggY29tbWFuZCAlcyAlcwoAAAAAAGNhbid0IGxhdW5jaCBicm93
c2VyIGJlY2F1c2UgJXMgaXNuJ3QgaW5zdGFsbGVkACVkIGV4aXRlZCB3aXRoICVkICglLGQgd29y
a2VycyByZW1haW4pAAAlZCBleGl0ZWQgKCUsZCB3b3JrZXJzIHJlbWFpbikAACVkIHRlcm1pbmF0
ZWQgd2l0aCAlcyAoJSxkIHdvcmtlcnMgcmVtYWluKQAAAAAAAG5lZWRlZCAlLGxkwrVzIGNwdSAo
JWQlJSBrZXJuZWwpJXMAAAAAAABuZWVkZWQgJSxsZGtiIG1lbW9yeSBvbiBhdmVyYWdlJXMAAAAA
AAAAbmVlZGVkICUsbGRrYiBzdGFjayBvbiBhdmVyYWdlJXMAAAAAAAAAAG1hcHBlZCAlLGxka2Ig
c2hhcmVkIG9uIGF2ZXJhZ2UlcwAAAAAAAABjYXVzZWQgJSxsZCBwYWdlIGZhdWx0cyAoJWQlJSBt
ZW1jcHkpJXMAJSxsZCBjb250ZXh0IHN3aXRjaGVzICglZCUlIGNvbnNlbnN1YWwpJXMAAAAAAAAA
cmVjZWl2ZWQgJSxsZCBtZXNzYWdlJXMgYW5kIHNlbnQgJSxsZCVzAHBlcmZvcm1lZCAlLGxkIHJl
YWQlcyBhbmQgJSxsZCB3cml0ZSBpL28gb3BlcmF0aW9ucyVzAAAAcmVkYmVhbiBzaGFsbCB0ZXJt
aW5hdGUgaGFyZGVyAABTZXJ2ZUFzc2V0RGVjb21wcmVzc2VkKCVsZCkgLT4gJWxkAAAAAAAAZGVm
bGF0ZUluaXQyKG1lbXNldCgmenMsIDAsIHNpemVvZih6cykpLCA0LCBaX0RFRkxBVEVELCAtTUFY
X1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpAAA8IWRvY3R5cGUgaHRt
bD4NCjxtZXRhIGNoYXJzZXQ9InV0Zi04Ij4NCjx0aXRsZT5yZWRiZWFuIHppcCBsaXN0aW5nPC90
aXRsZT4NCjxzdHlsZT4NCmh0bWwgeyBjb2xvcjogIzExMTsgZm9udC1mYW1pbHk6IHNhbnMtc2Vy
aWY7IH0NCmEgeyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH0NCnByZSBhOmhvdmVyIHsgY29sb3I6
ICMwMGU7IGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjOyB9DQpoMSBhIHsgY29sb3I6ICMx
MTE7IH0NCmltZyB7IHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH0NCmZvb3RlciB7IGNvbG9yOiAj
NTU1OyBmb250LXNpemU6IDEwcHQ7IH0NCnRkIHsgcGFkZGluZy1yaWdodDogM2VtOyB9DQouZW9j
ZGNvbW1lbnQgeyBtYXgtd2lkdGg6IDgwMHB4OyBjb2xvcjogIzMzMzsgZm9udC1zaXplOiAxMXB0
OyB9DQo8L3N0eWxlPg0KPGhlYWRlcj48aDE+DQoAAAAAAAAAPC9oMT4NCjxkaXYgY2xhc3M9ImVv
Y2Rjb21tZW50Ij4lLipzPC9kaXY+DQo8aHI+DQo8L2hlYWRlcj4NCjxwcmU+DQoAAAAAPGEgaHJl
Zj0iJS4qcyI+JS0qLipzPC9hPiAlcyAgJTAqbyAlNHMgICUsKmxkICAlJ3MNCgAAAAAlLSouKnMg
JXMgICUwKm8gJTRzICAlLCpsZCAgJSdzDQoAAAAAAAAAPGEgaHJlZj0iL3N0YXR1c3oiPi9zdGF0
dXN6PC9hPg0KAAAAAAAAACVzJSxsZCBzZWNvbmQlcyBvZiBvcGVyYXRpb248YnI+DQoAAAAAAAAl
LGxkIGNvbm5lY3Rpb24lcyBoYW5kbGVkPGJyPg0KACUsbGQgY29ubmVjdGlvbiVzIGFjdGl2ZTxi
cj4NCgAAYXNzZXQgJWAnLipzICUjbyBpc24ndCByZWFkYWJsZQBkaXJlY3RvcnkgJWAnLipzIGxh
Y2tzIGluZGV4IHBhZ2UAAAAAAAAAbXVubWFwKHVubWFwbGlzdC5wW3VubWFwbGlzdC5uXS5wLCB1
bm1hcGxpc3QucFt1bm1hcGxpc3Qubl0ubikAAGNsb3NlKHVubWFwbGlzdC5wW3VubWFwbGlzdC5u
XS5mKQAAAAAAAABlcnJvcjogdGltZW91dCBuZWVkcyB0byBiZSAzMW1zIG9yIGdyZWF0ZXIKAAAA
AABlcnJvcjogcmVkaXJlY3QgYXJnIG1pc3NpbmcgJz0nCgAAAAAAAAAAYXpoZHVndlZzbWJmeWw6
cDpyOlI6SDpjOkw6UDpVOkc6QkQ6dDpNOkM6SzpGOgAARkFJTFVSRSAlZCAlcyAlcyBIVFRQJTAy
ZCAlLipzICVgJy4qcyAlYCcuKnMgJWAnLipzICVgJy4qcwAAAAAAACVzICVzIHdpdGggJSxsZCB1
bnByb2Nlc3NlZCBhbmQgJSxkIGhhbmRsZWQgKCUsZCB3b3JrZXJzKQAAAAAAAAAlcyAlcyB3aXRo
ICUsZCByZXF1ZXN0cyBoYW5kbGVkACVzIGZyYWdnZWQgbXNnIGFkZGVkICUsbGQgYnl0ZXMgdG8g
JSxsZCBieXRlIGJ1ZmZlcgAAAAAAYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkAAAA
AAAAAFJFQ0VJVkVEICVzIEhUVFAlMDJkICUuKnMgJXMgJWAnLipzICVgJy4qcwAAAAAAAGNvdWxk
IG5vdCBzeW5jaHJvbml6ZSBtZXNzYWdlIHN0cmVhbQAAAAAlcyB3YW50cyBTU0wgYnV0IHJlZGJl
YW4gd2FzIGNvbXBpbGVkIHdpdGggLURVTlNFQ1VSRQAAACVzIGNvbm5lY3Rpb24gcmVzZXQgYmVm
b3JlIGFjY2VwdAAAAAAAAAAoc2hhcmVkID0gbW1hcChOVUxMLCBST1VORFVQKHNpemVvZihzdHJ1
Y3QgU2hhcmVkKSwgRlJBTUVTSVpFKSwgUFJPVF9SRUFEIHwgUFJPVF9XUklURSwgTUFQX1NIQVJF
RCB8IE1BUF9BTk9OWU1PVVMsIC0xLCAwKSkAZi4PH4QAAAAAAGaQ2aJAAAAAAADZokAAAAAAAJ2i
QAAAAAAA2aJAAAAAAADZokAAAAAAANmiQAAAAAAA2aJAAAAAAADZokAAAAAAANmiQAAAAAAA2aJA
AAAAAADZokAAAAAAANmiQAAAAAAA2aJAAAAAAADZokAAAAAAANmiQAAAAAAA2aJAAAAAAADZokAA
AAAAANmiQAAAAAAA2aJAAAAAAADZokAAAAAAANmiQAAAAAAA2aJAAAAAAADZokAAAAAAAJ2iQAAA
AAAA2aJAAAAAAADZokAAAAAAAJ2iQAAAAAAAwKJAAAAAAADZokAAAAAAAJ2iQAAAAAAA2aJAAAAA
AADZokAAAAAAANmiQAAAAAAAnaJAAAAAAAD+2kAAAAAAAPPcQAAAAAAA8NtAAAAAAADz3EAAAAAA
APPcQAAAAAAAytxAAAAAAAB83EAAAAAAAPPcQAAAAAAA89xAAAAAAADz3EAAAAAAAI3cQAAAAAAA
R9xAAAAAAADz3EAAAAAAAPPcQAAAAAAAoNxAAAAAAADz3EAAAAAAANrbQAAAAAAA89xAAAAAAADz
3EAAAAAAALPcQAAAAAAANdtAAAAAAADz3EAAAAAAAPPcQAAAAAAA89xAAAAAAADz3EAAAAAAAPPc
QAAAAAAA89xAAAAAAADz3EAAAAAAAPPcQAAAAAAA89xAAAAAAADz3EAAAAAAAFDbQAAAAAAAdNtA
AAAAAAAB3EAAAAAAAEfbQAAAAAAA89xAAAAAAACJ20AAAAAAAGLbQAAAAAAA4dxAAAAAAADz3EAA
AAAAAPPcQAAAAAAAldtAAAAAAABr3EAAAAAAAGvbQAAAAAAA89xAAAAAAADz3EAAAAAAACTcQAAA
AAAA89xAAAAAAADE20AAAAAAAD7bQAAAAAAAodtAAAAAAABZ20AAAAAAACzbQAAAAAAA89xAAAAA
AADz3EAAAAAAAP7aQAAAAAAAfdtAAAAAAAAg70AAAAAAACDvQAAAAAAAsO5AAAAAAAAn70AAAAAA
ALfuQAAAAAAAvu5AAAAAAADF7kAAAAAAAMzuQAAAAAAA0+5AAAAAAADa7kAAAAAAAOHuQAAAAAAA
6O5AAAAAAADv7kAAAAAAAPbuQAAAAAAA/e5AAAAAAAAE70AAAAAAAAvvQAAAAAAAEu9AAAAAAAAg
70AAAAAAABnvQAAAAAAAAAAAAAAAAABhY2NlcHRlcnJvcnMAYWNjZXB0aW50ZXJydXB0cwBhY2Nl
cHRyZXNldHMAYmFkbGVuZ3RocwBiYWRtZXNzYWdlcwBiYWRtZXRob2RzAGJhZHJhbmdlcwBjbG9z
ZWVycm9ycwBjb21wcmVzc2VkcmVzcG9uc2VzAGNvbm5lY3Rpb25zaGFuZGxlZABjb25uZWN0c3Jl
ZnVzZWQAY29udGludWVzAGRlY29tcHJlc3NlZHJlc3BvbnNlcwBkZWZsYXRlcwBkcm9wcGVkAGR5
bmFtaWNyZXF1ZXN0cwBlbWZpbGVzAGVuZXRkb3ducwBlbmZpbGVzAGVub2J1ZnMAZW5vbWVtcwBl
bm9uZXRzAGVycm9ycwBleHBlY3RzcmVmdXNlZABmYWlsZWRjaGlsZHJlbgBmb3JiaWRkZW5zAGZv
cmtlcnJvcnMAZnJhZ3MAZnVtYmxlcwBoYW5kc2hha2VpbnRlcnJ1cHRzAGh0dHAwOQBodHRwMTAA
aHR0cDExAGh0dHAxMgBodWdlcGF5bG9hZHMAaWRlbnRpdHlyZXNwb25zZXMAaW5mbGF0ZXMAbGlz
dGluZ3JlcXVlc3RzAGxvb3BzAG1hcGZhaWxzAG1hcHMAbWVsdGRvd25zAG1lc3NhZ2VzaGFuZGxl
ZABtaXNzaW5nbGVuZ3RocwBuZXRhZnJpbmljAG5ldGFub255bW91cwBuZXRhcG5pYwBuZXRhcHBs
ZQBuZXRhcmluAG5ldGF0dABuZXRjb2dlbnQAbmV0Y29tY2FzdABuZXRkb2QAbmV0Zm9yZABuZXRs
YWNuaWMAbmV0bG9vcGJhY2sAbmV0b3RoZXIAbmV0cHJpdmF0ZQBuZXRwcnVkZW50aWFsAG5ldHJp
cGUAbmV0dGVzdG5ldABuZXR1c3BzAG5vdGZvdW5kcwBub3Rtb2RpZmllZHMAb3BlbmZhaWxzAHBh
cnRpYWxyZXNwb25zZXMAcGF5bG9hZGRpc2Nvbm5lY3RzAHBpcGVsaW5lZHJlcXVlc3RzAHBvbGxp
bnRlcnJ1cHRzAHByZWNvbXByZXNzZWRyZXNwb25zZXMAcmVhZGVycm9ycwByZWFkaW50ZXJydXB0
cwByZWFkcmVzZXRzAHJlYWR0aW1lb3V0cwByZWRpcmVjdHMAcmVpbmRleGVzAHJlbG9hZHMAcmV3
cml0ZXMAc2VydmVyb3B0aW9ucwBzaHV0ZG93bnMAc2xvd2xvcmlzAHNsdXJwcwBzc2xjYW50Y2lw
aGVycwBzc2xoYW5kc2hha2VmYWlscwBzc2xoYW5kc2hha2VzAHNzbG5vY2lwaGVycwBzc2xub3Zl
cnNpb24Ac3Nsc2hha2VtYWNzAHNzbHRpbWVvdXRzAHNzbHVua25vd25jYQBzc2x1bmtub3duY2Vy
dABzc2x1cGdyYWRlcwBzdGF0ZmFpbHMAc3RhdGljcmVxdWVzdHMAc3RhdHMAc3RhdHVzenJlcXVl
c3RzAHN5bmNocm9uaXphdGlvbmZhaWx1cmVzAHRlcm1pbmF0ZWRjaGlsZHJlbgB0aGlzY29ycnVw
dGlvbgB0cmFuc2ZlcnNyZWZ1c2VkAHVyaXNyZWZ1c2VkAHZlcmlmaWVzAHdyaXRlZXJyb3JzAHdy
aXRlaW50ZXJydXB1dHMAd3JpdGVyZXNldHMAd3JpdGV0aW1lb3V0cwAAAAAAAAAAADd6AAAAAAAA
JHFDAAAAAABhYWMAAAAAAEBxQwAAAAAAYXBuZwAAAABKcUMAAAAAAGF0b20AAAAAVXFDAAAAAABh
dmkAAAAAAGpxQwAAAAAAYXZpZgAAAAB6cUMAAAAAAGF6dwAAAAAAhXFDAAAAAABibXAAAAAAAKJx
QwAAAAAAYnoyAAAAAACscUMAAAAAAGMAAAAAAAAA4mtDAAAAAABjYwAAAAAAAOJrQwAAAAAAY3Nz
AAAAAADAcUMAAAAAAGNzdgAAAAAAyXFDAAAAAABkb2MAAAAAANJxQwAAAAAAZXB1YgAAAADlcUMA
AAAAAGdpZgAAAAAA+nFDAAAAAABnegAAAAAAAARyQwAAAAAAaAAAAAAAAADia0MAAAAAAGh0bQAA
AAAAqGtDAAAAAABodG1sAAAAAKhrQwAAAAAAaQAAAAAAAADia0MAAAAAAGljbwAAAAAAFXJDAAAA
AABqYXIAAAAAAC5yQwAAAAAAanBlZwAAAABHckMAAAAAAGpwZwAAAAAAR3JDAAAAAABqcwAAAAAA
AFJyQwAAAAAAanNvbgAAAABickMAAAAAAG00YQAAAAAAc3JDAAAAAABtYXJrZG93buJrQwAAAAAA
bWQAAAAAAADia0MAAAAAAG1pZAAAAAAAfnJDAAAAAABtaWRpAAAAAH5yQwAAAAAAbXAyAAAAAABz
ckMAAAAAAG1wMwAAAAAAc3JDAAAAAABtcDQAAAAAAIlyQwAAAAAAbXBlZwAAAACTckMAAAAAAG1w
ZwAAAAAAk3JDAAAAAABvZ2EAAAAAAJ5yQwAAAAAAb2dnAAAAAACockMAAAAAAG9ndgAAAAAAuHJD
AAAAAABvZ3gAAAAAAKhyQwAAAAAAb3RmAAAAAADCckMAAAAAAHBkZgAAAAAAy3JDAAAAAABwbmcA
AAAAANtyQwAAAAAAcmFyAAAAAADlckMAAAAAAHJ0ZgAAAAAA+XJDAAAAAABzAAAAAAAAAOJrQwAA
AAAAc2gAAAAAAAAJc0MAAAAAAHNxbGl0ZQAAGnNDAAAAAABzcWxpdGUzABpzQwAAAAAAc3ZnAAAA
AAAyc0MAAAAAAHN3ZgAAAAAAQHNDAAAAAAB0MzgAAAAAAF5zQwAAAAAAdGFyAAAAAABoc0MAAAAA
AHRpZmYAAAAAenNDAAAAAAB0dGYAAAAAAIVzQwAAAAAAdHh0AAAAAADia0MAAAAAAHVsAAAAAAAA
jnNDAAAAAAB1bGF3AAAAAI5zQwAAAAAAd2FzbQAAAACac0MAAAAAAHdhdgAAAAAAq3NDAAAAAAB3
ZWJhAAAAALdzQwAAAAAAd2VibQAAAADCc0MAAAAAAHdlYnAAAAAAzXNDAAAAAAB3b2ZmAAAAANhz
QwAAAAAAd29mZjIAAADic0MAAAAAAHdzZGwAAAAA7XNDAAAAAAB4aHRtbAAAAAJ0QwAAAAAAeGxz
AAAAAAAYdEMAAAAAAHhtbAAAAAAAMXRDAAAAAAB4c2wAAAAAAEF0QwAAAAAAeHNsdAAAAABBdEMA
AAAAAHh6AAAAAAAAVnRDAAAAAAB6AAAAAAAAAGd0QwAAAAAAemlwAAAAAAB4dEMAAAAAAHpzdAAA
AAAAiHRDAAAAAAAfiwgAAAAAAAADZpAAAABAACR0SQAAyEIAAGFFAAAAPwAAAAAAADBDAAAAAAAA
8D8AAAAAAABZQP///////98//////////38AAAAAAAAAAAAAAAAAAACAAAAAAAAAAAA6IGlsbGVn
YWwgb3B0aW9uIC0tIAAlcyVzJWMKAA8fADogb3B0aW9uIHJlcXVpcmVzIGFuIGFyZ3VtZW50IC0t
IABmDx9EAABBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3
eHl6MDEyMzQ1Njc4OSsvAA8fgAAAAADLEkEAAAAAAAQTQQAAAAAABBNBAAAAAAAEE0EAAAAAAGYS
QQAAAAAA6BJBAAAAAAAEE0EAAAAAAAQTQQAAAAAABBNBAAAAAAAEE0EAAAAAAAQTQQAAAAAABBNB
AAAAAAAEE0EAAAAAAAQTQQAAAAAABBNBAAAAAAAEE0EAAAAAAAQTQQAAAAAABBNBAAAAAAAEE0EA
AAAAAAQTQQAAAAAABBNBAAAAAAAEE0EAAAAAAAQTQQAAAAAABBNBAAAAAAAEE0EAAAAAAAQTQQAA
AAAAoRJBAAAAAAAEE0EAAAAAALYSQQAAAAAAMDEyMzQ1Njc4OUFCQ0RFRgBmLg8fhAAAAAAAZi4P
H4QAAAAAAA8fAIaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhhSG
hoaGhoaGAIaGhoaGhoaGhoaGAIYUXwUKRg8ehgUPFABLKIYjFAAyGR4AHoaGhoaGhoYAhhRfBQpG
Dx6GBQ8UAEsohiMUADIZHgAehoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaG
hoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaG
hoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhobt40MAAAAAAADt40MAAAAAAADt
40MAAAAAAADt40MAAAAAAADt40MAAAAAAADt40MAAAAAAAAWl0MAAAAAAAMOoUMAAAAAAEKUl0MA
AAAAACzt40MAAAAAAADt40MAAAAAAAAdl0MAAAAAADTt40MAAAAAAAB8mUMAAAAAAC0kl0MAAAAA
ACLt40MAAAAAAAAzl0MAAAAAAE9El0MAAAAAABTt40MAAAAAAABtl0MAAAAAAABRl0MAAAAAAARh
l0MAAAAAABLt40MAAAAAAACcmkMAAAAAADtyl0MAAAAAADp3l0MAAAAAADmCl0MAAAAAACeYl0MA
AAAAAE2gl0MAAAAAAEmkl0MAAAAAABW2mEMAAAAAAAL/l0MAAAAAAAyul0MAAAAAABy2l0MAAAAA
AFDEl0MAAAAAAA/Jl0MAAAAAACDPl0MAAAAAABHgl0MAAAAAAC7tl0MAAAAAACHt40MAAAAAAAD7
l0MAAAAAAFEGmEMAAAAAADEXmEMAAAAAAEMfmEMAAAAAADcomEMAAAAAAC8imEMAAAAAABY8mEMA
AAAAAAtDmEMAAAAAAA5LmEMAAAAAAAFZmEMAAAAAACn4mkMAAAAAACt3mEMAAAAAAEjt40MAAAAA
AACImEMAAAAAADWRmEMAAAAAABegmEMAAAAAAAiwmEMAAAAAAD/BmEMAAAAAABDTmEMAAAAAADbh
mEMAAAAAABnmmEMAAAAAAAbxmEMAAAAAABv4mEMAAAAAAEUAmUMAAAAAACQdmUMAAAAAADjt40MA
AAAAAAAxmUMAAAAAAEA4mUMAAAAAABhFmUMAAAAAACVimUMAAAAAADDt40MAAAAAAADt40MAAAAA
AAAYm0MAAAAAACPt40MAAAAAAAB2mUMAAAAAAD6KmUMAAAAAAEvt40MAAAAAAACamUMAAAAAAAei
mUMAAAAAAD21mUMAAAAAAB/t40MAAAAAAABFmkMAAAAAAAm6mUMAAAAAAEzRmUMAAAAAAEbt40MA
AAAAAADt40MAAAAAAADVmUMAAAAAAEHhmUMAAAAAADzt40MAAAAAAADt40MAAAAAAADt40MAAAAA
AADt40MAAAAAAADumUMAAAAAAETt40MAAAAAAADt40MAAAAAAADt40MAAAAAAADt40MAAAAAAAAA
mkMAAAAAABMSmkMAAAAAAA3t40MAAAAAAAAWmkMAAAAAAArt40MAAAAAAAAwmkMAAAAAACbt40MA
AAAAAABMmkMAAAAAABpRmkMAAAAAAAVhmkMAAAAAAB1ymkMAAAAAAEft40MAAAAAAADt40MAAAAA
AAB6mkMAAAAAAEqUmkMAAAAAADLt40MAAAAAAADt40MAAAAAAADt40MAAAAAAADt40MAAAAAAACl
mkMAAAAAACjt40MAAAAAAADt40MAAAAAAADt40MAAAAAAAC7mkMAAAAAAE7t40MAAAAAAADt40MA
AAAAAADt40MAAAAAAADLmkMAAAAAACrt40MAAAAAAADpmkMAAAAAADPt40MAAAAAAADt40MAAAAA
AADt40MAAAAAAADt40MAAAAAAADt40MAAAAAAADt40MAAAAAAACSbEMAAAAAAB5BY2NlcHQARXhw
ZWN0AEFjY2VwdC1DaGFyc2V0AFgtWFNTLVByb3RlY3Rpb24AWC1DU1JGLVRva2VuAEFjY2VwdC1M
YW5ndWFnZQBYLUZvcndhcmRlZC1Ib3N0AExpbmsAS2VlcC1BbGl2ZQBBY2Nlc3MtQ29udHJvbC1N
YXhBZ2UAQWx0LVN2YwBWaWEAU2F2ZS1EYXRhAEV4cGlyZXMAQWNjZXB0LVJhbmdlcwBGcm9tAEFs
bG93AFgtUmVxdWVzdGVkLVdpdGgAQ29udGVudC1CYXNlAENvbnRlbnQtUmFuZ2UAU2V0LUNvb2tp
ZQBDb250ZW50LUxhbmd1YWdlAFRyYWlsZXIASWYtUmFuZ2UAQ29udGVudC1EZXNjcmlwdGlvbgBQ
cmFnbWEAU2VjLUdQQwBDYWNoZS1Db250cm9sAEFjY2Vzcy1Db250cm9sLVJlcXVlc3RIZWFkZXJz
AFdXVy1BdXRoZW50aWNhdGUASWYtTWF0Y2gAQ29udGVudC1MZW5ndGgAWC1Gb3J3YXJkZWQtRm9y
AFByb3h5LUNvbm5lY3Rpb24ASWYtTW9kaWZpZWQtU2luY2UASWYtTm9uZS1NYXRjaABWYXJ5AFVz
ZXItQWdlbnQAU2VydmVyAFVwZ3JhZGUAQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycwBJZi1V
bm1vZGlmaWVkLVNpbmNlAFB1YmxpYwBDb250ZW50LVR5cGUAQWNjZXNzLUNvbnRyb2wtQWxsb3ct
TWV0aG9kcwBDb250ZW50LURpc3Bvc2l0aW9uAFByb3h5LUF1dGhvcml6YXRpb24AWC1GcmFtZS1P
cHRpb25zAFJlZmVyZXIAUHJveHktQXV0aGVudGljYXRlAEVUYWcAWC1Db250ZW50LVR5cGUtT3B0
aW9ucwBVcmkAUmV0cnktQWZ0ZXIATWF4LUZvcndhcmRzAFRyYW5zZmVyLUVuY29kaW5nAFgtRm9y
d2FyZGVkLVByb3RvAEROVABVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzAEFjY2Vzcy1Db250cm9s
LUFsbG93LU9yaWdpbgBEYXRlAEFjY2VwdC1FbmNvZGluZwBDb250ZW50LUVuY29kaW5nAFdhcm5p
bmcAU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eQBDb250ZW50LUxvY2F0aW9uAEFjY2Vzcy1Db250
cm9sLU1ldGhvZABSZWZlcnJlci1Qb2xpY3kAQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2QA
Q29udGVudC1NRDUADx8AQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2RzAABBY2Nlc3MtQ29u
dHJvbC1BbGxvdy1DcmVkZW50aWFscwBDb250aW51ZQBTd2l0Y2hpbmcgUHJvdG9jb2xzAFByb2Nl
c3NpbmcAQ3JlYXRlZABBY2NlcHRlZABOb24tYXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbgBObyBD
b250ZW50AFJlc2V0IENvbnRlbnQATXVsdGktU3RhdHVzAEFscmVhZHkgUmVwb3J0ZWQASU0gVXNl
ZABNdWx0aXBsZSBDaG9pY2VzAE1vdmVkIFBlcm1hbmVudGx5AFNlZSBPdGhlcgBVc2UgUHJveHkA
UGVybWFuZW50IFJlZGlyZWN0AFVuYXV0aG9yaXplZABQYXltZW50IFJlcXVpcmVkAE5vdCBBY2Nl
cHRhYmxlAFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkAENvbmZsaWN0AEdvbmUAUHJlY29u
ZGl0aW9uIEZhaWxlZABSZXF1ZXN0LVVSSSBUb28gTG9uZwBVbnN1cHBvcnRlZCBNZWRpYSBUeXBl
AEknbSBhIHRlYXBvdABNaXNkaXJlY3RlZCBSZXF1ZXN0AFVucHJvY2Vzc2FibGUgRW50aXR5AExv
Y2tlZABGYWlsZWQgRGVwZW5kZW5jeQBVcGdyYWRlIFJlcXVpcmVkAFByZWNvbmRpdGlvbiBSZXF1
aXJlZABUb28gTWFueSBSZXF1ZXN0cwBVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29ucwBDbGll
bnQgQ2xvc2VkIFJlcXVlc3QAQmFkIEdhdGV3YXkAR2F0ZXdheSBUaW1lb3V0AFZhcmlhbnQgQWxz
byBOZWdvdGlhdGVzAEluc3VmZmljaWVudCBTdG9yYWdlAE5vdCBFeHRlbmRlZABOZXR3b3JrIENv
bm5lY3QgVGltZW91dCBFcnJvcgBmDx9EAABSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxl
AFJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2UAQ29ubmVjdGlvbiBDbG9zZWQgV2l0aG91
dCBSZXNwb25zZQAAAAAAAE5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWQAZi4PH4QAAAAA
AGYPH0QAAGQAOZtDAAAAAABlAEKbQwAAAAAAZgBWm0MAAAAAAMgAHGVDAAAAAADJAGGbQwAAAAAA
ygBpm0MAAAAAAMsAcptDAAAAAADMAJCbQwAAAAAAzQCbm0MAAAAAAM4A/2tDAAAAAADPAKmbQwAA
AAAA0AC2m0MAAAAAAOIAx5tDAAAAAAAsAc+bQwAAAAAALQHgm0MAAAAAAC4BdW1DAAAAAAAvAfKb
QwAAAAAAMAE2bEMAAAAAADEB/JtDAAAAAAAzAV5pQwAAAAAANAEGnEMAAAAAAJABQG5DAAAAAACR
ARmcQwAAAAAAkgEmnEMAAAAAAJMBAW1DAAAAAACUAXFtQwAAAAAAlQEKZkMAAAAAAJYBN5xDAAAA
AACXAUacQwAAAAAAmAEdbkMAAAAAAJkBZJxDAAAAAACaAW2cQwAAAAAAmwHGbUMAAAAAAJwBcpxD
AAAAAACdAdZtQwAAAAAAngGGnEMAAAAAAJ8Bm5xDAAAAAACgAeidQwAAAAAAoQH4bUMAAAAAAKIB
spxDAAAAAAClAb+cQwAAAAAApgHTnEMAAAAAAKcB6JxDAAAAAACoAe+cQwAAAAAAqgEBnUMAAAAA
AKwBEp1DAAAAAACtASidQwAAAAAArwEInkMAAAAAALwBKJ5DAAAAAADDATqdQwAAAAAA8wFYnUMA
AAAAAPQBUWdDAAAAAAD1AehtQwAAAAAA9gFunUMAAAAAAPcBPWdDAAAAAAD4AXqdQwAAAAAA+QHA
bEMAAAAAAPoBip1DAAAAAAD7AaKdQwAAAAAA/AGybEMAAAAAAP4Bt51DAAAAAAD/AVCeQwAAAAAA
VwLEnUMAAAAAAE1VTFRJQ0FTVABMT09QQkFDSwBQUklWQVRFAFRFU1RORVQAQUZSSU5JQwBMQUNO
SUMAQVBOSUMAQVJJTgBSSVBFAERPRABBVCZUAEFQUExFAEZPUkQAQ09HRU5UAFBSVURFTlRJQUwA
VVNQUwBDT01DQVNUAEZVVFVSRQBBTk9OWU1PVVMADx9AAPagQwAAAAAAAKFDAAAAAAAJoUMAAAAA
ABGhQwAAAAAAGaFDAAAAAAAhoUMAAAAAACihQwAAAAAALqFDAAAAAAAzoUMAAAAAADihQwAAAAAA
PKFDAAAAAABBoUMAAAAAAEehQwAAAAAATKFDAAAAAABToUMAAAAAAF6hQwAAAAAAY6FDAAAAAABr
oUMAAAAAAHKhQwAAAAAAbmV0L2h0dHAvaGVhZGVyaGFzc3Vic3RyaW5nLmMAMCA8PSBoICYmIGgg
PCBrSHR0cEhlYWRlcnNNYXgAZi4PH4QAAAAAAGaQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAQAAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQAAAAABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQABAAAAAAAAAAAAAQAAAAAAAAAA
AAABAAEAAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAAEAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEAAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAQEBAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAAEAAAAAAAAAAAABAAAAAAAAAAAA
AAAAAQABAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEAAQAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQABAQAAAQAAAAAAAAAAAAABAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAABAQEBAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAA
AAABAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQABAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAABAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB////////////////////////////////////////
////////////////////////AAECAwQFBgcICf////////8KCwwNDg//////////////////////
/////////////woLDA0OD///////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////wAB
AAEBAQAAAAAAAQAAAAAAAAAAAAAAAAABAAAAAQAAAQABAAEBAAAAAQABAAAAAAABAAABAQEAAAAA
AAABAAABAAEBAQEBAQEBAAAAAAAAAABmLg8fhAAAAAAADx9AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAABAAEAAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAABuZXQvaHR0cC9wYXJzZWh0dHBtZXNzYWdlLmMADx9AAHR5cGUgPT0ga0h0dHBSZXF1
ZXN0IHx8IHR5cGUgPT0ga0h0dHBSZXNwb25zZQBmkMonQQAAAAAAcihBAAAAAAAFKUEAAAAAAEQp
QQAAAAAAOSpBAAAAAAAoK0EAAAAAAAcsQQAAAAAALyxBAAAAAABMLUEAAAAAAF8rQQAAAAAAoStB
AAAAAACPLUEAAAAAAGJ5dGVzPQAwMTIzNDU2Nzg5YWJjZGVmAGYuDx+EAAAAAABmLg8fhAAAAAAA
Dx9AABoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa
GhoaGhoaGhoaGhoaABoFDwAaBQAaGgoPCgAFABoKGgUAGhoaGhoaGhoaGhoAGgUPABoFABoaCg8K
AAUAGgoaBQAaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa
GhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa
GhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AABQVVQAAAAAAARIRUFEAAAAAAJQQVRDSAAAAA9VTkxPQ0sAABEAAAAAAAAAAABHRVQAAAAAAAFQ
T1NUAAAAAAMAAAAAAAAAAABOT1RJRlkAAA5PUFRJT05TAAYAAAAAAAAAAABDT1BZAAAAAAlNRVJH
RQAAAAtSRVBPUlQAABBDT05ORUNUAAcAAAAAAAAAAABNT1ZFAAAAAA1UUkFDRQAAAAhERUxFVEUA
AAUAAAAAAAAAAAAAAAAAAAAAAABMT0NLAAAAAApNS0NPTAAAAAwbWzBtACBcABtbMzVtAAklcw0K
CSVzJXMlcyVzDQoACQklcyVzDQoAZg8fRAAAY2hlY2sgZmFpbGVkIG9uICVzIHBpZCAlZA0KCUNI
RUNLXyVzKCVzLCAlcyk7DQoJCSDihpIgJSNseCAoJXMpDQoJCSVzICUjbHggKCVzKQ0KADogAA0b
W0oAG1szMDsxMDFtABtbOTQ7NDltAEZFV0lWRFlaAC0tLS0tLS0tLS0tLS0tLS0tLS0tACVZLSVt
LSVkVCVIOiVNOiVTLgAlYyVzJTA2bGQ6JXM6JWQ6JS4qczolZF0gAGZhdGFsaXR5ICVzIHBpZCAl
ZAoADx9AAHBlcmZvcm1lZCBlbWVyZ2VuY3kgbG9nIHRydW5jYXRpb246ICVzCgAoa25OYWRkcjJs
aW5lAC1hAC1wQ2lmZQAgKGRpc2NyaW1pbmF0b3IgAERPTlRBTlNJTUVCUk8APz8/AFhNTQAgU0YA
IEMwACBDMQAgQzIAIEMzACUtM3MgJTAxNmx4ACAlcyglenUpICVMZwAvcHJvYy9zZWxmL21hcHMA
G1s5MTsxbQAgICVzICVzICVzICVzDQoADx9AACVzJS0yenUgJTAxNmx4JTAxNmx4ICVzJS0yZCAl
MDE2bHglMDE2bHgNCgAAAAAAAA0KJXNlcnJvciVzOiBVbmNhdWdodCBTSUclcyBvbiAlcw0KICAl
cw0KICAlcw0KAFFVSVQARlBFAABJTEwAAFNFR1YAVFJBUABBQlJUAEJVUwAAAAAAAABJRFpPVVBD
VlBSQUtaU1RJRE9SOAAAUjkAAFIxMABSMTEAUjEyAFIxMwBSMTQAUjE1AFJESQBSU0kAUkJQAFJC
WABSRFgAUkFYAFJDWABSU1AAUklQAA0LCA4MCQoPEAABAgMEBQYHQUREUjJMSU5FAGxheW91dCBz
cmMALXEALWV4AC9kZXYvdHR5ABtbPzEwMDA7MTAwMjsxMDE1OzEwMDZsG1s/MjVoACV1AGxheW91
dCBhc20ALXNlAGxpYmMvbG9nL2F0dGFjaGRlYnVnZ2VyLmMAYnJlYWsAJXMgKiUjcABnZGIALS10
dWkALXAAc2V0IG9zYWJpIEdOVS9MaW51eABzZXQgY29tcGxhaW50cyAwAHNldCBjb25maXJtIG9m
ZgBsYXlvdXQgcmVnAHNldCB2YXIgZ19nZGJzeW5jID0gMQBNQUtFRkxBR1MAVEVSTQBkdW1iAEFM
TERPTkUAQkFERkxBR1MARkFJTABFTkNPREUATUVNT1JZAE5PREFUQQBOT05BTUUATk9UQ0FOQ0VM
RUQAU0VSVklDRQBTT0NLVFlQRQBTVUNDRVNTAFNZU1RFTQBBRERSRkFNSUxZAA8fQABbXEEAAAAA
AGlcQQAAAAAAOFxBAAAAAACFXEEAAAAAAEZcQQAAAAAAYlxBAAAAAACvXEEAAAAAAK9cQQAAAAAA
r1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACv
XEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9c
QQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xB
AAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEA
AAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAA
AAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAA
AACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAA
AK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAA
r1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACv
XEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9c
QQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xB
AAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACvXEEAAAAAAK9cQQAAAAAAr1xBAAAAAACMXEEA
AAAAAKhcQQAAAAAAcFxBAAAAAAAxXEEAAAAAAJNcQQAAAAAAmlxBAAAAAABUXEEAAAAAAHdcQQAA
AAAATVxBAAAAAAC2XEEAAAAAAH5cQQAAAAAAP1xBAAAAAAChXEEAAAAAAFxkcml2ZXJzXGV0Y1xo
b3N0cwAvZXRjL2hvc3RzAC9ldGMvcmVzb2x2LmNvbmYAIAkNCgsAbmFtZXNlcnZlcgBTAFkAUwBU
AEUATQBcAEMAdQByAHIAZQBuAHQAQwBvAG4AdAByAG8AbABTAGUAdABcAFMAZQByAHYAaQBjAGUA
cwBcAFQAYwBwAGkAcABcAFAAYQByAGEAbQBlAHQAZQByAHMAXABJAG4AdABlAHIAZgBhAGMAZQBz
AAAARABoAGMAcABJAHAAQQBkAGQAcgBlAHMAcwAAAEQAaABjAHAATgBhAG0AZQBTAGUAcgB2AGUA
cgAAAGxpYmMvc29jay9iaW5kLmMAYWRkcnNpemUgPD0gc2l6ZW9mKGFkZHIyKQBsaWJjL3NvY2sv
YmluZC1udC5jAGZkLT5raW5kID09IGtGZFNvY2tldABsaWJjL3NvY2svZ2V0c29ja25hbWUtbnQu
YwBsaWJjL3NvY2svbGlzdGVuLW50LmMADx9AAIMzQAAAAAAAnzFAAAAAAABSMUAAAAAAAIYyQAAA
AAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAAANMkAAAAAAAIMzQAAAAAAAgzNAAAAA
AACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAA
AE8yQAAAAAAAFTNAAAAAAACDM0AAAAAAADkyQAAAAAAA2jBAAAAAAAAyMUAAAAAAAOIwQAAAAAAA
gzNAAAAAAACDM0AAAAAAANMyQAAAAAAAZTJAAAAAAACDM0AAAAAAAIMzQAAAAAAAXTFAAAAAAADp
MkAAAAAAAMAxQAAAAAAAIDNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMz
QAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNA
AAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAABEMkAAAAAAALIyQAAAAAAAQjFAAAAAAADqMEAA
AAAAAOwxQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA+jBAAAAAAAD/MkAAAAAAAIMzQAAA
AAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA1jFAAAAAAADhMUAAAAAAAIMzQAAAAAAA8jBAAAAA
AAD0MkAAAAAAAIMzQAAAAAAAgzNAAAAAAADIMkAAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAA
AIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA
CjFAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACD
M0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMz
QAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNA
AAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AA
AAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAA
AAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA3jJAAAAAAACJMUAAAAAAAIMzQAAAAAAAgzNAAAAA
AACDM0AAAAAAANIwQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAA
AIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA
gzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAOjFAAAAAAACD
M0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMz
QAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAAAuMkAAAAAAAIMzQAAAAAAAgzNA
AAAAAAACMUAAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AA
AAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAA
AAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAA
AACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAA
AIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA
gzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACD
M0AAAAAAAIMzQAAAAAAAgzNAAAAAAABKMUAAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMz
QAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNA
AAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AA
AAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAA
AAAAgzNAAAAAAACRMkAAAAAAAMsxQAAAAAAAVzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAA
AACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAATDNAAAAAAACDM0AAAAAA
AIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA
gzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACD
M0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMz
QAAAAAAAbTNAAAAAAAB4M0AAAAAAAGIzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNA
AAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAAArM0AAAAAAAFoyQAAAAAAAAjJAAAAAAABwMkAA
AAAAAAozQAAAAAAAezJAAAAAAAASMUAAAAAAACMyQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAA
AAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAA
AACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAA
AIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA
gzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACD
M0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMz
QAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAqjFA
AAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AA
AAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAACoxQAAAAAAAaDFAAAAAAACDM0AAAAAAAIMzQAAA
AAAAgzNAAAAAAAAiMUAAAAAAAPcxQAAAAAAAfjFAAAAAAACnMkAAAAAAAJwyQAAAAAAAvTJAAAAA
AAAaMUAAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAA
AIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAA
gzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAgzNAAAAAAACDM0AAAAAAAIMzQAAAAAAAczFAAAAAAAAA
AAQAAAIOAEphbgBGZWIATWFyAEFwcgBNYXkASnVuAEp1bABBdWcAU2VwAE9jdABOb3YARGVjAABT
dW4ATW9uAFR1ZQBXZWQAVGh1AEZyaQBTYXQAAGaQYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpB
QkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODkgOistLl8AbG9jYWwgdGltZSB6b25l
IG11c3QgYmUgc2V0ACxNNC4xLjAsTTEwLjUuMABOZXdfWW9yawBHU1QAemlwOnVzci9zaGFyZS96
b25laW5mbwBUWgBtAQAAbgEAAB8cHx4fHh8fHh8eHx8dHx4fHh8fHh8eH1VUQwAgICAAAAAAAAAA
4D9BTQBQTQArACVEICVYACUwMmQAJW0vJWQvJXkAJTJkACUwM2QAJUg6JU0AJUk6JU06JVMgJXAA
JUg6JU06JVMAJWUtJWItJVkAJTA0ZABKYW51YXJ5AAAARmVicnVhcnkAAE1hcmNoAAAAAABBcHJp
bAAAAAAATWF5AAAAAAAAAEp1bmUAAAAAAABKdWx5AAAAAAAAQXVndXN0AAAAAFNlcHRlbWJlcgBP
Y3RvYmVyAAAATm92ZW1iZXIAAERlY2VtYmVyAABTdW5kYXkAAAAATW9uZGF5AAAAAFR1ZXNkYXkA
AABXZWRuZXNkYXkAVGh1cnNkYXkAAEZyaWRheQAAAABTYXR1cmRheQAAUFdEAGxpYmMvemlwb3Mv
b3Blbi5jAGYPH0QAAFpJUF9MRklMRV9NQUdJQyh6aXBvcy0+bWFwICsgbGYpID09IGtaaXBMZmls
ZUhkck1hZ2ljAAAAWklQX0xGSUxFX0NPTVBSRVNTSU9OTUVUSE9EKHppcG9zLT5tYXAgKyBsZikg
PT0ga1ppcENvbXByZXNzaW9uTm9uZSB8fCBaSVBfTEZJTEVfQ09NUFJFU1NJT05NRVRIT0Qoemlw
b3MtPm1hcCArIGxmKSA9PSBrWmlwQ29tcHJlc3Npb25EZWZsYXRlAHppcDpsaWJjL3ppcG9zL2Zp
bmQuYwAPH0AAWklQX0NGSUxFX01BR0lDKHppcG9zLT5tYXAgKyBjKSA9PSBrWmlwQ2ZpbGVIZHJN
YWdpYwBmLg8fhAAAAAAAkAAAAAAAAAAAIdxBAAAAAAAEAAQACAAEAK3IQQAAAAAABAAFABAACACt
yEEAAAAAAAQABgAgACAArchBAAAAAAAEAAQAEAAQAO7OQQAAAAAACAAQACAAIADuzkEAAAAAAAgA
EACAAIAA7s5BAAAAAAAIACAAgAAAAe7OQQAAAAAAIACAAAIBAATuzkEAAAAAACAAAgECAQAQ7s5B
AAAAAABpbmNvcnJlY3QgaGVhZGVyIGNoZWNrAHVua25vd24gY29tcHJlc3Npb24gbWV0aG9kAGlu
dmFsaWQgd2luZG93IHNpemUAdW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0AGhlYWRlciBjcmMgbWlz
bWF0Y2gAaW52YWxpZCBibG9jayB0eXBlAGludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMAaW52
YWxpZCBjb2RlIGxlbmd0aHMgc2V0AGludmFsaWQgYml0IGxlbmd0aCByZXBlYXQAaW52YWxpZCBs
aXRlcmFsL2xlbmd0aHMgc2V0AGludmFsaWQgZGlzdGFuY2VzIHNldABpbnZhbGlkIGxpdGVyYWwv
bGVuZ3RoIGNvZGUAaW52YWxpZCBkaXN0YW5jZSBjb2RlAGludmFsaWQgZGlzdGFuY2UgdG9vIGZh
ciBiYWNrAGluY29ycmVjdCBkYXRhIGNoZWNrAGluY29ycmVjdCBsZW5ndGggY2hlY2sADx9AAHRv
byBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzAAAAAABpbnZhbGlkIGNvZGUgLS0gbWlz
c2luZyBlbmQtb2YtYmxvY2sADx8A9/RBAAAAAADi9kEAAAAAALP3QQAAAAAASPhBAAAAAACw+EEA
AAAAANb4QQAAAAAAbPlBAAAAAACY+UEAAAAAALz5QQAAAAAAq/xBAAAAAAAo/UEAAAAAAFf9QQAA
AAAAZv1BAAAAAABf/kEAAAAAAOn+QQAAAAAA8f5BAAAAAABG/0EAAAAAABwAQgAAAAAAJAFCAAAA
AAAbBEIAAAAAACMEQgAAAAAA4wVCAAAAAAD+BUIAAAAAAEoHQgAAAAAAWgdCAAAAAABuC0IAAAAA
AJ4LQgAAAAAArgtCAAAAAABMDUIAAAAAAKgOQgAAAAAA6/RBAAAAAABmLg8fhAAAAAAAZg8fRAAA
EAARABIAAAAIAAcACQAGAAoABQALAAQADAADAA0AAgAOAAEADwBmLg8fhAAAAAAAZi4PH4QAAAAA
AGYPH0QAABAAEAAQABAAEQARABIAEgATABMAFAAUABUAFQAWABYAFwAXABgAGAAZABkAGgAaABsA
GwAcABwAHQAdAEAAQAABAAIAAwAEAAUABwAJAA0AEQAZACEAMQBBAGEAgQDBAAEBgQEBAgEDAQQB
BgEIAQwBEAEYASABMAFAAWAAAAAAEAAQABAAEAAQABAAEAAQABEAEQARABEAEgASABIAEgATABMA
EwATABQAFAAUABQAFQAVABUAFQAQAE0AygAAAAMABAAFAAYABwAIAAkACgALAA0ADwARABMAFwAb
AB8AIwArADMAOwBDAFMAYwBzAIMAowDDAOMAAgEAAAAAZpAAAAAAAAAAAMDKQwAAAAAAAAAAABMA
AAAHAAAAAAAAAIDVQwAAAAAAIMtDAAAAAAAAAAAAHgAAAA8AAAAAAAAAANZDAAAAAACgy0MAAAAA
AAEBAAAeAQAADwAAAAAAAAAQERIACAcJBgoFCwQMAw0CDgEPAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC
AAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAIA
AAACAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAFAAAABgAAAAYAAAAHAAAABwAAAAgAAAAIAAAACQAA
AAkAAAAKAAAACgAAAAsAAAALAAAADAAAAAwAAAANAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAgAAAAMAAAAD
AAAAAwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAAAAFAAAABQAAAAAAAAAxLjIuMTEAbmVl
ZCBkaWN0aW9uYXJ5AHN0cmVhbSBlbmQAZmlsZSBlcnJvcgBzdHJlYW0gZXJyb3IAZGF0YSBlcnJv
cgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBmDx9EAAAbzEMAAAAAACvMQwAAAAAA
7eNDAAAAAAA2zEMAAAAAAEHMQwAAAAAATsxDAAAAAABZzEMAAAAAAG3MQwAAAAAA7eNDAAAAAADt
40MAAAAAACAfHh0cGxoZGBcWFRQTEhEBAAEAAQABAAEAAQABAAEAEA8ODQwLCgkIBwYFBAMCARAF
AQAXBQEBEwURABsFARARBQUAGQUBBBUFQQAdBQFAEAUDABgFAQIUBSEAHAUBIBIFCQAaBQEIFgWB
AEAFAAAQBQIAFwWBARMFGQAbBQEYEQUHABkFAQYVBWEAHQUBYBAFBAAYBQEDFAUxABwFATASBQ0A
GgUBDBYFwQBABQAAYAcAAAAIUAAACBAAFAhzABIHHwAACHAAAAgwAAAJwAAQBwoAAAhgAAAIIAAA
CaAAAAgAAAAIgAAACEAAAAngABAHBgAACFgAAAgYAAAJkAATBzsAAAh4AAAIOAAACdAAEQcRAAAI
aAAACCgAAAmwAAAICAAACIgAAAhIAAAJ8AAQBwQAAAhUAAAIFAAVCOMAEwcrAAAIdAAACDQAAAnI
ABEHDQAACGQAAAgkAAAJqAAACAQAAAiEAAAIRAAACegAEAcIAAAIXAAACBwAAAmYABQHUwAACHwA
AAg8AAAJ2AASBxcAAAhsAAAILAAACbgAAAgMAAAIjAAACEwAAAn4ABAHAwAACFIAAAgSABUIowAT
ByMAAAhyAAAIMgAACcQAEQcLAAAIYgAACCIAAAmkAAAIAgAACIIAAAhCAAAJ5AAQBwcAAAhaAAAI
GgAACZQAFAdDAAAIegAACDoAAAnUABIHEwAACGoAAAgqAAAJtAAACAoAAAiKAAAISgAACfQAEAcF
AAAIVgAACBYAQAgAABMHMwAACHYAAAg2AAAJzAARBw8AAAhmAAAIJgAACawAAAgGAAAIhgAACEYA
AAnsABAHCQAACF4AAAgeAAAJnAAUB2MAAAh+AAAIPgAACdwAEgcbAAAIbgAACC4AAAm8AAAIDgAA
CI4AAAhOAAAJ/ABgBwAAAAhRAAAIEQAVCIMAEgcfAAAIcQAACDEAAAnCABAHCgAACGEAAAghAAAJ
ogAACAEAAAiBAAAIQQAACeIAEAcGAAAIWQAACBkAAAmSABMHOwAACHkAAAg5AAAJ0gARBxEAAAhp
AAAIKQAACbIAAAgJAAAIiQAACEkAAAnyABAHBAAACFUAAAgVABAIAgETBysAAAh1AAAINQAACcoA
EQcNAAAIZQAACCUAAAmqAAAIBQAACIUAAAhFAAAJ6gAQBwgAAAhdAAAIHQAACZoAFAdTAAAIfQAA
CD0AAAnaABIHFwAACG0AAAgtAAAJugAACA0AAAiNAAAITQAACfoAEAcDAAAIUwAACBMAFQjDABMH
IwAACHMAAAgzAAAJxgARBwsAAAhjAAAIIwAACaYAAAgDAAAIgwAACEMAAAnmABAHBwAACFsAAAgb
AAAJlgAUB0MAAAh7AAAIOwAACdYAEgcTAAAIawAACCsAAAm2AAAICwAACIsAAAhLAAAJ9gAQBwUA
AAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnOABEHDwAACGcAAAgnAAAJrgAACAcAAAiHAAAIRwAA
Ce4AEAcJAAAIXwAACB8AAAmeABQHYwAACH8AAAg/AAAJ3gASBxsAAAhvAAAILwAACb4AAAgPAAAI
jwAACE8AAAn+AGAHAAAACFAAAAgQABQIcwASBx8AAAhwAAAIMAAACcEAEAcKAAAIYAAACCAAAAmh
AAAIAAAACIAAAAhAAAAJ4QAQBwYAAAhYAAAIGAAACZEAEwc7AAAIeAAACDgAAAnRABEHEQAACGgA
AAgoAAAJsQAACAgAAAiIAAAISAAACfEAEAcEAAAIVAAACBQAFQjjABMHKwAACHQAAAg0AAAJyQAR
Bw0AAAhkAAAIJAAACakAAAgEAAAIhAAACEQAAAnpABAHCAAACFwAAAgcAAAJmQAUB1MAAAh8AAAI
PAAACdkAEgcXAAAIbAAACCwAAAm5AAAIDAAACIwAAAhMAAAJ+QAQBwMAAAhSAAAIEgAVCKMAEwcj
AAAIcgAACDIAAAnFABEHCwAACGIAAAgiAAAJpQAACAIAAAiCAAAIQgAACeUAEAcHAAAIWgAACBoA
AAmVABQHQwAACHoAAAg6AAAJ1QASBxMAAAhqAAAIKgAACbUAAAgKAAAIigAACEoAAAn1ABAHBQAA
CFYAAAgWAEAIAAATBzMAAAh2AAAINgAACc0AEQcPAAAIZgAACCYAAAmtAAAIBgAACIYAAAhGAAAJ
7QAQBwkAAAheAAAIHgAACZ0AFAdjAAAIfgAACD4AAAndABIHGwAACG4AAAguAAAJvQAACA4AAAiO
AAAITgAACf0AYAcAAAAIUQAACBEAFQiDABIHHwAACHEAAAgxAAAJwwAQBwoAAAhhAAAIIQAACaMA
AAgBAAAIgQAACEEAAAnjABAHBgAACFkAAAgZAAAJkwATBzsAAAh5AAAIOQAACdMAEQcRAAAIaQAA
CCkAAAmzAAAICQAACIkAAAhJAAAJ8wAQBwQAAAhVAAAIFQAQCAIBEwcrAAAIdQAACDUAAAnLABEH
DQAACGUAAAglAAAJqwAACAUAAAiFAAAIRQAACesAEAcIAAAIXQAACB0AAAmbABQHUwAACH0AAAg9
AAAJ2wASBxcAAAhtAAAILQAACbsAAAgNAAAIjQAACE0AAAn7ABAHAwAACFMAAAgTABUIwwATByMA
AAhzAAAIMwAACccAEQcLAAAIYwAACCMAAAmnAAAIAwAACIMAAAhDAAAJ5wAQBwcAAAhbAAAIGwAA
CZcAFAdDAAAIewAACDsAAAnXABIHEwAACGsAAAgrAAAJtwAACAsAAAiLAAAISwAACfcAEAcFAAAI
VwAACBcAQAgAABMHMwAACHcAAAg3AAAJzwARBw8AAAhnAAAIJwAACa8AAAgHAAAIhwAACEcAAAnv
ABAHCQAACF8AAAgfAAAJnwAUB2MAAAh/AAAIPwAACd8AEgcbAAAIbwAACC8AAAm/AAAIDwAACI8A
AAhPAAAJ/wAAAAUAEAAFAAgABQAYAAUABAAFABQABQAMAAUAHAAFAAIABQASAAUACgAFABoABQAG
AAUAFgAFAA4ABQAeAAUAAQAFABEABQAJAAUAGQAFAAUABQAVAAUADQAFAB0ABQADAAUAEwAFAAsA
BQAbAAUABwAFABcABQAPH4QAAAAAAAwACACMAAgATAAIAMwACAAsAAgArAAIAGwACADsAAgAHAAI
AJwACABcAAgA3AAIADwACAC8AAgAfAAIAPwACAACAAgAggAIAEIACADCAAgAIgAIAKIACABiAAgA
4gAIABIACACSAAgAUgAIANIACAAyAAgAsgAIAHIACADyAAgACgAIAIoACABKAAgAygAIACoACACq
AAgAagAIAOoACAAaAAgAmgAIAFoACADaAAgAOgAIALoACAB6AAgA+gAIAAYACACGAAgARgAIAMYA
CAAmAAgApgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAI
AE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgA
AQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABx
AAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkA
CAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAI
ANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgA
nQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDT
AQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsB
CQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJ
AFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkA
hwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAX
AAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcA
CQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJ
AG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkA
vwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgABwBI
AAcAKAAHAGgABwAYAAcAWAAHADgABwB4AAcABAAHAEQABwAkAAcAZAAHABQABwBUAAcANAAHAHQA
BwADAAgAgwAIAEMACADDAAgAIwAIAKMACABjAAgA4wAIAAAAAAABAAAAAgAAAAMAAAAEAAAABgAA
AAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAAAAQAAgAEAAAACAAAAAwAA
AAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAAAAAAAAAAAAAAAAAAEAAAAC
AAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAAAEAAAABQAAAAYAAAAHAAAACAA
AAAoAAAAMAAAADgAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4AAAAAAAAAAvZGV2L3N0
ZGluAC9kZXYvc3Rkb3V0AEluZmluaXR5AE5hTgCtU0IAAAAAAK1TQgAAAAAAm1NCAAAAAACkU0IA
AAAAAGRTQgAAAAAAP1NCAAAAAAAAAAAAAAAAAAAAAAAAAPg/YUNvY6eH0j+zyGCLKIrGP/t5n1AT
RNM/AAAAAAAAJEAAAAAAAAAcQAAAAAAAABRAZi4PH4QAAAAAAGYuDx+EAAAAAAAPH0AABQAAABkA
AAB9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwPwAAAAAAACRAAAAAAAAAWUAAAAAAAECP
QAAAAAAAiMNAAAAAAABq+EAAAAAAgIQuQQAAAADQEmNBAAAAAITXl0EAAAAAZc3NQQAAACBfoAJC
AAAA6HZIN0IAAACilBptQgAAQOWcMKJCAACQHsS81kIAADQm9WsMQwCA4Dd5w0FDAKDYhVc0dkMA
yE5nbcGrQwA9kWDkWOFDQIy1eB2vFURQ7+LW5BpLRJLVTQbP8IBEAAAAAAAAAAC8idiXstKcPDOn
qNUj9kk5Paf0RP0PpTKdl4zPCLpbJUNvrGQoBsgKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIDg
N3nDQUMXbgW1tbiTRvX5P+kDTzhNMh0w+Uh3glo8v3N/3U8VdWxpYmMvbWVtL2RlZmVyLmdyZWcu
YwBfX2dhcmJhZ2UubgBmMi0+bmV4dCA9PSBmcmFtZQAPH0AAUG9pbnRlck5vdE93bmVkQnlQYXJl
bnRTdGFja0ZyYW1lKGYyLCBmcmFtZSwgYXJnKQBsaWJjL21lbS92YXNwcmludGYuYwB3cm90ZSA9
PSBzaXplIC0gMQAPH4AAAAAAdGhpcmRfcGFydHkvZGxtYWxsb2MvZGxtYWxsb2MuYwBjaHVua3Np
emUob2xkZmlyc3QpID09IHNtYWxsX2luZGV4MnNpemUoSSkAAAAAAABjaHVua3NpemUocCkgPT0g
c21hbGxfaW5kZXgyc2l6ZShJKQAAAAAAY2h1bmtzaXplKG5leHQpID09IHNtYWxsX2luZGV4MnNp
emUoSSkAAGNodW5rc2l6ZShwKSA9PSBzbWFsbF9pbmRleDJzaXplKGlkeCkAAABjaHVua3NpemUo
cCkgPT0gc21hbGxfaW5kZXgyc2l6ZShpKQAAAAAAKChzaXplX3QpbWVtICYgKGFsaWdubWVudCAt
IDEpKSA9PSAwAHNlZ21lbnRfaG9sZHMoc3AsIChjaGFyICopc3ApAChjaGFyICopb2xkZmlyc3Qg
PiAoY2hhciAqKXEAcGludXNlKG9sZGZpcnN0KQBxc2l6ZSA+PSBNSU5fQ0hVTktfU0laRQBvbGRm
aXJzdCAhPSBCAG9sZGZpcnN0ICE9IEYAaXNfYWxpZ25lZChzcykAbmZlbmNlcyA+PSAyAHBzaXpl
ID49IE1JTl9DSFVOS19TSVpFAGNodW5rc2l6ZSh2KSA9PSByc2l6ZSArIG5iAGlzX3NtYWxsKERW
UykARFZTID49IE1JTl9DSFVOS19TSVpFAGlzX2FsaWduZWQoY2h1bmsybWVtKHApKQBnX21wYXJh
bXMubWFnaWMgIT0gMABwICE9IEIAcCAhPSBGAG5leHQgIT0gQgBuZXh0ICE9IEYAcCAhPSBiAGNo
dW5rc2l6ZShwKSA+PSBuYgBmDx9EAAB0aGlyZF9wYXJ0eS9kbG1hbGxvYy9kbHZhbGxvYy5jAHRo
aXJkX3BhcnR5L2RsbWFsbG9jL2RsbWFsbG9jX3RyeV9yZWFsbG9jX2NodW5rLmMAOgA6IGFzc2Vy
dCgAKQ0KAGxpYmMvcnVudGltZS9jeGFhdGV4aXQuYwBpIDwgQVJSQVlMRU4oYi0+cCkAYiAhPSAm
X19jeGFfYmxvY2tzLnJvb3QAQ09NREJHAJBfAEYATwBSAEsAAABmDx9EAABlcnJvcjogLS1mdHJh
Y2UgbmVlZHMgdGhlIGNvbmNvbWl0YW50IC5jb20uZGJnIGJpbmFyeQoAkGZmZmZmZgpAAAAAAAAA
4EMtLS0tZnRyYWNlAGxpYmMvcnVudGltZS9ncm93LmMAaXRlbXNpemUAKCpwICYmICpjYXBhY2l0
eSkgfHwgKCEqcCAmJiAhKmNhcGFjaXR5KQAAAAAAAAAAIV9pc2hlYXAoKnApIHx8ICgoaW50cHRy
X3QpKnAgJiAxNSkgPT0gMAA7AG1tLT5pID09IAAlcyV6ZCVzDQoAJXMlLHpkJXMNCgBdPT17AG1t
LT5wWwB9OyAvKiAAIGZyYW1lcyBtYXBwZWQgdy8gACVzJSx6ZCVzJSx6ZCVzDQoNCgAgZnJhbWVz
IGdhcHBlZCAqLwAPHwAlcyUzdSVzMHglMDh4LDB4JTA4eCwlbGQsJWQsJWQlcyUsemQlcw0KAAAA
AAAAAAB4AHQAZQByAG0ALQB0AHIAdQBlAGMAbwBsAG8AcgAAAFQARQBSAE0AAABsaWJjL3J1bnRp
bWUvbWVtdHJhY2suYwBpID49IDAAaSA8PSBtbS0+aQBtbS0+aSA8IEFSUkFZTEVOKG1tLT5wKQBp
ICsgbiA8PSBtbS0+aQB5ID49IHgAQXJlTWVtb3J5SW50ZXJ2YWxzT2sobW0pAHIgPj0gbAB5ID49
IG1tLT5wW2xdLnkAbW0tPnBbbF0ueCA8PSBtbS0+cFtsXS55AHggPD0gbW0tPnBbcl0ueABtbS0+
cFtyXS54IDw9IG1tLT5wW3JdLnkAbGliYy9ydW50aW1lL21lbXRyYWNrbnQuYwAuc3RydGFiAH9F
TEYALmV4ZQAvYmluOi91c3IvbG9jYWwvYmluOi91c3IvYmluAFBBVEgAVHJhY2VyUGlkOgkASEVJ
U0VOREVCVUcAL3Byb2Mvc2VsZi9zdGF0dXMAAACAX5eltDZBX3CJ4T8AAAAAAAAvZGV2L3R0eQAv
ZGV2L251bGwAL2Rldi9zdGRpbgAvZGV2L3N0ZG91dABOVUwAQ09OSU4kAENPTk9VVCQADx8AGAAA
AAAAAAAAAAAAAAAAAAEAAAAAAAAAldYm6AsuET4vYmluL3NoAGJhc2gAIAkKCyIAbGliYy9jYWxs
cy9vcGVuLW50LmMAZ19mZHMucFtmZF0uZXh0cmEgIT0gLTEAYXBlLmNvbQBsaWJjL2NhbGxzL2Ns
b2NrX2dldHRpbWUuYwBhZC5heCAhPSAtMQCQXFw/XHBpcGVcY29zbW9cAGlwaGxwYXBpLmRsbAB3
czJfMzIuZGxsAE50RGVsYXlFeGVjdXRpb24ATnRRdWVyeUluZm9ybWF0aW9uRmlsZQBOdFF1ZXJ5
SW5mb3JtYXRpb25Qcm9jZXNzAE50WWllbGRFeGVjdXRpb24AbnRkbGwuZGxsAGFkdmFwaTMyLmRs
bAAobnVsbCkAMDEyMzQ1Njc4OUFCQ0RFRlBYADAxMjM0NTY3ODlhYmNkZWZweACQSU5GAGluZgBO
QU4AbmFuAGxpYmMvZm10L2l0b2E2NGZpeGVkMTYuZ3JlZy5jAGsgPD0gNjQgJiYgIShrICYgMykA
Zi4PH4QAAAAAAA8fQAAAAB8AOwBaAHgAlwC1ANQA8wARATABTgEAAB8APABbAHkAmAC2ANUA9AAS
ATEBTwFsaWJjL2ZtdC9udG9hLmMAbGVuIDwgQlVGRkVSX1NJWkUARVVOS05PV04AkEzXAgCsAgAA
tNcCALMCAAAM1wIAuQIAABzYAgDAAgAAjNYCAD2D//+c1gIAxgIAAJTXAgDKAgAAtNUCANACAAAU
1wIA1gIAAOzVAgDeAgAADNYCAOQCAADc1QIA6wIAACTXAgDyAgAAvNUCAPkCAABU1gIAAAMAAFTX
AgAHAwAA/NUCAA8DAABM1gIAFQMAAFTYAgAcAwAABNcCACIDAABk1wIAKQMAAKzWAgAxAwAAlNYC
ADgDAAD01gIAPwMAALzWAgBGAwAAjNcCAE0DAABE2AIAVAMAAFzWAgBcAwAARNcCAGIDAABE1gIA
aQMAABTYAgBwAwAA/NcCAHcDAADE1gIAfQMAAMTXAgCEAwAAPNYCAIoDAADk1wIAjwMAACzWAgCW
AwAA1NYCAJ4DAAAc1wIAqwMAAGzXAgCyAwAAtNYCALwDAAAs1wIAwgMAAHTWAgDJAwAALNgCAM8D
AADM1wIA1QMAAKTXAgDcAwAAfNYCAOYDAABM2AIA7QMAAHzXAgD0AwAANNYCAP0DAADM1gIACgQA
ANzXAgATBAAAPNcCAB4EAADU1wIAKgQAAAzYAgA6BAAAhNcCAEoEAACc1wIAUgQAALzXAgBdBAAA
1NUCAGoEAADE1QIAdwQAAMzVAgCCBAAA3NYCAJAEAADs1gIAmQQAAOTWAgClBAAAFNYCAK8EAAAk
1gIAvAQAAPzWAgDHBAAApNYCAM8EAABc1wIA1wQAAATYAgDgBAAAPNgCAOoEAAA02AIA9wQAABzW
AgABBQAAZNYCAA4FAABs1gIAGAUAAOTVAgAlBQAAhNYCAC4FAAAk2AIAOgUAAOzXAgBBBQAA9NUC
AEkFAAAE1gIAUQUAAKzXAgBbBQAAdNcCAGYFAAA01wIAdgUAAPTXAgB9BQAAAAAAAEVOT1NZUwBF
UEVSTQBFTk9FTlQARVNSQ0gARUlPAEVOWElPAEUyQklHAEVOT0VYRUMARUJBREYARUNISUxEAEVB
R0FJTgBFTk9NRU0ARUFDQ0VTAEVGQVVMVABFTk9UQkxLAEVCVVNZAEVFWElTVABFWERFVgBFTk9E
RVYARU5PVERJUgBFSVNESVIARUlOVkFMAEVORklMRQBFTUZJTEUARU5PVFRZAEVUWFRCU1kARUZC
SUcARU5PU1BDAEVEUVVPVABFU1BJUEUARVJPRlMARU1MSU5LAEVQSVBFAEVET00ARVJBTkdFAEVE
RUFETEsARU5BTUVUT09MT05HAEVOT0xDSwBFTk9URU1QVFkARUxPT1AARU5PTVNHAEVJRFJNAEVU
SU1FAEVQUk9UTwBFT1ZFUkZMT1cARUlMU0VRAEVVU0VSUwBFTk9UU09DSwBFREVTVEFERFJSRVEA
RU1TR1NJWkUARVBST1RPVFlQRQBFTk9QUk9UT09QVABFUFJPVE9OT1NVUFBPUlQARVNPQ0tUTk9T
VVBQT1JUAEVOT1RTVVAARU9QTk9UU1VQUABFUEZOT1NVUFBPUlQARUFGTk9TVVBQT1JUAEVBRERS
SU5VU0UARUFERFJOT1RBVkFJTABFTkVURE9XTgBFTkVUVU5SRUFDSABFTkVUUkVTRVQARUNPTk5B
Qk9SVEVEAEVDT05OUkVTRVQARU5PQlVGUwBFSVNDT05OAEVOT1RDT05OAEVTSFVURE9XTgBFVE9P
TUFOWVJFRlMARVRJTUVET1VUAEVDT05OUkVGVVNFRABFSE9TVERPV04ARUhPU1RVTlJFQUNIAEVB
TFJFQURZAEVJTlBST0dSRVNTAEVTVEFMRQBFUkVNT1RFAEVCQURNU0cARUNBTkNFTEVEAEVPV05F
UkRFQUQARU5PVFJFQ09WRVJBQkxFAEVOT05FVABFUkVTVEFSVABmkAHAAcABwAHAAuAC4ALgAuAC
4APwA/AD8APwA/AE+AT4BPgE+AT4BfwF/AX8BfwF/AX8AABsaWJjL3N0ci9zdHJjaHIuYwAhciB8
fCAqciB8fCAhYwBsaWJjL3N0ci9zdHJjaHJudWwuYwAoKnIgJiAyNTUpID09IGMgfHwgISpyAGxp
YmMvc3RyL3N0cm5sZW4uYwBpID09IG4gfHwgKGkgPCBuICYmICFzW2ldKQAPH0QAAEVYSVQAAAAA
SFVQAAAAAABJTlQAAAAAAFFVSVQAAAAASUxMAAAAAABUUkFQAAAAAEFCUlQAAAAAQlVTAAAAAABG
UEUAAAAAAEtJTEwAAAAAVVNSMQAAAABTRUdWAAAAAFVTUjIAAAAAUElQRQAAAABBTFJNAAAAAFRF
Uk0AAAAAU1RLRkxUAABDSExEAAAAAENPTlQAAAAAU1RPUAAAAABUU1RQAAAAAFRUSU4AAAAAVFRP
VQAAAABVUkcAAAAAAFhDUFUAAAAAWEZTWgAAAABWVEFMUk0AAFBST0YAAAAAV0lOQ0gAAABJTwAA
AAAAAFBXUgAAAAAAU1lTAAAAAABVTktOT1dOAFNJRwBmLg8fhAAAAAAAZpB/AH8AfwB/AH8AfwB/
AH8Aa2VybmVsMzIuZGxsAA8fANQrRFQBAAAAlhXkxgEAAADQlxl1AQAAAJ4AqswAAAAAJGHNYwEA
AAAAAAAAAAAAAP////8AAAAA/////wAAAABBBnHbAQAAAEEWAfcBAAAAoAA6JjsmZSZmJmMmYCYi
INglyyXZJUImQCZqJmsmPCa6JcQllSE8ILYApwCsJaghkSGTIZIhkCEfIpQhsiW8JSAAIQAcICMA
JAAlACYAGCAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4ARyBA
AEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwA
XQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5
AHoAewB8AH0AfgACI8cA/ADpAOIA5ADgAOUA5wDqAOsA6ADvAO4A7ADEAMUAyQDmAMYA9AD2APIA
+wD5AP8A1gDcAKIAowClAKwgkgHhAO0A8wD6APEA0QCqALoAvwAQI6wAvQC8AKEAqwC7AJElkiWT
JQIlJCVhJWIlViVVJWMlUSVXJV0lXCVbJRAlFCU0JSwlHCUAJTwlXiVfJVolVCVpJWYlYCVQJWwl
ZyVoJWQlZSVZJVglUiVTJWslaiUYJQwliCWEJYwlkCWAJbED3wCTA8ADowPDA7wDxAOmA5gDqQO0
Ax4ixgO1AykiYSKxAGUiZCIgIyEj9wBIIrAAGSLXABoifyCyAKAluwMBAQEBAQEBAQpDb3Ntb3Bv
bGl0YW4KQ29weXJpZ2h0IDIwMjAgSnVzdGluZSBBbGV4YW5kcmEgUm9iZXJ0cyBUdW5uZXkKClBl
cm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29m
dHdhcmUgZm9yCmFueSBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50
ZWQsIHByb3ZpZGVkIHRoYXQgdGhlCmFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVy
bWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuCgpUSEUgU09GVFdBUkUgSVMgUFJP
VklERUQgIkFTIElTIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMCldBUlJBTlRJRVMgV0lU
SCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQKV0FSUkFOVElF
UyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRQpB
VVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09O
U0VRVUVOVElBTApEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZS
T00gTE9TUyBPRiBVU0UsIERBVEEgT1IKUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Yg
Q09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIKVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9V
VCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUgpQRVJGT1JNQU5DRSBPRiBUSElT
IFNPRlRXQVJFLgoACgpsc3FsaXRlMyAoTUlUIExpY2Vuc2UpCkNvcHlyaWdodCAyMDAyLTIwMTYg
VGlhZ28gRGlvbml6aW8sIERvdWcgQ3VycmllAAoKVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJB
UyBJUyIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTCldJVEggUkVHQVJE
IFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YKTUVS
Q0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJF
IExJQUJMRSBGT1IKQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJ
QUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUwpXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1Mg
T0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4KQUNUSU9OIE9GIENPTlRSQUNU
LCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YKT1Ig
SU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FS
RS4ACgpNYmVkIFRMUyAoQXBhY2hlIDIuMCkKQ29weXJpZ2h0IEFSTSBMaW1pdGVkCkNvcHlyaWdo
dCBNYmVkIFRMUyBDb250cmlidXRvcnMACgpnZXRvcHQgKEJTRC0zKQpDb3B5cmlnaHQgMTk4Nywg
MTk5MywgMTk5NCBUaGUgUmVnZW50cyBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDYWxpZm9ybmlhAAoK
c3RyZnRpbWUgKEJTRC0zKQpDb3B5cmlnaHQgMTk4OSBUaGUgUmVnZW50cyBvZiB0aGUgVW5pdmVy
c2l0eSBvZiBDYWxpZm9ybmlhAAoKemxpYiAoemxpYiBMaWNlbnNlKQpDb3B5cmlnaHQgMTk5NS0y
MDE3IEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIACgppbmZsYXRlIDEuMi4xMSAoemxp
YiBMaWNlbnNlKQpDb3B5cmlnaHQgMTk5NS0yMDE3IEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsg
QWRsZXIKSW52ZW50ZWQgMTk5MCBQaGlsbGlwIFdhbHRlciBLYXR6AAoKemxpYiDCuyBzc2UyIGZp
bGwgd2luZG93ICh6bGliIExpY2Vuc2UpCkNvcHlyaWdodCAyMDEzIEludGVsIENvcnBvcmF0aW9u
CkF1dGhvcnM6IEFyamFuIHZhbiBkZSBWZW4sIEppbSBLdWt1bmFzAAoKQ2hyb21pdW0gKEJTRC0z
IExpY2Vuc2UpCkNvcHlyaWdodCAyMDE3IFRoZSBDaHJvbWl1bSBBdXRob3JzAAoKaW5mbGF0ZSAx
LjIuMTEgKHpsaWIgTGljZW5zZSkKQ29weXJpZ2h0IDE5OTUtMjAxNyBNYXJrIEFkbGVyCkludmVu
dGVkIDE5OTAgUGhpbGxpcCBXYWx0ZXIgS2F0egAKCmdkdG9hIChNSVQgTGljZW5zZSkKVGhlIGF1
dGhvciBvZiB0aGlzIHNvZnR3YXJlIGlzIERhdmlkIE0uIEdheQpLdWRvcyBnbyB0byBHdXkgTC4g
U3RlZWxlLCBKci4gYW5kIEpvbiBMLiBXaGl0ZQpDb3B5cmlnaHQgKEMpIDE5OTcsIDE5OTgsIDIw
MDAgYnkgTHVjZW50IFRlY2hub2xvZ2llcwAKQVZYMiBTSEEtMSAoQlNELTMgTGljZW5zZSkKQ29w
eXJpZ2h0IDIwMTQgSW50ZWwgQ29ycG9yYXRpb24KAApBVlgyIFNIQS0yNTYgKEJTRC0yIExpY2Vu
c2UpCkNvcHlyaWdodCAyMDEzIEludGVsIENvcnBvcmF0aW9uCgAKQVZYMiBTSEEtNTEyIChCU0Qt
MiBMaWNlbnNlKQpDb3B5cmlnaHQgMjAxMyBJbnRlbCBDb3Jwb3JhdGlvbgoAAJAAAEFjY2Vzc0No
ZWNrAAAARHVwbGljYXRlVG9rZW4AAAAAR2V0RmlsZVNlY3VyaXR5VwAAAABNYXBHZW5lcmljTWFz
awAAAABPcGVuUHJvY2Vzc1Rva2VuAAAAAFJlZ0Nsb3NlS2V5AAAAUmVnRW51bUtleUV4VwAAAFJl
Z0dldFZhbHVlVwAAAABSZWdPcGVuS2V5RXhXAAAAUmVnUXVlcnlJbmZvS2V5VwAADx9AAEMAR2V0
QWRhcHRlcnNBZGRyZXNzZXMAAAAAQWRkVmVjdG9yZWRFeGNlcHRpb25IYW5kbGVyAAAAQ2xvc2VI
YW5kbGUAAABDcmVhdGVEaXJlY3RvcnlXAAAAAENyZWF0ZUZpbGVNYXBwaW5nTnVtYVcAAAAAQ3Jl
YXRlRmlsZVcAAABDcmVhdGVOYW1lZFBpcGVXAAAAAENyZWF0ZVBpcGUAAAAAQ3JlYXRlUHJvY2Vz
c1cAAAAARGVsZXRlRmlsZVcAAABEdXBsaWNhdGVIYW5kbGUAAABFeGl0UHJvY2VzcwAAAEZpbmRD
bG9zZQAAAEZpbmRGaXJzdEZpbGVXAAAAAEZpbmROZXh0RmlsZVcAAABGbHVzaEZpbGVCdWZmZXJz
AAAAAEZyZWVFbnZpcm9ubWVudFN0cmluZ3NXAAAAR2VuZXJhdGVDb25zb2xlQ3RybEV2ZW50AAAA
AEdldENvbW1hbmRMaW5lVwAAAEdldENvbXB1dGVyTmFtZUV4VwAAAABHZXRDb25zb2xlTW9kZQAA
AABHZXRDdXJyZW50RGlyZWN0b3J5VwAAAABHZXRDdXJyZW50UHJvY2VzcwAAAEdldEN1cnJlbnRQ
cm9jZXNzSWQAAABHZXRDdXJyZW50VGhyZWFkAAAAAEdldEVudmlyb25tZW50U3RyaW5nc1cAAAAA
R2V0RW52aXJvbm1lbnRWYXJpYWJsZVcAAABHZXRFeGl0Q29kZVByb2Nlc3MAAAAAR2V0RmlsZUF0
dHJpYnV0ZXNXAAAAAEdldEZpbGVJbmZvcm1hdGlvbkJ5SGFuZGxlAAAAAEdldEZpbGVJbmZvcm1h
dGlvbkJ5SGFuZGxlRXgAAAAAR2V0RmlsZVR5cGUAAABHZXRGaW5hbFBhdGhOYW1lQnlIYW5kbGVX
AAAAR2V0TGFzdEVycm9yAAAAAEdldE1vZHVsZUZpbGVOYW1lQQAAAABHZXRNb2R1bGVIYW5kbGVB
AAAAAEdldFByb2NBZGRyZXNzAAAAAEdldFByb2Nlc3NJZAAAAABHZXRQcm9jZXNzVGltZXMAAABH
ZXRTdGRIYW5kbGUAAAAAR2V0U3lzdGVtRGlyZWN0b3J5QQAAAEdldFN5c3RlbVRpbWVBc0ZpbGVU
aW1lAAAAR2V0VGVtcFBhdGhXAAAAAEdldFRocmVhZFRpbWVzAAAAAEdldFdpbmRvd3NEaXJlY3Rv
cnlBAAAAAExvY2tGaWxlRXgAAAAATWFwVmlld09mRmlsZUV4TnVtYQAAAFJlT3BlbkZpbGUAAAAA
UmVhZEZpbGUAAAAAUmVtb3ZlRGlyZWN0b3J5VwAAAABTZXRDb25zb2xlQ1AAAAAAU2V0Q29uc29s
ZUN0cmxIYW5kbGVyAAAAU2V0Q29uc29sZU1vZGUAAAAAU2V0Q29uc29sZU91dHB1dENQAAAAAFNl
dEVuZE9mRmlsZQAAAABTZXRFbnZpcm9ubWVudFZhcmlhYmxlVwAAAFNldEZpbGVQb2ludGVyRXgA
AAAAU2V0RmlsZVRpbWUAAABTbGVlcAAAAFNsZWVwRXgAAABVbmxvY2tGaWxlRXgAAAAAVW5tYXBW
aWV3T2ZGaWxlAAAAVmlydHVhbFByb3RlY3QAAAAAV2FpdEZvck11bHRpcGxlT2JqZWN0cwAAAABX
YWl0Rm9yU2luZ2xlT2JqZWN0AAAAV3JpdGVGaWxlAGYPH0QAACkAV1NBQWNjZXB0AHQAV1NBQ2xl
YW51cAAALQBXU0FDbG9zZUV2ZW50ADIAV1NBQ3JlYXRlRXZlbnQAAG8AV1NBR2V0TGFzdEVycm9y
AFgAV1NBUG9sbABdAFdTQVJlY3ZGcm9tAGMAV1NBU2VuZFRvAHgAV1NBU29ja2V0VwAAcwBXU0FT
dGFydHVwAAACAGJpbmQAAAMAY2xvc2Vzb2NrZXQABgBnZXRzb2NrbmFtZQAKAGlvY3Rsc29ja2V0
AA0AbGlzdGVuAAAVAHNldHNvY2tvcHQAAIAABAAAAAAAAAAAAHXlAwAAIAQA2AAEAAAAAAAAAAAA
AOUDAFggBADoAAQAAAAAAAAAAADA7QMAaCAEAPgCBAAAAAAAAAAAAA3lAwB4IgQAAAAAAAAAAAAA
AAAAAAAAAAAAAAAPH0AAgPkDAAAAAACO+QMAAAAAAKD5AwAAAAAAtPkDAAAAAADG+QMAAAAAANr5
AwAAAAAA6PkDAAAAAAD4+QMAAAAAAAj6AwAAAAAAGPoDAAAAAAAAAAAAAAAAADD6AwAAAAAAAAAA
AAAAAABI+gMAAAAAAGb6AwAAAAAAdPoDAAAAAACI+gMAAAAAAKL6AwAAAAAAsPoDAAAAAADE+gMA
AAAAANL6AwAAAAAA5PoDAAAAAADy+gMAAAAAAAT7AwAAAAAAEvsDAAAAAAAe+wMAAAAAADD7AwAA
AAAAQPsDAAAAAABU+wMAAAAAAG77AwAAAAAAivsDAAAAAACc+wMAAAAAALL7AwAAAAAAxPsDAAAA
AADc+wMAAAAAAPD7AwAAAAAABvwDAAAAAAAa/AMAAAAAADT8AwAAAAAATvwDAAAAAABk/AMAAAAA
AHr8AwAAAAAAmPwDAAAAAAC4/AMAAAAAAMb8AwAAAAAA4vwDAAAAAADy/AMAAAAAAAj9AwAAAAAA
HP0DAAAAAAAu/QMAAAAAAD79AwAAAAAAUP0DAAAAAABg/QMAAAAAAHb9AwAAAAAAkP0DAAAAAACg
/QMAAAAAALL9AwAAAAAAyv0DAAAAAADY/QMAAAAAAO79AwAAAAAA/P0DAAAAAAAI/gMAAAAAABz+
AwAAAAAALP4DAAAAAABE/gMAAAAAAFb+AwAAAAAAbP4DAAAAAAB8/gMAAAAAAJb+AwAAAAAAqv4D
AAAAAAC4/gMAAAAAAMD+AwAAAAAAyv4DAAAAAADa/gMAAAAAAOz+AwAAAAAA/v4DAAAAAAAY/wMA
AAAAAC7/AwAAAAAAAAAAAAAAAABA/wMAAAAAAEz/AwAAAAAAWv8DAAAAAABq/wMAAAAAAHz/AwAA
AAAAjv8DAAAAAACY/wMAAAAAAKb/AwAAAAAAsv8DAAAAAADA/wMAAAAAAM7/AwAAAAAA1v8DAAAA
AADk/wMAAAAAAPL/AwAAAAAAAAAEAAAAAAAKAAQAAAAAAAAAAAAAAAAAyhdAAAAAAADcF0AAAAAA
AO4XQAAAAAAAsRpAAAAAAAAY5QMAAAAAACnlAwAAAAAAQOUDAAAAAABa5QMAAAAAAAAAAAAAAAAA
AQABBAEIAQwBEAEUARgUKAEcBCgBIBcoASgcKAEkAAABAAEBAQIBAwIEAgUEBgQHCAgICRAKEAsg
DCANQA5ADwIAARABEQISAhMEFAQVCBYIFxAYEBkgGiAbQBxAHQAAAQABAQECAQMBBAEFAQYBBwII
AgkCCgILBAwEDQQOBA8IEAgRCBIIExAUEBUQFhAXIBggGSAaHxsBHAAAAAAAAIy4sJ2Ojo6Oenp6
enp6enpISEhISEhISEhISEhISEhISD8NAAAAAABuoJyYhoaGhnBwcHBwcHBwPz8/Pz8/Pz8/Pz8/
Pz8/Pz82DQAAAAAAHwABAEwZ/wEADzAADy/4AyIADRD+SQAjv7YOAEI/AP8XOQAAXgAXASgAksC/
nz0AAACAAoYAFwcaABP/KACR+A8gAADA++8+DgAbDooAJv//NwCiFP4h/gAMAAAAAhAAQBAeIAAQ
ACNABhAAIIY5GgAkIwAQACG+ISAAE/wwAEGQHiBAQAATBF4AIgEgCAATEZMAOME9YGAAMZBAMEAA
EwAPARMYcAAGnwAnBFwNAEjyB4B/HQBF8h8APw0AQwMAAKBXAFD+f9/g/0EBKB9ALwD/AOD9ZgAA
AMMBAB4AZCAAIMwBCw/SAR0GZgAfAAEAYhMcBAAmDABCAVKwP0D+D+gAGnguACZgAIUBBBQAT4cB
BA5gAAcigAkIAGNAf+Uf+J8qAQWOAREPBgAy0BcEcAIB0AEjPDsyABOj3gEv8M9YAABv9//9IRAD
jAEMH/sfAS5S+AAAAHwLACzf/2IALwEAAQD/ax2A/wEcgKIBD2gAMhk8DgAvBgABAP//////////
////////syCA9/YSKMAA+xIPMwAMI0QI9BELGAARMGAPEQNwD2LAPwAAgP9MAAIQFCDIMwYABSkT
Un5mAAgQ+BMCEQAhncFDEi8wQHwACi8gIZYK////////////2x9AYB9LLwAABhoIH4A/AAwfDn8A
LB8gHQAJDj4cL8AH3QG9Im7wIx4PHAABH2BkADQf8EQAMAX0IAsYABoCsR4DchwkeCbaAQDwDDOA
7x8uABMIUg1IwH8AHmYCH9PkAgE2gPgHwCAAfgA/wB8fxwIGGVwoAz/4hQ2xHAsisAGjDQQwABmn
3gApKL94IC+8DzgODR//9BwgIPAMdAAR/tICUvh5gAB+TAM//H8DTAAfF3+xAFv8///8bSAAJn60
IQAfo1gAGB8YIwf//5Yv/wH7Df///////8kE8AoffxwZcAQIAB8HMBj///////////+WL2APXyX/
/4ddA/j/5w8wNAVmNw+6FOIBAQASfy06IB8gASY/+P7/wACXX3////nbEw4OH3+5GiQP2gGpCvQA
P/AHAAEA////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////0ZXAgAA
AP8BAAwgAB//AQAHUP///wAAAAAAAAAfAAEA//8OF/8BAA8wAf8Sr4iZ8K2u+ysAgfsTAfY/DAAG
GgAELx4JXAAtQ2AAADCpAhAPBgDzDYAAAAgAAgwAYDBAEAAABCwkIAwAAAABAAAAULgzABDgEQAf
gAABWBIYBwAfIbADVRb7sgM/DwD/AQAGET81AQMNAE5//v//CwBB////4AYABxMAEX8GABcHXgAC
EgAvAP8BAP///10OoAcPAQD/////////////vhMfZw4PDBODHx9gEz0PYwb//////2YvDwABAP//
+QSwGi/R4AAd/xAPqBUhD6IAUBIDpgA/9/9/2QQACM0ZGwEcAC9/AAEA//////////////////gf
D4AY///xDwADTB8HBAj/////kg/FBBADJxZPBwDwAGsbHw8EEP////////+UHxAZAAUPIjkFKUD+
1QwSBxQIbw//AQMAP2AIBDQB4L8QCBXfNjgQhwgAFRFkCB/9QAgDFZ+tOBF4TR8QBPM5B7QAHPhq
HwXeOG8QJwAAGPCBDQoPnggSGOCPACB7/AYAIOfHBQAP4B8BXw8HBwA/4CCbDwEA////////////
//////////////////////////////8LHz/8H///////////////////////////////////////
////CFD/////PwAAAACQAAQCARyc//////////8BgBCABADnBwAEAAAHDTAxLyMlCVkQVQo1PTYL
JyFFEQ4bQEFSViQEFgU4FT4YHyg/MjQzFzcTAghNDFMAKhxODzkUQl8mLRkGLVRgAS4gXCspIkf/
//////////8BHjosHQNGPDw7GkQSAAsBDA0CA/7MkYAIAgEDgCAQgAgAAgEUJd0DSv8fSQXUAkIH
BAMIQICAQIAEgIAEgIAIgBAAgAIEAAKACAEBBAIKFBEMHh8EpNLBgAyAAYYgBIAEhSCAgICAAYCA
gIAC//8DBIEIAP///////////wH+//////////8BAQAEAgEKnP//////////AYAEgAIRHxkBAAAH
DWJjYQtyCUoQfQpnb2gjWSF6EQ4bcHErVHMEFgVqFSgYH1okZGZlF2kTAgglDCpAXBwmD2sUJ4MB
WF8ZBl9LggEBYCBHXVsiQlUebF4dA3Q+bm0aVxIABQAGBwIBoagBAgACIBCAAoCAAgLnASc+CQr/
HwsCDjo9AQOACIBAgIAgQICAAYCABIABgIAQgIAIgBAAAoAEAQEEAgcREx8KDICAgIAIkpICDRQC
DxWAgCCAEAEDFwz/////A/7///8DAQAEAgEYnP//////////AYAQgAQA3g8AAwAABw0wMS8jJQlY
EFcKNT02CychRREOG0BBUlUkBBYFOBU+GB8oPzI0Mxc3EwIITQxTACocTg85FEJiJlYZBi1UYQEu
IGArKSJH/f//////////AR46LB0DRlw8OxpEEgAHAQgJAgP+zJGACAIBA4AgEICAAQACARQlxQFK
/x9JBaUCQsEDBAMIQICAgAKABICAIICAgAGAEACAAgQAAoAIAQEEAgoUEQweHwSk0sGADIABjCAE
gASLIICAgIABgICAgAL//wMAAAD/////A/7///8DAQAEAgEYnP//////////AQgCAOcHAAMAAAcN
MDEvIyUJXBBYCjU9NgsnIUURDhtAQVlUJAQWBTgVPhgfKD8yNDMXNxMCCE0MWgAqHE4PORRCXSZb
GQYtV14BLiBfKykiR////////////wEeOiwdA0Y8PDsaRBIABwEICQID/syRgAgCAQOAIBCAgAEA
AgEUesUBSiVJBTBCCwQDCECAgASABACAgAiAEACAAgQAAoAIAQEEAgoUEQweHwSk0sGADIABhiAE
gASFIICAAoCAAf//AxAAAP7//////////wH///////////8BAQCAgICACICAgIAEgICAgAoXnP//
////////AYAEAAAfAAEAAOcMBcBOwU6/TrNOtU4GAKoBAIABxU7NTsZO6wi3TiHVTrcB5wPfAdBO
0U4AALROlE5X3QjITosCzk7QAgS4Ts9Owk7ETsNOywLHTrAJAsEBAA4AALpOJwEayU4DkQEAtk69
Tt4I2Ai9TgAADL5ObQC7TrlOItdOAPkuyk68Thm2BNZOAMxOy06UAdROEQAFAAYHAgH+zJGACICA
gEAAAiAQgIBAAAL/H/8f/x//H/8f/x//H/8f/x//H/8f/x+AgICADgQAgIAgQICAgAGAgIAQgAEA
AIAQgICAgAqAgICADoAEgICAgASABhCACAcREx8KDICAgIAIAIABhiAABIUggIAggBD//wMADwD+
//////////8B////////////AQAABAIBHv7//////////wGAASAAHwABAAAHDTAxLyMlCV4QWQo1
PTYLJyFFEQ4bQEFaXCQEFgU4FT4YHyg/MjQzFzcTAghNDFsAKhxODzkUQmgmLRkGZlRpAS4gZCsp
Ikf///////////8BHjosHQNGZTw7GkQSAAcBCAkCA/7MkYAIAgEDgCAQAAACgYCAEJSAgBClgIAQ
xYGAEMqAgBD/H8mAgBCFgIAQsICAEMKAgBCHgIAQhICAEAMIQICAgAiABACAgECAEACAAgQAAoAI
AQEEAgoUEQweHwSk0rGADIABhiAEgASFIICAIIAQ//8DBAAA/////wP+////AwFmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYu
Dx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAA
AGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QA
AAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4P
H4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYu
Dx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAA
AGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QA
AAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4P
H4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYu
Dx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAA
AGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QA
AAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4P
H4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYu
Dx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAA
AGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QA
AAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4P
H4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYu
Dx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAA
AGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QA
AAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4P
H4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYu
Dx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAA
AGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QA
AAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4P
H4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAA
Zi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAA
AAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8f
hAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABm
Lg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAA
AABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+E
AAAAAABmLg8fhAAAAAAAZi4PH4QAAAAAAGYuDx+EAAAAAAAPH4AAAAAAgPkDAAAAAACO+QMAAAAA
AKD5AwAAAAAAtPkDAAAAAADG+QMAAAAAANr5AwAAAAAA6PkDAAAAAAD4+QMAAAAAAAj6AwAAAAAA
GPoDAAAAAAAAAAAAAAAAADD6AwAAAAAAAAAAAAAAAABI+gMAAAAAAGb6AwAAAAAAdPoDAAAAAACI
+gMAAAAAAKL6AwAAAAAAsPoDAAAAAADE+gMAAAAAANL6AwAAAAAA5PoDAAAAAADy+gMAAAAAAAT7
AwAAAAAAEvsDAAAAAAAe+wMAAAAAADD7AwAAAAAAQPsDAAAAAABU+wMAAAAAAG77AwAAAAAAivsD
AAAAAACc+wMAAAAAALL7AwAAAAAAxPsDAAAAAADc+wMAAAAAAPD7AwAAAAAABvwDAAAAAAAa/AMA
AAAAADT8AwAAAAAATvwDAAAAAABk/AMAAAAAAHr8AwAAAAAAmPwDAAAAAAC4/AMAAAAAAMb8AwAA
AAAA4vwDAAAAAADy/AMAAAAAAAj9AwAAAAAAHP0DAAAAAAAu/QMAAAAAAD79AwAAAAAAUP0DAAAA
AABg/QMAAAAAAHb9AwAAAAAAkP0DAAAAAACg/QMAAAAAALL9AwAAAAAAyv0DAAAAAADY/QMAAAAA
AO79AwAAAAAA/P0DAAAAAAAI/gMAAAAAABz+AwAAAAAALP4DAAAAAABE/gMAAAAAAFb+AwAAAAAA
bP4DAAAAAAB8/gMAAAAAAJb+AwAAAAAAqv4DAAAAAAC4/gMAAAAAAMD+AwAAAAAAyv4DAAAAAADa
/gMAAAAAAOz+AwAAAAAA/v4DAAAAAAAY/wMAAAAAAC7/AwAAAAAAAAAAAAAAAABA/wMAAAAAAEz/
AwAAAAAAWv8DAAAAAABq/wMAAAAAAHz/AwAAAAAAjv8DAAAAAACY/wMAAAAAAKb/AwAAAAAAsv8D
AAAAAADA/wMAAAAAAM7/AwAAAAAA1v8DAAAAAADk/wMAAAAAAPL/AwAAAAAAAAAEAAAAAAAKAAQA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAwQUAAAACACBsMlSCoemCh0BAAAq
AgAAGgAAAHVzci9zaGFyZS96b25laW5mby9CZWlqaW5npdC9TsJQHIbxP35LHBpXv46oCIOLgzHR
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
AQAYAD0eU93sXNcB32sXHiRd1wE9HlPd7FzXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQItAxQAAAAIAIGw
yVJQRM1sRQQAAB8JAAAZACQAuwAAAAAAAACkgVUxBAB1c3Ivc2hhcmUvem9uZWluZm8vQmVybGlu
CgAgAAAAAAABABgAPR5T3exc1wHfaxceJF3XAT0eU93sXNcBAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQIt
AxQAAAAIAIGwyVKAbe1/kgQAAJUJAAAaACQAugAAAAAAAACkgdE1BAB1c3Ivc2hhcmUvem9uZWlu
Zm8vQm91bGRlcgoAIAAAAAAAAQAYAD0eU93sXNcB32sXHiRd1wE9HlPd7FzXAQAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAFBLAQItAxQAAAAIAIGwyVLigJjqqgYAAAEOAAAaACQAugAAAAAAAACkgZs6BAB1c3Ivc2hh
cmUvem9uZWluZm8vQ2hpY2FnbwoAIAAAAAAAAQAYAD0eU93sXNcB32sXHiRd1wE9HlPd7FzXAQAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAFBLAQItAxQAAAAIAIGwyVK2mTxuQQUAAB0LAAAWACQAvgAAAAAAAACkgX1B
BAB1c3Ivc2hhcmUvem9uZWluZm8vR1NUCgAgAAAAAAABABgAPR5T3exc1wHfaxceJF3XAT0eU93s
XNcBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQItAxQAAAAIAIGwyVL9kge7lgAAAFIBAAAbACQAuQAA
AAAAAACkgfJGBAB1c3Ivc2hhcmUvem9uZWluZm8vSG9ub2x1bHUKACAAAAAAAAEAGAA9HlPd7FzX
Ad9rFx4kXdcBPR5T3exc1wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQItAxQAAAAIAIGwyVKiW1yhXQQAABEJ
AAAZACQAuwAAAAAAAACkgcFHBAB1c3Ivc2hhcmUvem9uZWluZm8vSXNyYWVsCgAgAAAAAAABABgA
PR5T3exc1wHfaxceJF3XAT0eU93sXNcBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQItAxQAAAAIAIGwyVIf
wYFzlAAAAD4BAAAYACQAvAAAAAAAAACkgVVMBAB1c3Ivc2hhcmUvem9uZWluZm8vSmFwYW4KACAA
AAAAAAEAGAA9HlPd7FzXAd9rFx4kXdcBPR5T3exc1wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQItAxQA
AAAIAIGwyVLUrLyq0gYAAGcOAAAZACQAuwAAAAAAAACkgR9NBAB1c3Ivc2hhcmUvem9uZWluZm8v
TG9uZG9uCgAgAAAAAAABABgAPR5T3exc1wHfaxceJF3XAT0eU93sXNcBAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AFBLAQItAxQAAAAIAIGwyVL1UoFsGwQAAK8IAAAcACQAuAAAAAAAAACkgShUBAB1c3Ivc2hhcmUv
em9uZWluZm8vTWVsYm91cm5lCgAgAAAAAAABABgAPR5T3exc1wHfaxceJF3XAT0eU93sXNcBAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAFBLAQItAxQAAAAIAIGwyVJveFiNjAYAANkNAAAbACQAuQAAAAAAAACkgX1YBAB1
c3Ivc2hhcmUvem9uZWluZm8vTmV3X1lvcmsKACAAAAAAAAEAGAA9HlPd7FzXAd9rFx4kXdcBPR5T
3exc1wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAFBLAQItAxQAAAAIAIGwyVJmJyjqrgAAAJoBAAAcACQAuAAAAAAA
AACkgUJfBAB1c3Ivc2hhcmUvem9uZWluZm8vU2luZ2Fwb3JlCgAgAAAAAAABABgAPR5T3exc1wHf
axceJF3XAT0eU93sXNcBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBLAQIeAxQAAAAIAGcw41LmVt/vKwIAAMACAAAE
ABgAAAAAAAAAAACkgSpgBAAuYXBlVVQFAAMSYOBgdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgA
gbDIUjm9dmoHGAAAPkIAAAsAGAAAAAAAAAAAAKSBk2IEAGZhdmljb24uaWNvVVQFAAPCS8BgdXgL
AAEE6AMAAAToAwAAUEsBAh4DCgAAAAAAgbDIUuavwobREwAA0RMAAAsAGAAAAAAAAAAAAKSB33oE
AHJlZGJlYW4ucG5nVVQFAAPCS8BgdXgLAAEE6AMAAAToAwAAUEsBAh4DFAAAAAgA71wNU37rt67k
UgAAHAoBAA0AGAAAAAAAAQAAALSB9Y4EAHBhbm5lbGx1bS5odG1VVAUAA9I9FmF1eAsAAQToAwAA
BOgDAABQSwUGAAAAABAAEAAHDwAAIOIEAAAA
"""

def dms2dd(degrees, minutes, seconds, direction):
    dd = float(degrees) + float(minutes)/60 + float(seconds)/(60*60)
    if direction == 'S' or direction == 'W':
        dd *= -1
    return dd

def exif_data(file):
    img = PIL.Image.open(file)
    tags = img._getexif()

    if not tags or not 34853 in tags:
        return None
    gpstag = tags[34853]
    if not 1 in gpstag or not 2 in gpstag:
        return None

    gpstag_latitude_ref = gpstag[1]
    gpstag_latitude = gpstag[2]
    try:
        gpstag_latitude_degrees = float(gpstag_latitude[0]);
        gpstag_latitude_minutes = float(gpstag_latitude[1]);
        gpstag_latitude_seconds = float(gpstag_latitude[2]);
    except:
        gpstag_latitude_degrees = gpstag_latitude[0][0] / gpstag_latitude[0][1];
        gpstag_latitude_minutes = gpstag_latitude[1][0] / gpstag_latitude[1][1];
        gpstag_latitude_seconds = gpstag_latitude[2][0] / gpstag_latitude[2][1];
    latitude = dms2dd(gpstag_latitude_degrees, gpstag_latitude_minutes,
                      gpstag_latitude_seconds, gpstag_latitude_ref);
    
    gpstag_longtitude = gpstag[4]
    gpstag_longtitude_ref = gpstag[3]
    try:
        gpstag_longtitude_degrees = gpstag_longtitude[0];
        gpstag_longtitude_minutes = gpstag_longtitude[1];
        gpstag_longtitude_seconds = gpstag_longtitude[2];
    except:
        gpstag_longtitude_degrees = gpstag_longtitude[0][0] / gpstag_longtitude[0][1];
        gpstag_longtitude_minutes = gpstag_longtitude[1][0] / gpstag_longtitude[1][1];
        gpstag_longtitude_seconds = gpstag_longtitude[2][0] / gpstag_longtitude[2][1];
        
    longtitude = dms2dd(gpstag_longtitude_degrees, gpstag_longtitude_minutes,
                        gpstag_longtitude_seconds, gpstag_longtitude_ref);

    output = {"lat":latitude, "lng":longtitude}

    if 5 in gpstag and 6 in gpstag:
        try:
            altitude = float(gpstag[6])
        except:
            altitude = gpstag[6][0] / gpstag[6][1]
        above_sea_level = gpstag[5]
        if above_sea_level == 1:
            altitude *= -1
        output["altitude"] = altitude

    if 36867 in tags:
        output["date"] = str(tags[36867])

    if 271 in tags or 272 in tags:
        output["camera"] = ""
        if 271 in tags:
            output["camera"] += tags[271] + " "
        if 272 in tags:
            output["camera"] += tags[272]

    with open(file, "br") as f:
        full = f.read()
        if full.find("ProjectionType".encode()) != -1 and full.find("equirectangular".encode()) != -1:
            output["ProjectionType"] = "equirectangular"

    return output

def make_map_with_photos(files, outputname):
    has_360 = False
    photos_added = 0
    gpxtracks_added = 0
    skipped = 0
    photos_string = ""
    gpxs_string = ""
    for file in files:
        if file.lower().endswith(".gpx"):
            with open(file, 'r') as gpxfile:
                gpxfilecontents = json.dumps(gpxfile.read());
                gpxs_string += "new L.GPX("+gpxfilecontents+", {async: true}).on('click', gpxclick).addTo(mymap);"
            gpxtracks_added += 1
        else:
            exif = exif_data(file);
            if exif:
                latitude = exif["lat"]
                longtitude = exif["lng"]
                photos_string += "{\"lat\":"+str(latitude)+", \"lng\":"+str(longtitude)
                url = file
                if "ProjectionType" in exif and exif["ProjectionType"] == "equirectangular":
                    has_360 = True
                    url = "http://localhost:8080/pannellum.htm#autoLoad=true&maxHfov=170&panorama=http://localhost:8080/"+file
                photos_string += ", \"thumbnail\":\""+file+"\", \"url\":\""+url+"\""
                photos_string += ", \"name\":\""+file
                if "date" in exif:
                    photos_string += "<br/>"+exif["date"]
                if "altitude" in exif:
                    photos_string += "<br/>Altitude: "+str(exif["altitude"])+"m"
                if "camera" in exif:
                    photos_string += "<br/>Camera: " + str(exif["camera"])
                if "ProjectionType" in exif and exif["ProjectionType"] == "equirectangular":
                    photos_string += "<br/>360"
                photos_string += "\"},\n"
                photos_added += 1
            else:
                skipped += 1
            
    html = template.replace("{{{PHOTOS}}}", photos_string).replace("{{{GPXS}}}", gpxs_string);
    open(outputname, "w").write(html)

    if has_360:
        outf = "redbean-original-1.4.com"
        open(outf, "wb").write(base64.b64decode(redbeanbinary))
        mode = os.stat(outf).st_mode
        mode |= stat.S_IEXEC
        os.chmod(outf, mode)
        outf2 = "map.bat"
        open(outf2, "w").write("""
:; trap 'killall redbean-original-1.4.com' INT
:; ./redbean-original-1.4.com -D . -vv &
:; browse {0}
:; sleep 999999999
:; exit 0
start redbean-original-1.4.com -D . -vv
start {0}
""".format(outputname))
        mode = os.stat(outf2).st_mode
        mode |= stat.S_IEXEC
        os.chmod(outf2, mode)


    return {"photos_added": photos_added, "gpxtracks_added": gpxtracks_added, "skipped": skipped}

if __name__ == "__main__":
    if len(sys.argv) >= 2:
        print(make_map_with_photos(sys.argv[1:], "map.html"))
    else:
        print("Usage: " + sys.argv[0] + " file1.jpg file2.jpg file3.gpx ...")
